<!DOCTYPE HTML>
<html>
<head>
  <meta name="google-site-verification" content="C99UqEDEOWXxRodhn8sWg1NRTdOgYZPbS0mgBURT9Pw" />
  <meta name="msvalidate.01" content="86FFF123B293617931E24F9B61CA5E1E" />
  <meta name="baidu-site-verification" content="GDPyw3Yidj" />
  <meta charset="utf-8">
  
  <title>C++20协程入门教程 | Zplutor&#39;s</title>
  <meta name="author" content="Zplutor">
  
  <meta name="description" content="1. 前言随着Visual Studio 2022的发布，C++20终于来到了我们的眼前，在这个标准的新特性之中，最吸引人之一的是协程，对于饱受异步调用之繁琐写法的人来说，协程似乎是解决异步问题的灵丹妙药。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="C++20协程入门教程"/>
  <meta property="og:site_name" content="Zplutor&#39;s"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Zplutor&#39;s" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Zplutor&#39;s</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/atom.xml">Feed</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2022-03-24T16:05:57.000Z"><a href="/2022/03/25/cpp-coroutine-beginner/">2022-03-25</a></time>
      
      
  
    <h1 class="title">C++20协程入门教程</h1>
  

    </header>
    <div class="entry">
      
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>随着Visual Studio 2022的发布，C++20终于来到了我们的眼前，在这个标准的新特性之中，最吸引人之一的是协程，对于饱受异步调用之繁琐写法的人来说，协程似乎是解决异步问题的灵丹妙药。</p>
<span id="more"></span>

<p>最初我对协程一无所知，当我开始学习它的时候，才发现它的复杂程度超出了我的预期。在网络上关于C++协程的文章有很多，但能够从初学者的角度把协程的基础原理讲清楚的寥寥无几。而且在 <a target="_blank" rel="noopener" href="http://cppreference.com/">cppreference.com</a> 上关于协程的页面仍然是未完成的状态，不少组件的文档仍然是空缺的。</p>
<p>在这样的背景下，学习过程是比较曲折的。我阅读了各种不同的文章，运行并调试其中的示例代码，最终才理解了C++的协程是怎么回事。在这篇文章中，我将自己的学习经历作为参考，从入门的角度来介绍C++协程。希望这篇文章能帮助大家更容易学习和理解协程。</p>
<h2 id="2-什么是协程"><a href="#2-什么是协程" class="headerlink" title="2. 什么是协程"></a>2. 什么是协程</h2><p>学习协程遇到的第一个问题是：什么是协程？一个简短的回答是：协程是一个函数，它可以暂停以及恢复执行。按照我们对普通函数的理解，函数暂停意味着线程停止运行了（就像命中了断点一样），那协程的不同之处在哪里呢？区别在于，普通函数是线程相关的，函数的状态跟线程紧密关联；而协程是线程无关的，它的状态与任何线程都没有关系。</p>
<p>这个解释比较抽象，为了更好地理解，我们先来回顾一下函数的调用机制。在调用一个函数的时候，线程的栈上会记录这个函数的状态（参数、局部变量等），这是通过移动栈顶指针来完成的。例如，函数 <code>Foo()</code> 调用 <code>Bar()</code> 的过程如下所示：</p>
<img src="/2022/03/25/cpp-coroutine-beginner/1.png" class="">

<p>首先，“地址3”到“地址2”这段空间，是分配给 <code>Foo()</code> 保存状态使用的，栈顶指针指向“地址2”；当调用 <code>Bar()</code> 的时候，栈顶指针移动到“地址1”，此时“地址2”到“地址1”这段空间是分配给 <code>Bar()</code> 保存状态使用的。当 <code>Bar()</code> 执行完毕，栈顶指针移动回“地址2”， <code>Bar()</code> 的状态被销毁，内存空间被回收。</p>
<p>由此可见，函数状态的维护完全依赖于线程栈，脱离了线程，函数就不复存在，所以说函数是线程相关的。</p>
<p>而协程不一样，协程的状态是保存在堆内存上的。假设 <code>Bar()</code> 是一个协程，那么调用它的过程如下所示：</p>
<img src="/2022/03/25/cpp-coroutine-beginner/2.png" class="">

<p>首先， <code>Bar()</code> 的状态所需的内存会在堆上分配，独立于线程栈而存在。传递给它的参数都会复制到这个状态中，而局部变量会直接在这个状态中创建。调用 <code>Bar()</code> 的时候，由于本质上还是一个函数调用，所以栈顶指针也会往下移动，在栈上给执行 <code>Bar()</code> 所需的状态分配空间，其中会有一个引用指向在堆上的状态，这样一来， <code>Bar()</code> 就可以像一个普通函数那样执行了，线程也可以访问到位于堆上的状态。</p>
<p>如果协程需要暂停，那么当前执行到的代码位置会记录到堆的状态中。然后栈上的执行时状态被销毁，栈顶指针移动以回收空间，就像普通函数结束时那样。在下一次恢复执行时，堆状态中记录的暂停位置会读取出来，从这个位置接着执行。这样就实现了一个可暂停和恢复执行的函数。</p>
<p>由此可见，当协程执行的时候，它跟普通函数一样，也是需要依赖线程栈；但是，一旦它暂停了，它的状态就会独立保存在堆中，此时它跟任何线程都没有关系，调用它的线程可以继续去做其它事情而不会停止。在下一次恢复执行时，协程可以由上次执行的线程来执行，也可以由另外一个完全不同的线程来执行。所以说协程是线程无关的。</p>
<h2 id="3-协程的优点"><a href="#3-协程的优点" class="headerlink" title="3. 协程的优点"></a>3. 协程的优点</h2><p>协程的优点主要在于，它能优化异步逻辑的代码，使代码可读性更高。举个例子，假设我们有一个组件叫 <code>IntReader</code> ，它的功能是从一个访问速度很慢的设备上读取一个整数值，因此它提供的接口是异步的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BeginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::srand(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="literal">nullptr</span>)));</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> value = std::rand();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//使用 value ...</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>BeginRead()</code> 开启了一个新的线程来生成一个随机的整数，模拟异步操作。作为一个仅用于示范的代码，这里尽量保持精简。</p>
<p>为了获取到 <code>IntReader</code> 的结果，传统的做法是提供一个回调函数，当操作完成的时候，通过回调函数告知使用者。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BeginRead</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([callback]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::srand(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="literal">nullptr</span>)));</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> value = std::rand();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            callback(value);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader;</span><br><span class="line">    reader.<span class="built_in">BeginRead</span>([](<span class="type">int</span> result) &#123;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; result &lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们需要调用多个 IntReader ，把它们的结果加起来再输出，那么基于回调的代码就会很难看了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    reader1.<span class="built_in">BeginRead</span>([](<span class="type">int</span> result1) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> total = result1;</span><br><span class="line"></span><br><span class="line">        IntReader reader2;</span><br><span class="line">        reader2.<span class="built_in">BeginRead</span>([total](<span class="type">int</span> result2) &#123;</span><br><span class="line"></span><br><span class="line">            total += result2;</span><br><span class="line"></span><br><span class="line">            IntReader reader3;</span><br><span class="line">            reader3.<span class="built_in">BeginRead</span>([total](<span class="type">int</span> result3) &#123;</span><br><span class="line">            </span><br><span class="line">                total += result3;</span><br><span class="line">                std::cout &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码不仅需要一层套一层，还要在每层回调之间传递结果，这就是俗称的“回调地狱”。而有了协程，这些问题都迎刃而解，我们可以这样来调用 <code>IntReader</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> total = <span class="keyword">co_await</span> reader1;</span><br><span class="line"></span><br><span class="line">    IntReader reader2;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader2;</span><br><span class="line"></span><br><span class="line">    IntReader reader3;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader3;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑顿时清晰了不少，看上去就像同步调用那样。在每一个调用 co_await 的地方，协程都会暂停下来，等 IntReader 操作完成之后再从这个地方恢复执行。接下来，我们来看下如何实现这种效果。</p>
<h2 id="4-实现一个协程"><a href="#4-实现一个协程" class="headerlink" title="4. 实现一个协程"></a>4. 实现一个协程</h2><p>在C++中，只要在函数体内出现了 <code>co_await</code> 、<code>co_return</code> 和 <code>co_yield</code> 这三个操作符中的其中一个，这个函数就成为了协程。我们先来关注一下 <code>co_await</code> 操作符。</p>
<h3 id="4-1-co-await-和-Awaitable"><a href="#4-1-co-await-和-Awaitable" class="headerlink" title="4.1. co_await 和 Awaitable"></a>4.1. co_await 和 Awaitable</h3><p><code>co_await</code> 的作用是让协程暂停下来，等待某个操作完成之后再恢复执行。在上面的协程示例中，我们对 <code>IntReader</code> 调用了 <code>co_await</code> 操作符，目前这是不可行的，因为 <code>IntReader</code> 是我们自定义的类型，编译器不理解它，不知道它什么时候操作完成，不知道如何获取操作结果。为了让编译器理解我们的类型，C++定义了一个协议规范，只要我们的类型按照这个规范实现好，就可以在 <code>co_await</code> 使用了。</p>
<p>这个规范称作 Awaitable，它定义了若干个函数，传给 <code>co_await</code> 操作符的对象必须实现这些函数。这些函数包括：</p>
<ul>
<li><p><code>await_ready()</code>，返回类型是 <code>bool</code>。协程在执行 <code>co_await</code> 的时候，会先调用 <code>await_ready()</code> 来询问“操作是否已完成”，如果函数返回了 <code>true</code> ，协程就不会暂停，而是继续往下执行。实现这个函数的原因是，异步调用的时序是不确定的，如果在执行 <code>co_await</code> 之前就已经启动了异步操作，那么在执行 <code>co_await</code> 的时候异步操作有可能已经完成了，在这种情况下就不需要暂停，通过<code>await_ready()</code>就可以到达到这个目的。</p>
</li>
<li><p><code>await_suspend()</code>，有一个类型为 <code>std::coroutine_handle&lt;&gt;</code> 的参数，返回类型可以是 <code>void</code> 或者 <code>bool</code> 。如果 <code>await_ready()</code> 返回了 <code>false</code> ，意味着协程要暂停，那么紧接着会调用这个函数。该函数的目的是用来接收协程句柄（也就是<code>std::coroutine_handle&lt;&gt;</code> 参数），并在异步操作完成的时候通过这个句柄让协程恢复执行。协程句柄类似于函数指针，它表示一个协程实例，调用句柄上的对应函数，可以让这个协程恢复执行。</p>
<p><code>await_suspend()</code> 的返回类型一般为 <code>void</code>，但也可以是 <code>bool</code> ，这时候的返回值用来控制协程是否真的要暂停，这里是第二次可以阻止协程暂停的机会。如果该函数返回了 <code>false</code> ，协程就不会暂停（注意返回值的含义跟 <code>await_ready()</code> 是相反的）。</p>
</li>
<li><p><code>await_resume()</code>，返回类型可以是 <code>void</code> ，也可以是其它类型，它的返回值就是 <code>co_await</code> 操作符的返回值。当协程恢复执行，或者不需要暂停的时候，会调用这个函数。</p>
</li>
</ul>
<p>接下来，我们修改一下 IntReader ，让它符合 Awaitable 规范。下面是完整的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([<span class="keyword">this</span>, handle]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::srand(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="literal">nullptr</span>)));</span></span></span><br><span class="line"><span class="params"><span class="function">            value_ = std::rand();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            handle.resume();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> total = <span class="keyword">co_await</span> reader1;</span><br><span class="line"></span><br><span class="line">    IntReader reader2;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader2;</span><br><span class="line"></span><br><span class="line">    IntReader reader3;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader3;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintInt</span>();</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; line) &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先忽略返回类型 <code>Task</code> ，下文会专门介绍协程的返回类型。在这个例子中，对于 <code>await_ready()</code> 函数，我们总是返回 false，即协程总是要暂停。然后我们把子线程改成在 <code>await_supsend()</code> 中启动，也就是在协程暂停的时候来启动，因此不再需要 <code>BeginRead()</code> 函数了。子线程生成随机数之后，保存在 <code>value_</code> 成员变量中，然后调用协程句柄的 <code>resume()</code> 函数来恢复协程执行。最后通过 <code>await_resume()</code> 函数把结果返回给调用者。</p>
<p>值得关注的地方是线程的执行。在 <code>main()</code> 函数中，主线程调用了 <code>PrintInt()</code> ，执行到 <code>co_await reader1</code> 这一行，协程暂停了，于是主线程退出 <code>PrintInt()</code> ，返回到 <code>main()</code> 继续往下执行，最后在 while 循环中等待用户输入。接下来，在 <code>reader1</code>中启动的子线程调用了协程句柄的 <code>resume()</code> ，所以从 <code>co_await reader1</code> 中恢复执行的是这个子线程，直到 <code>co_await reader2</code> ，协程再次暂停，子线程退出。以此类推，后面的流程分别由 <code>reader2</code> 和 <code>reader3</code> 中启动的子线程来继续执行。所以，在 <code>PrintInt()</code> 这个协程内，总共有四个线程参与了执行。这里的关键点是：哪个线程调用协程句柄的 <code>resume()</code> ，就由哪个线程恢复协程执行。建议在IDE中设置断点来观察这个示例程序的执行流程，以便更好地理解。</p>
<h3 id="4-2-预定义的-Awaitable-类型"><a href="#4-2-预定义的-Awaitable-类型" class="headerlink" title="4.2. 预定义的 Awaitable 类型"></a>4.2. 预定义的 Awaitable 类型</h3><p>C++预定义了两个符合 Awaitable 规范的类型： <code>std::suspend_never</code> 和 <code>std::suspend_always</code> 。顾名思义，这两个类型分别表示“不暂停”和“要暂停”，实际上它们的区别仅在于 <code>await_ready()</code> 函数的返回值， <code>std::suspend_never</code> 会返回 true，而 <code>std::suspend_always</code> 会返回 false。除此之外，这两个类型的 <code>await_supsend()</code> 和 <code>await_resume()</code> 函数实现都是空的。</p>
<p>这两个类型是工具类，用来作为 <code>promise_type</code> 部分函数的返回类型，以控制协程在某些时机是否要暂停。下文会详细介绍 <code>promise_type</code> 。</p>
<h3 id="4-3-协程的返回类型和-promise-type"><a href="#4-3-协程的返回类型和-promise-type" class="headerlink" title="4.3. 协程的返回类型和 promise_type"></a>4.3. 协程的返回类型和 promise_type</h3><p>现在我们把关注点聚焦在协程的返回类型上。C++对协程的返回类型只有一个要求：包含名为 <code>promise_type</code> 的内嵌类型。跟上文介绍的 Awaitable 一样， <code>promise_type</code> 需要符合C++规定的协议规范，也就是要定义几个特定的函数。 <code>promise_type</code> 是协程的一部分，当协程被调用，在堆上为其状态分配空间的时候，同时也会在其中创建一个对应的 <code>promise_type</code> 对象。通过在它上面定义的函数，我们可以与协程进行数据交互，以及控制协程的行为。</p>
<p><code>promise_type</code> 要实现的第一个函数是 <code>get_return_object()</code> ，用来创建协程的返回值。在协程内，我们不需要显式地创建返回值，这是由编译器隐式调用 <code>get_return_object()</code> 来创建并返回的。这个关系看起来比较怪异， <code>promise_type</code> 是返回类型的内嵌类型，但编译器不会直接创建返回值，而是先创建一个 <code>promise_type</code> 对象，再通过这个对象来创建返回值。</p>
<img src="/2022/03/25/cpp-coroutine-beginner/3.png" class="">

<p>那么协程的返回值有什么用呢？这取决于协程的设计者的意图，取决于他想要以什么样的方式来使用协程。例如，在上文的示例中，<code>PrintInt()</code> 这个协程只是输出一个整数，不需要与调用者有交互，所以它的返回值只是一个空壳。 假如我们想实现一个 <code>GetInt()</code> 协程，它会返回一个整数给调用者，由调用者来输出结果，那么就需要对协程的返回类型做一些修改了。</p>
<h3 id="4-4-co-return"><a href="#4-4-co-return" class="headerlink" title="4.4. co_return"></a>4.4. co_return</h3><p>我们现在把 <code>PrintInt()</code> 修改成 <code>GetInt()</code> 。使用 <code>co_return</code> 操作符可以从协程中返回数据，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> total = <span class="keyword">co_await</span> reader1;</span><br><span class="line"></span><br><span class="line">    IntReader reader2;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader2;</span><br><span class="line"></span><br><span class="line">    IntReader reader3;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>co_return total</code> 这个表达式等价于 <code>promise_type.return_value(total)</code> ，也就是说，返回的数据会通过 <code>return_value()</code> 函数传递给 <code>promise_type</code> 对象， <code>promise_type</code> 要实现这个函数才能接收到数据。除此之外，还要想办法让返回值 <code>Task</code> 能访问到这个数据。为了减少数据传递，我们可以在 <code>promise_type</code> 和 <code>Task</code> 之间共享同一份数据。修改之后的完整示例如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([<span class="keyword">this</span>, handle]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::srand(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="literal">nullptr</span>)));</span></span></span><br><span class="line"><span class="params"><span class="function">            value_ = std::rand();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            handle.resume();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">promise_type</span>() : <span class="built_in">value_</span>(std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> Task&#123; value_ &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            *value_ = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; value_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">const</span> std::shared_ptr&lt;<span class="type">int</span>&gt;&amp; value) : <span class="built_in">value_</span>(value) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> total = <span class="keyword">co_await</span> reader1;</span><br><span class="line"></span><br><span class="line">    IntReader reader2;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader2;</span><br><span class="line"></span><br><span class="line">    IntReader reader3;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; line) &#123;</span><br><span class="line">        std::cout &lt;&lt; task.<span class="built_in">GetValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>promise_type</code> 和 <code>Task</code> 之间，使用了 <code>std::shared_ptr&lt;int&gt;</code> 来共享数据。在 <code>get_return_object()</code> 中创建 <code>Task</code> 的时候，把 <code>promise_type</code> 里的智能指针传递了过去，这样它们就能访问到同一个数据。在 <code>promise_type</code> 的 <code>return_value()</code> 中写数据，然后在 <code>Task</code> 的 <code>GetValue()</code> 中读数据。</p>
<p>异步是具有传染性的， <code>GetInt()</code> 内部调用了异步操作，所以它自身实际上也是一个异步操作。为了等待它执行完成，我们把 <code>task.GetValue()</code> 的调用放在了 while 循环中，每当用户输入一次之后就进行输出。由于这是一个简单的示例程序，没有各种高级的异步同步机制，所以通过等待用户输入方式来变相地等待协程执行完成。</p>
<p>在真实的使用场景中，协程的返回类型还需要提供各种同步机制才能给调用者使用，例如加上回调、通知等，就像普通的异步操作一样。由此可见，协程的优点体现在它内部的代码逻辑上，而不是对外的使用方式上。当然，我们也可以让协程的返回类型实现 Awaitable 规范，让它可以被另外一个协程更好地调用。这样一来，调用协程的也必须是协程，这样层层往上传递，直到遇到不能改成协程的函数为止，例如 <code>main()</code> 函数。从这个角度来说，协程也是具有传染性的。</p>
<p>最后，跟普通的 <code>return</code> 一样， <code>co_return</code> 也可以不带任何参数，这时候协程以不带数据的方式返回，相当于调用了 <code>promise_type.return_void()</code> ， <code>promise_type</code> 需要定义这个函数以支持不带数据的返回。如果我们在协程结束的时候没有调用任何 <code>co_return</code> ，那么编译器会隐式地加上一个不带参数的 <code>co_return</code> 调用。</p>
<h3 id="4-5-co-yield"><a href="#4-5-co-yield" class="headerlink" title="4.5. co_yield"></a>4.5. co_yield</h3><p>当协程调用了 <code>co_return</code> ，意味着协程结束了，就跟我们在普通函数中用 <code>return</code> 结束函数一样。这时候，与这个协程实例有关的内存都会被释放掉，它不能再执行了。如果需要在协程中多次返回数据而不结束协程的话，可以使用 <code>co_yield</code> 操作符。</p>
<p><code>co_yield</code> 的作用是，返回一个数据，并且让协程暂停，然后等下一次机会恢复执行。 <code>co_yield value</code> 这个表达式等价于 <code>co_await promise_type.yield_value(value)</code> ， <code>co_yield</code> 的参数会传递给 <code>promise_type</code> 的 <code>yield_value()</code> 函数，再把这个函数的返回值传给 <code>co_await</code> 。上文提到，传给 <code>co_await</code> 的参数要符合 Awaitable 规范，所以 <code>yield_value()</code> 的返回类型也要满足这个规范。在这里就可以使用预定义的 <code>std::supsend_never</code> 或 <code>std::suspend_always</code> ，通常会使用后者来让协程每次调用 <code>co_yield</code> 的时候都暂停。</p>
<p>下面我们修改一下示例，当用户输入一次之后，从协程取出一个值输出，然后让它生成下一个值；用户继续输入，又取出一个值输出，再生成下一个值，如此反复循环。完整的示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([<span class="keyword">this</span>, handle]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">static</span> <span class="type">int</span> seed = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            value_ = ++seed;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            handle.resume();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> Task&#123; std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            value_ = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">coroutine_handle_</span>(handle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coroutine_handle_.<span class="built_in">promise</span>().<span class="built_in">GetValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        coroutine_handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; coroutine_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        IntReader reader;</span><br><span class="line">        <span class="type">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; line) &#123;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; task.<span class="built_in">GetValue</span>() &lt;&lt; std::endl;</span><br><span class="line">        task.<span class="built_in">Next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例修改的点比较多，我们拆解来看。首先，为了方便看出来程序的确是按照我们的预期来运行的，这里把 <code>IntReader::await_suspend()</code> 子线程内生成随机整数改成生成递增的整数。</p>
<p>然后，为了让使用者可以恢复协程执行， <code>Task</code> 增加了一个 <code>Next()</code> 函数，这个函数调用了作为成员变量的协程句柄来恢复执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    coroutine_handle_.<span class="built_in">resume</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着 <code>Task</code> 需要拿到协程的句柄，这是在 <code>promise_type</code> 的 <code>get_return_object()</code> 中通过以下方式传递过去的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> Task&#123; std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::coroutine_handle</code> 的 <code>from_promise()</code> 函数可以通过 <code>promise_type</code> 对象获取与之关联的协程句柄，反之，协程句柄上也有一个 <code>promise()</code> 函数可以获取对应的 <code>promise_type</code> 对象，他们是可以互相转换的。所以，在 <code>Task</code> 和 <code>promise_type</code> 之间就不需要使用 <code>std::shared_ptr&lt;int&gt;</code> 来共享数据了， <code>Task</code> 通过协程句柄就能访问到 <code>promise_type</code> 对象，像下面这样直接取数据就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> coroutine_handle_.<span class="built_in">promise</span>().<span class="built_in">GetValue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意一下协程句柄 <code>std::coroutine_handle</code> 的模板类型。在前面的例子中，协程句柄的类型是 <code>std::coroutine_handle&lt;&gt;</code> ，不带模板参数；而在这个例子中，协程句柄的类型是  <code>std::coroutine_handle&lt;promise_type&gt;</code> ，模板参数中填入了 <code>promise_type</code> 类型。它们的区别类似于指针 <code>void*</code> 和 <code>promise_type*</code> 的区别，前者是无类型的，后者是强类型的。两种类型的协程句柄本质上是相同的东西，它们可以有相同的值，指向同一个协程实例，而且也都可以恢复协程执行。但只有强类型的 <code>std::coroutine_handle&lt;promise_type&gt;</code> 才能调用 <code>from_promise()</code> 获取到 <code>promise_type</code> 对象。</p>
<p>接下来，协程 <code>GetInt()</code> 的实现修改成一个无限循环，在循环内通过 <code>IntReader</code> 获取到整数，再通过 <code>co_yield</code> 把整数返回出去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        IntReader reader;</span><br><span class="line">        <span class="type">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于协程来说，无限循环是常见的实现方式，由于它具有暂停的特性，并不会像普通函数那样让线程在里面死循环。</p>
<p>最后，在 <code>promise_type</code> 中定义了 <code>yield_value()</code> 函数来接收 <code>co_yield</code> 返回的数据。我们希望返回数据之后立即暂停协程，所以返回类型定义成了 <code>std::supsend_always</code> 。</p>
<h3 id="4-6-协程的生命周期"><a href="#4-6-协程的生命周期" class="headerlink" title="4.6. 协程的生命周期"></a>4.6. 协程的生命周期</h3><p>正如上文所说的，在一开始调用协程的时候，C++会在堆上为协程的状态分配内存，这块内存必须在适当的时机来释放，否则就会造成内存泄漏。释放协程的内存有两种方式：自动释放和手动释放。</p>
<p>当协程结束的时候，如果我们不做任何干预，那么协程的内存就会被自动释放。调用了 <code>co_return</code> 语句之后，协程就会结束，下面两个协程是自动释放的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader;</span><br><span class="line">    <span class="type">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PrintInt()</code> 没有出现 <code>co_return</code> 语句，编译器会在末尾隐式地加上 <code>co_return</code> 。</p>
<p>自动释放的方式有时候并不是我们想要的，参考下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Task&#123; std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            value_ = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">coroutine_handle_</span>(handle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coroutine_handle_.<span class="built_in">promise</span>().<span class="built_in">GetValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; coroutine_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; line) &#123;</span><br><span class="line">        std::cout &lt;&lt; task.<span class="built_in">GetValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中， <code>GetInt()</code> 协程通过 <code>co_return</code> 返回了1024给 <code>promise_type</code> ；协程返回值 <code>Task</code> 通过协程句柄访问 <code>promise_type</code> ，从中取出这个值。随着用户的输入，把这个值输出来。运行程序，我们会发现输出的值并不是1024，而是一个随机值；也有可能会出现地址访问错误的异常。</p>
<p>造成这个现象的原因是，协程在返回1024之后就被自动释放了， <code>promise_type</code> 也跟着被一起释放了，此时在 <code>Task</code> 内部持有的协程句柄已经变成了野指针，指向一块已经被释放的内存。所以访问这个协程句柄的任何行为都会造成不确定的后果。</p>
<p>解决这个问题的方法是，修改 <code>promise_type</code> 中 <code>final_supsend()</code> 函数的返回类型，从 <code>std::suspend_never</code> 改成 <code>std::suspend_always</code> 。协程在结束的时候，会调用 <code>final_suspend()</code> 来决定是否暂停，如果这个函数返回了要暂停，那么协程不会自动释放，此时协程句柄还是有效的，可以安全访问它内部的数据。</p>
<p>不过，这时候释放协程就变成我们的责任了，我们必须在适当的时机调用协程句柄上的 <code>destroy()</code> 函数来手动释放这个协程。在这个例子中，可以在 <code>Task</code> 的析构函数中做这个事情：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Task</span>() &#123;</span><br><span class="line">    coroutine_handle_.<span class="built_in">destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要协程处于暂停状态，就可以调用协程句柄的 <code>destroy()</code> 函数来释放它，不一定要求协程结束。对于通过无限循环来实现的协程，手动释放是必需的。</p>
<p>与 <code>final_suspend()</code> 相对应的是 <code>initial_suspend()</code> ，在协程刚开始执行的时候，会调用这个函数来决定是否暂停。我们可以将这个函数的返回类型改成 <code>std::suspend_always</code> 来让协程一执行即暂停。这对于一些需要延迟执行的场景是有用的，例如，我们想先获取一批协程句柄，像数据那样对它们进行管理，在稍后的时机再挑选合适的协程来执行。</p>
<h3 id="4-7-异常处理"><a href="#4-7-异常处理" class="headerlink" title="4.7. 异常处理"></a>4.7. 异常处理</h3><p>最后，我们看一下协程的异常处理。编译器生成的执行协程的伪代码大概如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_await</span> promise_type.<span class="built_in">initial_suspend</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//协程函数体的代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...) &#123;</span><br><span class="line"></span><br><span class="line">    promise_type.<span class="built_in">unhandled_exception</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">co_await</span> promise_type.<span class="built_in">final_suspend</span>();</span><br></pre></td></tr></table></figure>

<p>协程主要的执行代码都被 try - catch 包裹，假如抛出了未处理的异常， <code>promise_type</code> 的 <code>unhandled_exception()</code> 函数会被调用，我们可以在这个函数里面做对应的异常处理。由于这个函数是在 <code>catch</code> 语句中调用的，我们可以在函数内调用 <code>std::current_exception()</code> 函数获取异常对象，也可以调用 <code>throw</code> 重新抛出异常。</p>
<p>调用了 <code>unhandled_exception()</code> 之后，协程就结束了，接下来会继续调用 <code>final_suspend()</code> ，与正常结束协程的流程一样。C++规定 <code>final_suspend()</code> 必须定义成 <code>noexcept</code> ，也就是说它不允许抛出任何异常。</p>
<h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5. 后记"></a>5. 后记</h2><p>至此，关于C++协程的基础内容介绍完毕。从当前的使用方式来看，C++20的协程只提供了最基础的能力，为了用上它，我们需要写不少代码，将一个一个小块串联起来。所以，现在C++协程的形态是不友好的，晦涩难懂，难以学习。</p>
<p>要想在实际的开发中使用上C++协程，还有比较长的路。我们可以自己动手对它进行封装，或者寻求第三方库的解决方案，或者继续期待未来的C++标准带来更高层封装的协程组件。</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/C/">C++</a>
  </div>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  <div class="ds-thread" data-thread-key="2022/03/25/cpp-coroutine-beginner/" data-title="C++20协程入门教程" data-url="http://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/"></div>

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zplutor"};
	  (function() {
		 var ds = document.createElement('script');
		 ds.type = 'text/javascript';ds.async = true;
		 ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		 ds.charset = 'UTF-8';
		 (document.getElementsByTagName('head')[0] 
		  || document.getElementsByTagName('body')[0]).appendChild(ds);
	  })();
  </script>
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/C/">C++</a><small>20</small></li>
  
    <li><a href="/tags/COM/">COM</a><small>5</small></li>
  
    <li><a href="/tags/IUnknown/">IUnknown</a><small>1</small></li>
  
    <li><a href="/tags/KeyWindow/">KeyWindow</a><small>1</small></li>
  
    <li><a href="/tags/OpenSSL/">OpenSSL</a><small>1</small></li>
  
    <li><a href="/tags/RAND-bytes/">RAND_bytes</a><small>1</small></li>
  
    <li><a href="/tags/RAND-poll/">RAND_poll</a><small>1</small></li>
  
    <li><a href="/tags/RichEdit/">RichEdit</a><small>3</small></li>
  
    <li><a href="/tags/SQL/">SQL</a><small>1</small></li>
  
    <li><a href="/tags/STL/">STL</a><small>5</small></li>
  
    <li><a href="/tags/Visual-Studio/">Visual Studio</a><small>2</small></li>
  
    <li><a href="/tags/WM-TIMER/">WM_TIMER</a><small>1</small></li>
  
    <li><a href="/tags/WinDbg/">WinDbg</a><small>1</small></li>
  
    <li><a href="/tags/Windows/">Windows</a><small>26</small></li>
  
    <li><a href="/tags/Windows-Performance-Toolkit/">Windows Performance Toolkit</a><small>1</small></li>
  
    <li><a href="/tags/XCode/">XCode</a><small>1</small></li>
  
    <li><a href="/tags/boost/">boost</a><small>5</small></li>
  
    <li><a href="/tags/libcurl/">libcurl</a><small>2</small></li>
  
    <li><a href="/tags/macOS/">macOS</a><small>2</small></li>
  
    <li><a href="/tags/procdump/">procdump</a><small>1</small></li>
  
    <li><a href="/tags/内存泄露/">内存泄露</a><small>1</small></li>
  
    <li><a href="/tags/内核对象/">内核对象</a><small>1</small></li>
  
    <li><a href="/tags/单例/">单例</a><small>1</small></li>
  
    <li><a href="/tags/字符串/">字符串</a><small>4</small></li>
  
    <li><a href="/tags/字符编码/">字符编码</a><small>2</small></li>
  
    <li><a href="/tags/定时器/">定时器</a><small>2</small></li>
  
    <li><a href="/tags/异常/">异常</a><small>3</small></li>
  
    <li><a href="/tags/引用计数/">引用计数</a><small>1</small></li>
  
    <li><a href="/tags/性能/">性能</a><small>3</small></li>
  
    <li><a href="/tags/日志/">日志</a><small>1</small></li>
  
    <li><a href="/tags/智能指针/">智能指针</a><small>1</small></li>
  
    <li><a href="/tags/死锁/">死锁</a><small>1</small></li>
  
    <li><a href="/tags/流式输出/">流式输出</a><small>1</small></li>
  
    <li><a href="/tags/消息队列/">消息队列</a><small>1</small></li>
  
    <li><a href="/tags/线程/">线程</a><small>2</small></li>
  
    <li><a href="/tags/继承/">继承</a><small>1</small></li>
  
    <li><a href="/tags/编译/">编译</a><small>1</small></li>
  
    <li><a href="/tags/调试/">调试</a><small>6</small></li>
  
    <li><a href="/tags/超时/">超时</a><small>2</small></li>
  
    <li><a href="/tags/预编译头/">预编译头</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2023 Zplutor
  
</div>
<div class="clearfix"></div></footer>
  
</body>
</html>
