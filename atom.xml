<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zplutor&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zplutor.github.io/"/>
  <updated>2020-12-24T17:07:43.925Z</updated>
  <id>http://zplutor.github.io/</id>
  
  <author>
    <name>Zplutor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分析一个驱动程序导致程序无响应的案例</title>
    <link href="http://zplutor.github.io/2020/12/25/analyze-an-application-hang-caused-by-driver/"/>
    <id>http://zplutor.github.io/2020/12/25/analyze-an-application-hang-caused-by-driver/</id>
    <published>2020-12-24T16:46:27.000Z</published>
    <updated>2020-12-24T17:07:43.925Z</updated>
    
    <content type="html"><![CDATA[<p>最近有客户投诉我们的程序经常无响应，几乎无法使用。我查看了问题现场，发现有以下表现：</p><ol><li>无响应时程序的CPU使用率基本保持为0%。</li><li>如果一直放着不干预，一分钟左右程序是能恢复正常的。</li><li>从转储文件看，程序是在调用<code>ReadFile</code>读取文件内容时出现无响应的，部分的堆栈如下所示：</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ntdll!KiFastSystemCallRet</span><br><span class="line">ntdll!NtReadFile+0xc</span><br><span class="line">KERNELBASE!ReadFile+0xaa</span><br><span class="line">kernel32!ReadFileImplementation+0xf0</span><br><span class="line">MyApp!winRead+0xc6</span><br><span class="line">MyApp!sqlite3OsRead+0x2c</span><br><span class="line">MyApp!sqlite3WalReadFrame+0x45</span><br><span class="line">MyApp!readDbPage+0x94</span><br><span class="line">MyApp!getPageNormal+0x1a4</span><br><span class="line">MyApp!sqlite3PagerGet+0x13</span><br><span class="line">MyApp!getAndInitPage+0x72</span><br><span class="line">MyApp!moveToChild+0x7f</span><br><span class="line">MyApp!sqlite3BtreeMovetoUnpacked+0x3c5</span><br><span class="line">MyApp!sqlite3VdbeExec+0x2b31</span><br><span class="line">MyApp!sqlite3Step+0xee</span><br><span class="line">MyApp!sqlite3_step+0x98</span><br></pre></td></tr></table></figure><p>根据这些现象，我猜测可能是某个实现不好的驱动程序拦截了<code>ReadFile</code>这个API导致的。为了进一步排查，需要更详尽的信息，于是我在客户的电脑上使用Windows Performance Recorder录制性能数据，从无响应开始，一直录制到恢复正常，然后使用Windows Performance Analyzer对这个性能数据进行分析。下面是分析过程。</p><p>在这里主要用到的是Windows Performance Analyzer的“CPU Usage (Precise)”图表，这个图表的数据与线程的状态切换息息相关。简单来说，在线程的生命周期中，会在以下几种状态之间切换：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/1.png"><ul><li>等待，线程要执行的条件未被满足，正在等待这些条件。例如，线程在等待一个互斥锁被释放。</li><li>就绪，线程要执行的所有条件均已满足，随时可以调度给CPU执行。例如，一个线程释放了互斥锁，另外一个正在等待锁的线程会进入就绪状态。</li><li>执行，线程正在被CPU执行。</li></ul><p>Windows Performance Recorder记录了系统中所有线程每一次状态切换的信息，包括就绪之前等待的时长、哪个线程让另一个线程就绪、导致线程进入等待状态的堆栈等等，这些信息均通过CPU Usage (Precise)图表来呈现。</p><p>回到本文要分析的问题，“程序在一分钟左右能恢复正常”是一个很关键的信息，它表明了导致程序无响应的一个可能原因：主线程在等待某个条件，经过一分钟左右该条件得到满足，主线程得以继续执行，于是程序恢复正常。为了证实这个猜想，需要从CPU Usage (Precise)图表中找到证据。</p><p>在打开了CPU Usage (Precise)图表之后，先对这个表格的列做一些调整，如下所示：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/2.png"><p>这里把表格黄色分割线左侧的列，依次设置成了“New Process” - “New Thread Id” - “New Thread Stack”，这几个带有“New”前缀的列表示切换到执行状态的线程的相关信息，例如New Process表示线程所在进程的名字，New Thread Id即该线程的ID，New Thread Stack表示切换到执行状态之后，线程开始执行时代码位置的堆栈，这通常也是线程进入等待状态时的堆栈。经过这样设置之后，表格的数据会依次按照进程-线程-堆栈来聚合，方便筛选和查看。</p><p>然后是表格蓝色分割线右侧的列设置成了“Waits”的最大值，顾名思义，Waits这个数据的含义是线程在切换到就绪状态之前等待的时长。注意这不是切换到执行状态之前的等待时长。从就绪状态切换到执行状态之间也有一段时间，这段时间不会计算在内，而且通常这段时间都很短，相比在等待状态的时长，可以忽略不计。</p><p>接下来，将表格按照Waits列倒序排列，并且根据进程名字和主线程ID进行筛选，即可找到等待时长最大的线程状态切换数据，从这个数据的堆栈，能看出来一些端倪，如下所示：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/3.png"><p>从图中可以看到，主线程在这一次切换到执行状态之前等待了大约77秒，符合程序无响应的感官时长，而且图中展示的堆栈与转储文件中的堆栈是一致的，所以基本可以确定这里就是问题产生的根源。相比用户态的转储文件，Windows Performance Analyzer的一个优势是可以看到内核态的堆栈，可以看到调用<code>ReadFile</code>之后发生的事情。这里有一个可疑的驱动程序<code>cwNep.sys</code>，它没有符号信息，并且网上搜索的结果表明，它显然是一个第三方的驱动程序。这个驱动程序调用了<code>FltSendMessage</code>，该函数使主线程进入了等待状态。</p><p>查阅<code>FltSendMessage</code>的文档，可以知道这个API是内核态的驱动程序向用户态的应用程序发消息时使用的，并且它是一个阻塞式的同步调用，如果应用程序没有调用<code>FilterGetMessage</code>来接收消息，驱动程序就会一直等待，直到消息被接收或者超时。</p><p>至此，问题的原因已经很清楚了，<code>cwNep.sys</code>驱动程序拦截了<code>ReadFile</code>调用，并且向用户态的应用程序发消息，而该应用程序没有及时接收这个消息，导致调用线程进入长时间的等待状态。</p><p>既然已经找到了肇事的驱动程序，那么可以继续找一下是哪个应用程序没有及时接收消息。基于程序可以从无响应中恢复的现象，可以确定要找的应用程序最终是成功调用了<code>FilterGetMessage</code>。从文档可知，<code>FilterGetMessage</code>既可以同步调用也可以异步调用，暂且假设它是被同步调用的，那么调用这个函数的线程，在接收到驱动程序的消息之后，必然会从等待状态切换到就绪状态，继而切换到执行状态，并且它开始执行的堆栈也是在<code>FilterGetMessage</code>内部。所以，可以在New Thread Stack这一列中查找<code>FilterGetMessage</code>关键字，如下所示：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/4.png"><p>在这个案例中，运气不错，很快找到了唯一一个调用了<code>FilterGetMessage</code>的线程，如下所示：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/5.png"><p>由此确定这个没有及时接收消息的应用程序是<code>wepsvc.exe</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有客户投诉我们的程序经常无响应，几乎无法使用。我查看了问题现场，发现有以下表现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无响应时程序的CPU使用率基本保持为0%。&lt;/li&gt;
&lt;li&gt;如果一直放着不干预，一分钟左右程序是能恢复正常的。&lt;/li&gt;
&lt;li&gt;从转储文件看，程序是在调用&lt;code&gt;ReadFile&lt;/code&gt;读取文件内容时出现无响应的，部分的堆栈如下所示：&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="性能" scheme="http://zplutor.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="Windows Performance Toolkit" scheme="http://zplutor.github.io/tags/Windows-Performance-Toolkit/"/>
    
  </entry>
  
  <entry>
    <title>如何判断一个类型是否可比较</title>
    <link href="http://zplutor.github.io/2020/11/21/how-to-check-if-a-type-is-comparable/"/>
    <id>http://zplutor.github.io/2020/11/21/how-to-check-if-a-type-is-comparable/</id>
    <published>2020-11-21T14:21:23.000Z</published>
    <updated>2020-11-21T14:31:58.848Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个用户定义类型，如果定义了<code>operator==</code>或者<code>operator&lt;</code>等比较函数，那么这个类型就是可比较的。在实现一些工具库的时候，可能需要知道某个类型是否可比较，例如，想要知道是否可以使用<code>==</code>操作符来比较两个类对象是否相等，那么可以使用下面的模板类来判断：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsEqualityComparable</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line">    static constexpr auto Test(K*) -&gt; decltype(std::declval&lt;K&gt;() == std::declval&lt;K&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">Test</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> Value = <span class="built_in">std</span>::is_same_v&lt;<span class="keyword">bool</span>, <span class="keyword">decltype</span>(Test&lt;T&gt;(<span class="literal">nullptr</span>))&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内置类型和标准库类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; IsEqualityComparable&lt;<span class="keyword">int</span>&gt;::Value;    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; IsEqualityComparable&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::Value; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有比较操作符的自定义类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComaprableObject</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> ComaprableObject&amp; o1, <span class="keyword">const</span> ComaprableObject&amp; o2) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; IsEqualityComparable&lt;ComaprableObject&gt;::Value <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没有比较操作符的自定义类型</span></span><br><span class="line">class UncomparableObject &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; IsEqualityComparable&lt;ComaprableObject&gt;::Value <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>这个模板类型基于C++的SFINAE特性，关于这个特性的解释，可以参考之前的文章<a href="http://zplutor.github.io/2019/04/10/how-to-check-whether-a-container-is-an-associative-container/">《如何判断一个容器是否关联容器》</a>，在这篇文章里，也基于SFINAE特性实现了一个判断某类型是否关联容器的模板类。</p><p><code>IsEqualityComparable</code>使用了<code>std::is_same_v</code>来推导结果，它检查<code>Test&lt;T&gt;(nullptr)</code>这个函数调用表达式的返回值类型是否<code>bool</code>，如果是，则<code>T</code>可以用<code>==</code>进行比较，如果不是则不可以比较。</p><p>为了让<code>Test&lt;T&gt;(nullptr)</code>这个表达式对不同类型有不同的返回值，这里定义了两个重载的<code>Test</code>模板方法，其中第一个的声明如下所示：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line">static constexpr auto Test(K*) -&gt; decltype(std::declval&lt;K&gt;() == std::declval&lt;K&gt;());</span><br></pre></td></tr></table></figure></p><p>这个方法的返回值类型通过<code>decltype</code>来推导，而推导的来源正是模板类型<code>K</code>的<code>==</code>表达式，如果<code>K</code>可以比较，那么这个方法是有效的，返回值类型是<code>bool</code>；如果<code>K</code>不可以比较，那么根据SFINAE，这个方法会被删除，就像从未存在过一样。注意<code>std::declval</code>的使用，这个函数可以在不调用构造函数的前提下生成一个<code>K</code>的引用，以便使用者直接访问<code>K</code>的接口。这意味着使用者不需要知道如何构造<code>K</code>的对象，因为<code>==</code>只能作用于对象上，在比较之前必须先有对象，为了创建对象，使用者要调用<code>K</code>的构造方法。由于每个类型的构造方法都不一样，这里就没办法做到广泛适用。而<code>std::declval</code>绕过了构造方法，避免了这个问题。</p><p>第二个重载的<code>Test</code>模板方法如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">Test</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个方法是“没有选择时的最后选择“。如果第一个模板方法被删除了，那么<code>Test&lt;T&gt;(nullptr)</code>这个表达式就会匹配到这个模板方法，表达式的返回值类型是<code>int</code>；如果第一个模板方法有效，那么表达式会优先匹配第一个方法，因为参数为<code>...</code>的重载方法优先级是最低的，此时表达式的返回值类型是<code>bool</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个用户定义类型，如果定义了&lt;code&gt;operator==&lt;/code&gt;或者&lt;code&gt;operator&amp;lt;&lt;/code&gt;等比较函数，那么这个类型就是可比较的。在实现一些工具库的时候，可能需要知道某个类型是否可比较，例如，想要知道是否可以使用&lt;code&gt;==&lt;/code&gt;操作符来比较两个类对象是否相等，那么可以使用下面的模板类来判断：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio并行编译失效的原因</title>
    <link href="http://zplutor.github.io/2019/12/29/why-multi-processor-compile-option-not-work/"/>
    <id>http://zplutor.github.io/2019/12/29/why-multi-processor-compile-option-not-work/</id>
    <published>2019-12-29T12:48:44.000Z</published>
    <updated>2019-12-29T12:52:13.154Z</updated>
    
    <content type="html"><![CDATA[<p>对于大型C++项目来说，并行编译开关<code>/MP</code>是必不可少的编译器选项，它能显著提高项目的编译速度。但是，当我在自己所在的项目中开启了这个选项之后，发现没有什么效果，只有少数文件可以并行编译，大多数文件仍然是串行编译的，编译时CPU使用率只有30%~40%。这个问题困扰了我们项目组很久。</p><a id="more"></a><p>最近，我在Visual Studio的社区里发现了一个反馈，内容是说当显式指定了.obj文件的输出文件名时，<code>/MP</code>选项会失效。而Visual Studio的官方团队也解释说这确实是编译器的缺陷，因为编译器是以传递给编译器的参数来决定编译单元是否能并行编译的，只有编译参数一模一样的编译单元才能够并行。</p><p>于是我立即查看我们工程的设置，发现.obj文件的输出文件名确实被修改了，如下图所示：</p><img src="/2019/12/29/why-multi-processor-compile-option-not-work/1.png"><p>这个值的意思是，按照源文件的相对路径来输出.obj文件。默认情况下，工程里所有源文件编译后的.obj文件都会输出到同一个目录中，一旦在不同目录下存在名字相同的源文件，它们输出的.obj文件就会相互覆盖，在大型工程里这个问题很容易遇到。所以，为了避免这个问题，我们在这个设置项加上了<code>%(RelativeDir)</code>。</p><p>这样一来，虽然解决了名字冲突的问题，却带来了并行编译失效的问题。由于<code>%(RelativeDir)</code>的值是随着源文件所在目录而改变的，所以不同目录下的源文件其编译参数都不一样，它们就无法并行编译了。只有同一个目录下的源文件才能并行编译。</p><p>去掉了这个设置之后，<code>/MP</code>选项终于恢复了该有的效率，在编译时CPU使用率一直在90%以上，整个工程的编译时间缩短了一半。当然，代价是必须逐个处理名字冲突的源文件，要么改名字，要么改.obj文件的输出路径。</p><p>在上述的反馈中，Visual Studio团队已经在着手修复这个问题，希望在不久的将来能恢复使用<code>%(RelativeDir)</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于大型C++项目来说，并行编译开关&lt;code&gt;/MP&lt;/code&gt;是必不可少的编译器选项，它能显著提高项目的编译速度。但是，当我在自己所在的项目中开启了这个选项之后，发现没有什么效果，只有少数文件可以并行编译，大多数文件仍然是串行编译的，编译时CPU使用率只有30%~40%。这个问题困扰了我们项目组很久。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="Visual Studio" scheme="http://zplutor.github.io/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>为什么隐藏Owned窗口时，Owner窗口会被后置</title>
    <link href="http://zplutor.github.io/2019/07/06/why-the-owner-window-would-be-put-at-back-when-its-owned-window-hides/"/>
    <id>http://zplutor.github.io/2019/07/06/why-the-owner-window-would-be-put-at-back-when-its-owned-window-hides/</id>
    <published>2019-07-06T08:44:21.000Z</published>
    <updated>2020-11-21T14:20:22.313Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发的时候遇到一个怪异的问题，问题背景：在程序中，有一个Owner窗口拥有多个Owned窗口，当关闭Owned窗口时，会调用<code>ShowWindow</code>来隐藏该窗口，而不是真正的关闭。当最后一个Owned窗口隐藏时，理论上应该要激活Owner窗口，然而实际上激活的是位于Owner窗口下面的另外一个窗口。</p><a id="more"></a><p>经过一番检查，最终发现问题的根源在于Owned窗口的样式：如果Owned窗口具有<code>WS_OVERLAPPED</code>样式，就会出现该问题；而把样式改成<code>WS_POPUP</code>之后，问题就会消失。</p><p>可以用以下的代码来试验：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(HINSTANCE instance, HINSTANCE, LPWSTR, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册Owner窗口类</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Owner窗口</span></span><br><span class="line">    HWND owner_window = CreateWindow(</span><br><span class="line">        <span class="string">L"OwnerWindowClass"</span>, </span><br><span class="line">        <span class="string">L"Owner"</span>, </span><br><span class="line">        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_VISIBLE,</span><br><span class="line">        CW_USEDEFAULT, </span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        instance,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册Owned窗口类，使用OwnedWindowProcedure作为窗口过程函数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第一个Owned窗口</span></span><br><span class="line">    HWND owned_window1 = CreateWindow(</span><br><span class="line">        <span class="string">L"OwnedWindowClass"</span>, </span><br><span class="line">        <span class="string">L"Owned"</span>,</span><br><span class="line">        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_VISIBLE,</span><br><span class="line">        <span class="number">0</span>, </span><br><span class="line">        <span class="number">0</span>, </span><br><span class="line">        <span class="number">500</span>,</span><br><span class="line">        <span class="number">500</span>,</span><br><span class="line">        owner_window,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        instance,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第二个Owned窗口</span></span><br><span class="line">    HWND owned_window2 = CreateWindow(</span><br><span class="line">        <span class="string">L"OwnedWindowClass"</span>,</span><br><span class="line">        <span class="string">L"Owned"</span>,</span><br><span class="line">        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_VISIBLE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">500</span>,</span><br><span class="line">        <span class="number">500</span>,</span><br><span class="line">        owner_window,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        instance,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG message&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;message, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;message);</span><br><span class="line">        DispatchMessage(&amp;message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">OwnedWindowProcedure</span><span class="params">(HWND window_handle, UINT message, WPARAM wparam, LPARAM lparam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截关闭行为，改成隐藏</span></span><br><span class="line">    <span class="keyword">if</span> (message == WM_CLOSE) &#123;</span><br><span class="line">        ShowWindow(window_handle, SW_HIDE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(window_handle, message, wparam, lparam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行以上代码，会显示一个Owner窗口和两个Owned窗口。逐个关闭Owned窗口，在关闭最后一个窗口时，如果桌面上存在其它窗口，那么必然会激活其它窗口，而不是Owner窗口。把Owned窗口的样式改成<code>WS_POPUP</code>之后，就不会再出现这个现象了。</p><p>从这个问题可以看出，Overlapped窗口和Popup窗口并不仅仅是默认有无边框的区别，在一些细节行为上，这两种窗口会有不同的表现。一般来说，<code>WS_OVERLAPPED</code>样式用于顶层的Owner窗口，而Owned窗口应尽量使用<code>WS_POPUP</code>样式，这样可以避免出现一些意料之外的表现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在开发的时候遇到一个怪异的问题，问题背景：在程序中，有一个Owner窗口拥有多个Owned窗口，当关闭Owned窗口时，会调用&lt;code&gt;ShowWindow&lt;/code&gt;来隐藏该窗口，而不是真正的关闭。当最后一个Owned窗口隐藏时，理论上应该要激活Owner窗口，然而实际上激活的是位于Owner窗口下面的另外一个窗口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>如何判断一个容器是否关联容器</title>
    <link href="http://zplutor.github.io/2019/04/10/how-to-check-whether-a-container-is-an-associative-container/"/>
    <id>http://zplutor.github.io/2019/04/10/how-to-check-whether-a-container-is-an-associative-container/</id>
    <published>2019-04-09T16:56:50.000Z</published>
    <updated>2019-04-09T17:00:59.117Z</updated>
    
    <content type="html"><![CDATA[<p>如果你正在编写一个C++工具库，那么有可能需要知道一个容器是否关联容器。例如，你要写一个<code>Contain()</code>工具函数，该函数用来判断元素是否在容器中。而且你希望对于不同的容器，总是使用性能最优的查找方式，也就是说，对于关联容器，使用<code>find()</code>成员函数；而对于非关联容器，则使用<code>std::find()</code>函数。</p><a id="more"></a><p>此时，你也许需要使用模板元编程。在STL中，所有关联容器都有一个特征：定义了<code>key_type</code>成员类型，根据这个特征即可判断某个类型是否关联容器。</p><p>进行这个判断的模板元类型如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsAssociativeContainer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">Test</span><span class="params">(<span class="keyword">typename</span> T::key_type*)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">Test</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> Value = Test&lt;C&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; IsAssociativeContainer&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::Value;    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; IsAssociativeContainer&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;::Value;      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; IsAssociativeContainer&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt;::Value;       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; IsAssociativeContainer&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::Value;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p><code>IsAssociativeContainer</code>的实现使用了C++模板的SFINAE技术，全称为“Substitution Failure Is Not An Error”，它的意思是：当编译器试图在多个重载的模板函数中查找最佳匹配时，如果某个函数的模板参数推导失败，那么这个函数会被丢弃，而不会出现编译错误。</p><p>首先，在<code>IsAssociativeContainer</code>内部，定义了两个重载的<code>Test()</code>模板函数，第一个重载带有<code>T::key_type*</code>参数，对应关联容器类型，该函数返回<code>true</code>；第二个重载接受可变参数，对应非关联容器类型，该函数返回<code>false</code>。</p><p>然后，在定义静态常量<code>Value</code>时，使用<code>Test&lt;C&gt;(nullptr)</code>对其赋值。这里正是C++魔法起作用的时刻：编译器要在两个<code>Test()</code>重载函数中找到最佳匹配，使用它的返回值作为<code>Value</code>的值。假如模板类型<code>C</code>不是关联容器，它没有<code>key_type</code>成员类型，那么编译器在推导第一个重载的时候会失败，这个重载函数随即被丢弃，就像它从来没有出现过那样，所以编译器只能选择第二个重载。假如<code>C</code>是关联容器，它具有<code>key_type</code>成员类型，那么两个重载函数都能推导成功，此时编译器会优先选择第一个重载，因为接受可变参数的重载函数优先级是最低的。这种只接受可变参数的模板函数经常与SFINAE一起使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你正在编写一个C++工具库，那么有可能需要知道一个容器是否关联容器。例如，你要写一个&lt;code&gt;Contain()&lt;/code&gt;工具函数，该函数用来判断元素是否在容器中。而且你希望对于不同的容器，总是使用性能最优的查找方式，也就是说，对于关联容器，使用&lt;code&gt;find()&lt;/code&gt;成员函数；而对于非关联容器，则使用&lt;code&gt;std::find()&lt;/code&gt;函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何避免预创建的CEF浏览器抢夺焦点</title>
    <link href="http://zplutor.github.io/2018/12/16/how-to-stop-precreated-cef-browser-stealing-focus/"/>
    <id>http://zplutor.github.io/2018/12/16/how-to-stop-precreated-cef-browser-stealing-focus/</id>
    <published>2018-12-16T12:34:57.000Z</published>
    <updated>2018-12-16T12:36:07.292Z</updated>
    
    <content type="html"><![CDATA[<p>现在越来越多程序使用CEF浏览器来展示界面内容，以Web页面模拟原生界面。这种程序的Web页面内容大部分都来源于本地，因此加载速度一般都会很快。但是，与加载内容形成明显对比的是，创建CEF浏览器很耗时，大约需要1~2秒，这对用户体验造成很大影响。</p><a id="more"></a><p>解决这个问题的方法一般是采用预创建技术，即在展示Web页面之前，在后台预先创建好CEF浏览器，等到需要展示Web页面时，直接拿出这个浏览器使用，省去了创建的时间。</p><p>不过，在实践中发现，使用了预创建之后，会带来另一个问题：在创建浏览器的那一刻，窗口焦点会被它抢夺走，前台的窗口会莫名其妙地突然失去焦点，用户体验也很糟糕。</p><p>在CEF提供的接口中，有一个<code>CefFocusHandler</code>接口，其中有一个<code>OnSetFocus</code>方法，在浏览器窗口即将获取焦点之前会调用该方法，如果这个方法返回true，则可以阻止浏览器窗口获取焦点。这是在CEF中唯一跟焦点有关的接口，因此首先会想到利用这个方法来解决抢夺焦点问题。然而实践证明这个方法没有任何作用，因为它只处理“浏览器窗口”自身的焦点，而不处理父窗口的焦点。</p><p>CEF浏览器一般是作为其它窗口的子窗口，因此在预创建浏览器时，也必须指定父窗口。通常会使用一个不可见的窗口来充当浏览器的父窗口。如果使用Spy++工具来观察窗口的消息流，会发现在<code>OnSetFocus</code>返回true的情况下，浏览器窗口的确不会再收到<code>WM_SETFOCUS</code>消息；但父窗口不受影响，总是会收到<code>WM_SETFOCUS</code>消息，从而抢夺了焦点。</p><p>目前尚不清楚为什么父窗口会收到<code>WM_SETFOCUS</code>消息，可能是CEF有意将焦点设置到父窗口，也可能是CEF调用的某个API的副作用。既然不能通过CEF提供的接口解决，那只能使用其它变通方法。</p><p>由于一个被禁用的窗口永远不能取得焦点，所以一个行之有效的方法是：把父窗口设置成禁用，即在创建父窗口的时候设置<code>WS_DISABLED</code>样式。经过验证，这样做可以正常创建CEF浏览器，并且不会引起其它副作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在越来越多程序使用CEF浏览器来展示界面内容，以Web页面模拟原生界面。这种程序的Web页面内容大部分都来源于本地，因此加载速度一般都会很快。但是，与加载内容形成明显对比的是，创建CEF浏览器很耗时，大约需要1~2秒，这对用户体验造成很大影响。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>文件的共享模式和访问权限</title>
    <link href="http://zplutor.github.io/2018/08/26/file-share-mode-and-access-rights/"/>
    <id>http://zplutor.github.io/2018/08/26/file-share-mode-and-access-rights/</id>
    <published>2018-08-26T14:04:12.000Z</published>
    <updated>2018-08-26T14:14:45.082Z</updated>
    
    <content type="html"><![CDATA[<p>有用户反馈了这样一个问题：当Word或者Excel打开了一个文件时，无法用我们的程序打开该文件，而用其它程序却能够正常打开。经检查，这是由于在打开文件时<code>CreateFile</code>函数失败了，错误码是32，“另一个程序正在使用此文件，进程无法访问”。 </p><a id="more"></a><p>我检查了一遍代码，“看上去”似乎一切正常。但是为什么其它程序可以正常打开，就只有我们的程序不行呢？为了对比两者在打开文件上的差异，我使用ProcessMonitor来观察分别用Notepad++和我们程序打开同一个文件的过程。</p><p>经过对比，可以发现两者在执行CreateFile操作时，共享模式（ShareMode）的值明显不一样，如下所示：</p><img src="/2018/08/26/file-share-mode-and-access-rights/1.png"><p>左图是Notepad++的CreateFile操作，ShareMode包含了Read和Write，操作结果为SUCCESS；右图是我们程序的CreateFile操作，ShareMode只有Read，操作结果为SHARING_VIOLATION。显然，问题出在调用<code>CreateFile</code>函数时传入的<code>dwShareMode</code>参数上，我们对该参数只传入了<code>FILE_SHARE_READ</code>。尝试加上<code>FILE_SHARE_WRITE</code>之后，问题解决了。</p><p>我又仔细阅读了一遍文档，发现一直以来我对共享模式的理解都不够全面（通过与其他人的交流，可以肯定不止我一个人是这样）。</p><p>共享模式实际上是用来与文件的访问权限进行校验的。假设进程A要打开一个文件，而该文件已经被进程B打开了，那么系统会进行以下校验：</p><ul><li>进程A传入的共享模式与进程B对该文件的访问权限（即打开文件时传入的<code>dwDesiredAccess</code>参数）是否一致；</li><li>进程A传入的访问权限与进程B的共享模式是否一致。</li></ul><p>共享模式与访问权限的一致性判断方式：</p><ul><li>如果共享模式包含读取，那么访问权限也必须包含读取；</li><li>如果共享模式包含写入，那么访问权限也必须包含写入。</li></ul><p>也就是说，系统会对双方的共享模式和访问权限进行交叉校验，只有两个校验都通过了，进程A才能打开文件，否则就会出现共享冲突错误。</p><p>所以，现在已不难理解为什么之前我们的程序打不开被Word和Excel打开的文件。Word和Excel必然对文件有写入权限，而我们的程序在打开文件时，共享模式只设置了读取，这意味着“我希望其它人只能读取该文件”，显然这是不可能的。</p><p>注意，为了便于理解，上面用了进程做例子，但实际上共享模式和访问权限都属于文件句柄的一部分，权限校验是针对句柄的。在一个进程中多次打开同一个文件，也会在文件句柄之间进行这些校验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有用户反馈了这样一个问题：当Word或者Excel打开了一个文件时，无法用我们的程序打开该文件，而用其它程序却能够正常打开。经检查，这是由于在打开文件时&lt;code&gt;CreateFile&lt;/code&gt;函数失败了，错误码是32，“另一个程序正在使用此文件，进程无法访问”。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>修复微信快捷键截屏后无法使用输入法</title>
    <link href="http://zplutor.github.io/2018/06/14/fix-fail-to-use-ime-after-using-screen-capture-shortcut-of-wechat/"/>
    <id>http://zplutor.github.io/2018/06/14/fix-fail-to-use-ime-after-using-screen-capture-shortcut-of-wechat/</id>
    <published>2018-06-14T05:34:05.000Z</published>
    <updated>2018-10-20T02:21:22.868Z</updated>
    
    <content type="html"><![CDATA[<p>你有没有遇到过不能使用输入法的问题？输入法明明切换出来了，也处于中文模式下，但无论如何也只能输入英文，非常令人恼火。此时不妨回想一下，在出现问题之前是否曾经使用微信的快捷键来截屏？</p><a id="more"></a><p>在某些系统下，使用微信的默认快捷键（ALT + A，或者ALT键与其它字符键的组合）截屏后有较大的概率会出现上述问题。微信似乎也意识到这个问题，在最新版本中作了修正。然而这个修正貌似治标不治本，只是降低了问题出现的概率，甚至没有作用——有些人仍然在截屏后几乎总是无法输入中文。</p><p>作为用户，除了重启程序之外，还有更简单的方法来解决这个问题：按一下ALT键即可。造成这个问题的原因是当我们按下ALT键时，是当前程序接收到按下事件；而在激活了微信截屏后，我们松开ALT键时，却是微信接收到松开事件。因此对于当前程序来说，ALT键一直处于按下状态，没有松开，这时我们按下的任何键实际上都变成了与ALT键的组合，除了无法使用输入法之外，还会导致CTRL + C、CTRL + V等快捷键失效。只要再按一下ALT键，重置这个键的状态，即可让程序恢复正常。当然，有个无法解释的问题是，为什么出现问题的时候，输入字符时不会触发与ALT键的组合快捷键？也许这与操作系统的实现方式有关，目前无从得知。</p><p>作为开发者，这个问题是需要解决的。虽然这是微信的缺陷，但问题却表现在我们的程序上，不明就里的用户肯定会以为是我们程序的问题。鉴于微信庞大的用户量，这个问题的影响还是挺大的。好在解决方法也简单：既然用户自己按一下ALT键就能恢复，那么我们在程序中检测出这种情况，再模拟按一下ALT键就好了。</p><p>为了检测出这种情况，可以结合使用<code>GetKeyState</code>和<code>GetAsyncKeyState</code>函数。从MSDN文档描述可知，<code>GetKeyState</code>获取的按键状态是通过按键的消息事件来维护的，而<code>GetAsyncKeyState</code>获取的按键状态是键盘的实际状态。既然截屏时当前程序接收不到ALT键松开的事件，那么<code>GetKeyState</code>返回的状态自然也不对了。所以，如果发现<code>GetKeyState</code>返回了按下状态，而<code>GetAsyncKeyState</code>返回了非按下状态，那么就可以确定出现了问题。</p><p>在截屏完成后，窗口焦点会从微信切换到当前程序，当前程序的窗口会收到<code>WM_ACTIVATEAPP</code>消息，这是进行上述检测的一个理想的时机。</p><p>最后，使用<code>SendInput</code>函数即可模拟按键事件。要注意的是，必须在处理<code>WM_ACTIVATEAPP</code>消息的下一个消息循环来调用该函数。为了统一处理，可以把检测代码一起放到下一个消息循环。</p><p>以下是解决该问题的示例代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UINT WM_REVISE_ALT_KEY = WM_USER + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((message == WM_ACTIVATEAPP) &amp;&amp; (wparam == TRUE)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口被激活后，在下一个消息循环修正ALT键的状态</span></span><br><span class="line">        PostMessage(hwnd, WM_REVISE_ALT_KEY, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message == WM_REVISE_ALT_KEY) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ALT键处于按下状态        </span></span><br><span class="line">        SHORT key_state = GetKeyState(VK_MENU);</span><br><span class="line">        <span class="keyword">if</span> ((key_state &gt;&gt; <span class="number">15</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ALT键实际上没有按下</span></span><br><span class="line">            SHORT async_key_state = GetAsyncKeyState(VK_MENU);</span><br><span class="line">            <span class="keyword">if</span> ((async_key_state &gt;&gt; <span class="number">15</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//模拟按下ALT键</span></span><br><span class="line">                INPUT inputs[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span>&amp; key_down_input = inputs[<span class="number">0</span>];</span><br><span class="line">                key_down_input.type = INPUT_KEYBOARD;</span><br><span class="line">                key_down_input.ki.wVk = VK_MENU;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span>&amp; key_up_input = inputs[<span class="number">1</span>];</span><br><span class="line">                key_up_input.type = INPUT_KEYBOARD;</span><br><span class="line">                key_up_input.ki.wVk = VK_MENU;</span><br><span class="line">                key_up_input.ki.dwFlags = KEYEVENTF_KEYUP;</span><br><span class="line"></span><br><span class="line">                SendInput(<span class="number">2</span>, inputs, <span class="keyword">sizeof</span>(INPUT));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CallWindowProcedure(DefWindowProc, message, wparam, lparam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你有没有遇到过不能使用输入法的问题？输入法明明切换出来了，也处于中文模式下，但无论如何也只能输入英文，非常令人恼火。此时不妨回想一下，在出现问题之前是否曾经使用微信的快捷键来截屏？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>使用boost.filesystem检查文件是否存在的正确方式</title>
    <link href="http://zplutor.github.io/2018/04/09/proper-way-to-check-file-existence-using-boost-filesystem/"/>
    <id>http://zplutor.github.io/2018/04/09/proper-way-to-check-file-existence-using-boost-filesystem/</id>
    <published>2018-04-08T16:41:37.000Z</published>
    <updated>2018-04-08T16:46:09.552Z</updated>
    
    <content type="html"><![CDATA[<p>在我参与的项目中，使用了boost.filesystem进行文件操作。boost.filesystem在发生错误的时候会抛出异常，但是在大部分情况下这些异常是可以忽略的，例如，在检查文件是否存在的时候，发生错误可以等同于文件不存在。虽然boost.filesystem也提供了重载函数，通过输出参数返回错误来代替异常，但是在每个调用点都得定义一个输出参数，稍显麻烦。所以，为了简化客户代码，我们实现了一些包装函数，如下所示：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFileExistent</span><span class="params">(<span class="keyword">const</span> boost::filesystem::path&amp; path)</span> </span>&#123;</span><br><span class="line">    boost::system:error_code error;</span><br><span class="line">    <span class="keyword">return</span> boost::filesystem::is_regular_file(path, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数用来检查文件是否存在，使用了<code>boost::filesystem::is_regular_file</code>。当<code>path</code>指向一个“常规文件”的时候，认为该文件存在；否则其它任何情况都认为文件不存在。</p><p>这个函数一直都很正常，直到最近有用户反馈，当发送OneDrive同步文件夹中的文件时，会出现文件不存在的提示，而这个文件明明是存在的。经过排查，我发现当OneDrive开启了“按需文件”功能时，<code>boost::filesystem::is_regular_file</code>对于同步文件夹中的文件会返回false。这个功能的设置界面如下图所示：</p><img src="/2018/04/09/proper-way-to-check-file-existence-using-boost-filesystem/1.png"><p>当开启了“按需文件”功能时，OneDrive中的文件信息会同步到本地文件系统中，但文件内容不会立即同步，只有真正用到文件内容时才会同步下来。这样一来可以节省本地的硬盘空间。并不是所有Windows系统都支持该功能，只有安装了2017年10月份发布的<a href="https://blogs.windows.com/windowsexperience/2017/09/01/create-and-play-this-holiday-with-the-windows-10-fall-creators-update-coming-oct-17/#S6S0hTTo5v4hZw8X.97" target="_blank" rel="noopener">秋季更新</a>的Windows 10系统才可以。</p><p>显然，当OneDrive中的文件还没有将内容同步下来时，它并不算是一个“常规文件”，难怪<code>boost::filesystem::is_regular_file</code>会返回false。事实上，用<code>boost::filesystem::status</code>获取这些文件的类型时，会返回<code>symlink_file</code>，boost.filesystem将它们视为符号链接文件。</p><p>不论是常规文件还是符号链接文件，呈现给用户的都是能够正常使用的文件。所以，不能单纯地用<code>boost::filesystem::is_regular_file</code>来检查文件是否存在了，下面是包装函数的改进版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFileExistent</span><span class="params">(<span class="keyword">const</span> boost::filesystem::path&amp; path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    boost::system:error_code error;</span><br><span class="line">    <span class="keyword">auto</span> file_status = boost::filesystem::status(path, error);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! boost::filesystem::exists(file_status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boost::filesystem::is_directory(file_status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过<code>boost::filesystem::status</code>获取文件的信息，如果发生错误，则认为文件不存在。然后，使用<code>boost::filesystem::exists</code>判断文件是否存在，该函数不区分文件夹和文件，所以最后还要使用<code>boost::filesystem::is_directory</code>判断一下是否文件夹，只要不是文件夹，都认为文件是存在的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我参与的项目中，使用了boost.filesystem进行文件操作。boost.filesystem在发生错误的时候会抛出异常，但是在大部分情况下这些异常是可以忽略的，例如，在检查文件是否存在的时候，发生错误可以等同于文件不存在。虽然boost.filesystem也提供了重载函数，通过输出参数返回错误来代替异常，但是在每个调用点都得定义一个输出参数，稍显麻烦。所以，为了简化客户代码，我们实现了一些包装函数，如下所示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="boost" scheme="http://zplutor.github.io/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>如何调试程序静默退出</title>
    <link href="http://zplutor.github.io/2017/11/12/how-to-debug-program-silent-exit/"/>
    <id>http://zplutor.github.io/2017/11/12/how-to-debug-program-silent-exit/</id>
    <published>2017-11-12T05:11:42.000Z</published>
    <updated>2017-11-12T05:20:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序的静默退出，俗称闪退，是一个令人郁闷的问题。闪退发生的时候，没有任何提示，也没有留下任何现场信息（除了闪退之前一些没什么用的日志），导致很难去定位和解决。</p><a id="more"></a><p>总的来说，闪退一般是在以下几种情况下出现的：</p><ul><li><p>程序发生异常。有些特殊的异常会使异常捕获机制失效，因此我们准备好的错误报告，甚至是Windows的错误报告都不能正常执行。有时在Windows事件查看器中能看到对应的程序异常记录，但是这个记录的信息量太少，不足以定位异常。</p></li><li><p>程序被其它程序终止。听起来这有点匪夷所思，我的程序没有干任何坏事，为什么会无缘无故被终止？事实上这种情况确实发生过，举个例子：360安全卫士的某个版本会毫无预兆地终止企业微信。如果你恰好碰到了这样的问题，可以尝试把360安全卫士升级到最新版本。</p></li><li><p>程序自行终止。有些（设计不合理的）程序会在某些不能继续执行的情况下调用<code>TerminateProcess</code>来终止自己。通常在终止之前程序要进行提示或者留下一点日志，以方便调试。然而有的程序的确会给自己带来麻烦，终止之前不留下一丝痕迹。</p></li></ul><p>幸运的是，Windows已经针对闪退问题提供了专门的调试功能。这个功能需要使用GFlags工具来开启，GFlags包含在Windows SDK的Debugging Tools中，可以通过安装这个套件来获取。运行GFlags后，切换到Silent Process Exit标签（GFlags可以开启很多调试功能，闪退调试只是其中一个），参考下图来进行设置：</p><img src="/2017/11/12/how-to-debug-program-silent-exit/1.png"><p>Silent Process Exit可以针对指定程序进行设置，也可以全局设置，一般只需要针对我们自己的程序设置即可。在Application Specific Settings的Image一栏，填入程序的可执行文件名称，然后按下TAB键，即可打开这个程序的设置。</p><p>在Reporting Mode一栏，首先勾选Enable Silent Process Exit Monitoring 选项，然后根据需要勾选其它四个选项。</p><ul><li><p>Enable dump collection，勾选了该选项后，程序退出的时候生成dump文件。该选项可以保留退出时的现场环境，一般都要勾选。同时需要填写Dump Folder Location和Dump Type两栏。</p></li><li><p>Launch monitor process，勾选了该选项后，程序退出的时候会启动指定的进程来调试。如果已经勾选了生成dump，那么不太必要再启动调试器了。同时需要填写Monitor Process一栏。</p></li><li><p>Enable notification，勾选了该选项后，程序退出的时候会在系统任务栏区域弹出提示。实践发现这个选项有时不生效，程序闪退时没有提示。</p></li><li><p>Ignore Self Exists，勾选了该选项后，程序自行的退出会被忽略。如果不勾选，程序每次正常退出时系统都会根据前面三个选项进行处理，勾选这个选项可以避免不必要的骚扰。可是实践发现这个选项有时也会不生效，有些程序正常退出也会触发前面选项的处理。</p></li></ul><p>这里以记事本程序<code>notepad.exe</code>为例子，按确定按钮保存设置。打开记事本，在任务管理器中结束它，此时系统任务栏会弹出提示：</p><img src="/2017/11/12/how-to-debug-program-silent-exit/2.png"><p>在事件查看器中可以看到对应的记录。同时在<code>C:\</code>下生成了对应的dump文件：</p><img src="/2017/11/12/how-to-debug-program-silent-exit/3.png"><p>Windows提供的这个调试功能非常方便，但是GFlags的使用方式仍有一定门槛，不是每个用户都能快速按照我们的指引来设置。为了节约沟通成本，最好能有一种自动化的方式来帮用户打开这个功能。事实上，GFlags是通过修改注册表来实现功能的，所以只要把对应的注册表项导出，再让用户导入即可。</p><p>以上面记事本的设置为例，对应的注册表项如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe]</span><br><span class="line">&quot;GlobalFlag&quot;=dword:00000200</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe]</span><br><span class="line">&quot;LocalDumpFolder&quot;=&quot;C:\\&quot;</span><br><span class="line">&quot;DumpType&quot;=dword:00000121</span><br><span class="line">&quot;ReportingMode&quot;=dword:00000006</span><br><span class="line">&quot;IgnoreSelfExits&quot;=dword:00000001</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序的静默退出，俗称闪退，是一个令人郁闷的问题。闪退发生的时候，没有任何提示，也没有留下任何现场信息（除了闪退之前一些没什么用的日志），导致很难去定位和解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="异常" scheme="http://zplutor.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>在Visual Studio和XCode之间兼容性最好的文本编码</title>
    <link href="http://zplutor.github.io/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/"/>
    <id>http://zplutor.github.io/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/</id>
    <published>2017-04-02T06:42:04.000Z</published>
    <updated>2017-04-06T15:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨平台开发的文本编码问题"><a href="#跨平台开发的文本编码问题" class="headerlink" title="跨平台开发的文本编码问题"></a>跨平台开发的文本编码问题</h2><p>有一个跨平台的模块需要同时在Visual Studio 2013和XCode 8下开发，在开发过程中发现以下问题：</p><a id="more"></a><ul><li><p>在Visual Studio创建的代码文件，里面的中文注释在XCode下会显示成乱码：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/1.png"></li><li><p>在XCode创建的代码文件，如果里面包含中文注释，在Visual Studio中编译时可能会产生C4819警告：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/2.png"></li></ul><p>产生这些问题的原因是两款IDE对文本编码的支持方式不一致。为了解决它们，需要弄清楚Visual Studio和XCode的异同。</p><h2 id="Visual-Studio对文本编码的支持"><a href="#Visual-Studio对文本编码的支持" class="headerlink" title="Visual Studio对文本编码的支持"></a>Visual Studio对文本编码的支持</h2><p>Visual Studio的默认编码是ANSI，也就是Windows当前语言的编码。对于简体中文来说就是GB2312。默认编码无法设置。</p><p>打开了一个文件之后，在Visual Studio的“文件” - “高级保存选项”菜单中可以修改当前文件的编码：<br><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/3.png"></p><p>在弹出的对话框中可以选择各种编码：<br><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/4.png"></p><p>Visual Studio只能手动一个一个地转换文本编码，不能做到自动转换或者批量转换。</p><p>虽然在上面的列表中可以找到UTF-8 without BOM编码，并且Visual Studio也确实能够正确显示这种编码的文件内容，但实测发现编译器并不能很好地支持这种编码。例如，当文件中含有奇数个中文字符时，编译的时候会出现上文说的C4819警告；而当含有偶数个中文字符时，则一切正常。</p><h2 id="XCode对文本编码的支持"><a href="#XCode对文本编码的支持" class="headerlink" title="XCode对文本编码的支持"></a>XCode对文本编码的支持</h2><p>XCode的默认编码是UTF-8 without BOM，可以在Preferences中修改默认编码：<br><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/5.png"></p><p>在该选项中可以选择各种文本编码：<br><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/6.png"></p><p>然而实测发现这个选项没有什么用。修改之后，新建的文件仍然是UTF-8编码，打开的文件也不会使用指定编码。</p><p>XCode并没有区分UTF-8 with BOM和UTF-8 without BOM，默认是UTF-8 without BOM，但它还是能够打开和编辑UTF-8 with BOM编码的文件。</p><p>打开了一个文件后，在Utilities面板中可以查看和设置当前文件使用的编码：<br><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/7.png"></p><p>XCode的编码检测也不准确。例如，GB2312编码的文件会被检测为Western (Mac OS Roman)，导致中文显示成乱码。</p><p>通过下拉列表修改了文本编码后，XCode会弹出以下的对话框，询问是要转换编码还是重新解析文件：<br><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/8.png"></p><p>Convert选项会把当前文件转换成选择的编码；Reinterpret选项会以选择的编码重新解析当前文件。如果内容显示正常，只想改变编码的话，应该使用Convert；如果内容出现乱码，应该使用Reinterpret重新解析。</p><h2 id="选择兼容性最好的文本编码"><a href="#选择兼容性最好的文本编码" class="headerlink" title="选择兼容性最好的文本编码"></a>选择兼容性最好的文本编码</h2><p>综合两款IDE对文本编码的支持情况，可以知道能够同时被Visual Studio和XCode支持的文本编码是：</p><ul><li>UTF-8 with BOM</li><li>UTF-16 BE</li><li>UTF-16 LE</li><li>GB2312（以及其它区域语言）</li></ul><p>对于代码文件，UTF-16比较浪费空间，所以首先排除掉。至于GB2312等区域语言，由于XCode无法正确检测出这种编码的文件，每次打开的时候都要手工转换一下，所以也不是理想的选择。</p><p>最后只剩下UTF-8 with BOM。Visual Studio和XCode都能够直接打开和编辑这种编码的文件，无需进行任何转换。遗憾的是，两款IDE都不能直接创建这种编码的文件，只能在创建之后再手工转换一下（XCode需要借助工具来转换）。虽然存在这个不足，不过UTF-8 with BOM是当前情况下兼容性最好的选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;跨平台开发的文本编码问题&quot;&gt;&lt;a href=&quot;#跨平台开发的文本编码问题&quot; class=&quot;headerlink&quot; title=&quot;跨平台开发的文本编码问题&quot;&gt;&lt;/a&gt;跨平台开发的文本编码问题&lt;/h2&gt;&lt;p&gt;有一个跨平台的模块需要同时在Visual Studio 2013和XCode 8下开发，在开发过程中发现以下问题：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="字符编码" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
      <category term="macOS" scheme="http://zplutor.github.io/tags/macOS/"/>
    
      <category term="Visual Studio" scheme="http://zplutor.github.io/tags/Visual-Studio/"/>
    
      <category term="XCode" scheme="http://zplutor.github.io/tags/XCode/"/>
    
  </entry>
  
  <entry>
    <title>STL中的二分查找</title>
    <link href="http://zplutor.github.io/2017/03/14/binary-search-in-stl/"/>
    <id>http://zplutor.github.io/2017/03/14/binary-search-in-stl/</id>
    <published>2017-03-14T15:41:16.000Z</published>
    <updated>2017-03-14T16:07:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是重要且常用的算法，在STL中自然少不了它的身影。本文介绍一下在STL中与二分查找有关的函数。</p><a id="more"></a><p>要注意，这些函数都要求集合是有序的，在使用之前应使用<code>std::sort</code>等函数对集合进行排序。</p><h2 id="检查元素是否存在"><a href="#检查元素是否存在" class="headerlink" title="检查元素是否存在"></a>检查元素是否存在</h2><h3 id="std-binary-search"><a href="#std-binary-search" class="headerlink" title="std::binary_search"></a>std::binary_search</h3><p><code>std::binary_search</code>用来检查指定的元素是否存在集合中，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span> );</span></span><br></pre></td></tr></table></figure><p>第一个原型使用<code>&lt;</code>操作符来比较元素，第二个原型使用指定的比较器来比较元素。比较器的比较规则应该与排序时使用的比较规则一致。</p><p>使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认比较器来查找元素</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> exist;</span><br><span class="line">exist = <span class="built_in">std</span>::binary_search(numbers.begin(), numbers.end(), <span class="number">3</span>); <span class="comment">// exist = true</span></span><br><span class="line">exist = <span class="built_in">std</span>::binary_search(numbers.begin(), numbers.end(), <span class="number">4</span>); <span class="comment">// exist = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义比较器来查找元素</span></span><br><span class="line"><span class="keyword">auto</span> comparer = [](<span class="keyword">int</span> i1, <span class="keyword">int</span> i2) &#123;</span><br><span class="line">    <span class="keyword">return</span> i1 &gt; i2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort(numbers.begin(), numbers.end(), comparer); <span class="comment">// 9, 7, 5, 3, 1</span></span><br><span class="line">exist = <span class="built_in">std</span>::binary_search(numbers.begin(), numbers.end(), <span class="number">5</span>, comparer); <span class="comment">//exist = true</span></span><br><span class="line">exist = <span class="built_in">std</span>::binary_search(numbers.begin(), numbers.end(), <span class="number">6</span>, comparer); <span class="comment">//exist = false</span></span><br></pre></td></tr></table></figure><p><code>std::binary_search</code>至多需要进行<code>log2(last - first) + O(1)</code>次比较。</p><p><code>std::binary_search</code>的使用场景比较单一，它只能知道某个元素是否存在集合中。如果要获取元素的位置，需要使用下面的函数。</p><h2 id="获取元素位置"><a href="#获取元素位置" class="headerlink" title="获取元素位置"></a>获取元素位置</h2><h3 id="std-lower-bound"><a href="#std-lower-bound" class="headerlink" title="std::lower_bound"></a>std::lower_bound</h3><p><code>std::lower_bound</code>用来获取集合中第一个不小于指定值的元素位置，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">lower_bound</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">lower_bound</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span> );</span></span><br></pre></td></tr></table></figure><p>第一个原型使用<code>&lt;</code>操作符来比较元素，第二个原型使用指定的比较器来比较元素。比较器的比较规则应该与排序时使用的比较规则一致。</p><p>使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iterator;</span><br><span class="line">iterator = <span class="built_in">std</span>::lower_bound(numbers.begin(), numbers.end(), <span class="number">3</span>); </span><br><span class="line"><span class="comment">// *iterator = 3</span></span><br><span class="line"></span><br><span class="line">iterator = <span class="built_in">std</span>::lower_bound(numbers.begin(), numbers.end(), <span class="number">4</span>); </span><br><span class="line"><span class="comment">// *iterator = 5</span></span><br><span class="line"></span><br><span class="line">iterator = <span class="built_in">std</span>::lower_bound(numbers.begin(), numbers.end(), <span class="number">11</span>); </span><br><span class="line"><span class="comment">// iterator = numbers.end()</span></span><br></pre></td></tr></table></figure><p>要注意，<code>std::lower_bound</code>返回的迭代器指向的是第一个不小于（即等于或大于）指定值的元素，所以在它返回之后还要再检查一次，以确认真的找到了该元素。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取集合</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers = ...; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查找元素位置</span></span><br><span class="line"><span class="keyword">auto</span> iterator = <span class="built_in">std</span>::lower_bound(numbers.begin(), numbers.end(), <span class="number">3</span>); </span><br><span class="line"><span class="keyword">if</span> (iterator != numbers.end() &amp;&amp; *iterator == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">//集合中存在该元素，iterator指向它。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//集合中不存在该元素，iterator指向第一个大于它的元素，或集合末尾。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计的好处是，如果要执行的是“如果元素不存在则插入”的操作，那么可以直接往<code>iterator</code>指向的位置插入新元素，而不必担心破坏集合的有序性。</p><p><code>std::lower_bound</code>至多需要进行<code>log2(last - first) + O(1)</code>次比较。</p><h3 id="std-upper-bound"><a href="#std-upper-bound" class="headerlink" title="std::upper_bound"></a>std::upper_bound</h3><p>与<code>std::lower_bound</code>类似，<code>std::upper_bound</code>用来获取集合中第一个大于指定值的元素位置，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">upper_bound</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">upper_bound</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>, <span class="title">Compare</span> <span class="title">comp</span> );</span></span><br></pre></td></tr></table></figure><p>第一个原型使用<code>&lt;</code>操作符来比较元素，第二个原型使用指定的比较器来比较元素。比较器的比较规则应该与排序时使用的比较规则一致。</p><p>使用示例如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iterator;</span><br><span class="line">iterator = <span class="built_in">std</span>::upper_bound(numbers.begin(), numbers.end(), <span class="number">3</span>); </span><br><span class="line"><span class="comment">// *iterator = 5</span></span><br><span class="line"></span><br><span class="line">iterator = <span class="built_in">std</span>::upper_bound(numbers.begin(), numbers.end(), <span class="number">4</span>); </span><br><span class="line"><span class="comment">// *iterator = 5</span></span><br><span class="line"></span><br><span class="line">iterator = <span class="built_in">std</span>::upper_bound(numbers.begin(), numbers.end(), <span class="number">11</span>); </span><br><span class="line"><span class="comment">// iterator = numbers.end()</span></span><br></pre></td></tr></table></figure></p><p>由于<code>std::upper_bound</code>返回的迭代器指向的是第一个大于指定值的元素，相对来说它的使用场景较<code>std::lower_bound</code>要少。</p><p><code>std::upper_bound</code>至多需要进行<code>log2(last - first) + O(1)</code>次比较。</p><h3 id="std-equal-range"><a href="#std-equal-range" class="headerlink" title="std::equal_range"></a>std::equal_range</h3><p><code>std::equal_range</code>用来获取集合中所有与指定值相等的元素范围，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:pair&lt;ForwardIt,ForwardIt&gt; equal_range( ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value );</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Compare</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">std</span>:</span>:pair&lt;ForwardIt,ForwardIt&gt; equal_range( ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value, Compare comp );</span><br></pre></td></tr></table></figure><p>第一个原型使用<code>&lt;</code>操作符来比较元素，第二个原型使用指定的比较器来比较元素。比较器的比较规则应该与排序时使用的比较规则一致。</p><p><code>std::equal_range</code>返回一对迭代器，第一个迭代器指向第一个不小于指定值的元素（等同于<code>std::lower_bound</code>的返回值），第二个迭代器指向第一个大于指定值的元素（等同于<code>std::upper_bound</code>的返回值）。如果两个迭代器相等，说明不存在这样的元素。</p><p>使用示例如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; iterator_pair;</span><br><span class="line">iterator_pair = <span class="built_in">std</span>::equal_range(numbers.begin(), numbers.end(), <span class="number">3</span>); </span><br><span class="line"><span class="comment">// *iterator_pair.first = 3, *iterator_pair.second = 5(1)  括号中的数字表示是第几个，下同</span></span><br><span class="line"></span><br><span class="line">iterator_pair = <span class="built_in">std</span>::equal_range(numbers.begin(), numbers.end(), <span class="number">5</span>); </span><br><span class="line"><span class="comment">// *iterator_pair.first = 5(1), *iterator_pair.second = 7</span></span><br><span class="line"></span><br><span class="line">iterator_pair = <span class="built_in">std</span>::equal_range(numbers.begin(), numbers.end(), <span class="number">8</span>); </span><br><span class="line"><span class="comment">// *iterator_pair.first = *iterator_pair.second = 9</span></span><br><span class="line"></span><br><span class="line">iterator_pair = <span class="built_in">std</span>::equal_range(numbers.begin(), numbers.end(), <span class="number">9</span>); </span><br><span class="line"><span class="comment">// *iterator_pair.first = 9, iterator_pair.second = numbers.end()</span></span><br><span class="line"></span><br><span class="line">iterator_pair = <span class="built_in">std</span>::equal_range(numbers.begin(), numbers.end(), <span class="number">11</span>); </span><br><span class="line"><span class="comment">// iterator_pair.first = iterator_pair.second = numbers.end()</span></span><br></pre></td></tr></table></figure></p><p><code>std::equal_range</code>至多需要进行<code>2 * log2(last - first) + O(1)</code>次比较，在性能上不如<code>std::lower_bound</code>和<code>std::upper_bound</code>，所以如果不需要获取相等元素区间的话，按需调用<code>std::lower_bound</code>或<code>std::upper_bound</code>是更好的选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找是重要且常用的算法，在STL中自然少不了它的身影。本文介绍一下在STL中与二分查找有关的函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>libcurl动态超时的陷阱</title>
    <link href="http://zplutor.github.io/2016/11/20/a-trap-of-dynamic-timeout-in-libcurl/"/>
    <id>http://zplutor.github.io/2016/11/20/a-trap-of-dynamic-timeout-in-libcurl/</id>
    <published>2016-11-20T14:35:41.000Z</published>
    <updated>2016-11-20T14:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在《<a href="http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/">如何设置libcurl的动态超时值</a>》中提到，动态超时值（通过<code>CURLOPT_LOW_SPEED_LIMIT</code>和<code>CURLOPT_LOW_SPEED_TIME</code>设置）比固定超时值（通过<code>CURLOPT_TIMEOUT</code>设置）更符合实际需要，所以我一般只设置动态超时值，而不设置固定超时值。然而，在实际使用中发现，有时网络请求会一直没有结束，也就是说设置的动态超时值在某些情况下会失效。在阅读了libcurl的源代码之后，我发现原来动态超时值存在一个陷阱。</p><a id="more"></a><p>简单地说，libcurl只在下载响应数据阶段才会检测动态超时，如果网络请求一直没有进入这个阶段，那么动态超时值就没有作用了。下面我们从libcurl的内部机制分析一下这个陷阱。</p><p>在libcurl内部，网络请求由Session对象表示，而Session对象由Multi对象管理。Multi对象是一个管理器，它自身维护一个定时器，每隔一段时间触发一次Session对象执行。也就是说，Session本身不会主动执行，而是由Multi来驱动执行， 如下图所示：</p><img src="/2016/11/20/a-trap-of-dynamic-timeout-in-libcurl/1.png"><p>Session的实现是一个状态机，从请求开始到结束，大致要经过以下状态（这是一份精简过的状态，实际状态比这个复杂）：</p><ul><li>Init，初始化状态。</li><li>Connect，正在连接状态。</li><li>Do，正在发送请求数据状态。</li><li>WaitPerform，等待响应状态。</li><li>Perform，正在接收响应数据状态。</li><li>Completed，完成状态。</li></ul><p>一般情况下，只有当Session处于Perform状态时，libcurl才会检测动态超时。所以，一旦等不到服务器的响应，Session就会一直停留在WaitPerform状态，动态超时值也就没有任何作用了。</p><p>至于固定超时值，它的检测时机是在每次心跳触发Session对象执行的时候，与Session的状态机制没有任何关系，因此固定超时值总是有效的。</p><p>可见，licurl的超时机制并不够好——动态超时值不可靠，固定超时值又不能满足需求。那么在实践中应该如何做呢？有两种方法可供选择。首先，如果条件允许的话，可以摒弃libcurl的超时机制，自己来实现。这样的好处是可以自主控制超时，具有最大的灵活性。当然，这种方法复杂度较高，大部分情况下条件也不允许。</p><p>其次，可以通过不断设置固定超时值来模拟动态超时。例如，每收到libcurl的一次进度回调，就重新设置一个更大的固定超时值。虽然官方文档并没有明说，但从libcurl的源代码来看，这种做法是可行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《&lt;a href=&quot;http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/&quot;&gt;如何设置libcurl的动态超时值&lt;/a&gt;》中提到，动态超时值（通过&lt;code&gt;CURLOPT_LOW_SPEED_LIMIT&lt;/code&gt;和&lt;code&gt;CURLOPT_LOW_SPEED_TIME&lt;/code&gt;设置）比固定超时值（通过&lt;code&gt;CURLOPT_TIMEOUT&lt;/code&gt;设置）更符合实际需要，所以我一般只设置动态超时值，而不设置固定超时值。然而，在实际使用中发现，有时网络请求会一直没有结束，也就是说设置的动态超时值在某些情况下会失效。在阅读了libcurl的源代码之后，我发现原来动态超时值存在一个陷阱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="libcurl" scheme="http://zplutor.github.io/tags/libcurl/"/>
    
      <category term="超时" scheme="http://zplutor.github.io/tags/%E8%B6%85%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>如何让指定的程序崩溃</title>
    <link href="http://zplutor.github.io/2016/09/08/how-to-make-a-specified-application-crash/"/>
    <id>http://zplutor.github.io/2016/09/08/how-to-make-a-specified-application-crash/</id>
    <published>2016-09-08T12:24:38.000Z</published>
    <updated>2016-09-08T12:42:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了验证程序崩溃信息的收集和上报机制，需要让程序崩溃。为了达到这个目的，一般的做法是临时在程序中加入引发异常的代码。这种做法只在开发人员自己编译的版本中有效，在正式版本中无法进行验证。另外一种方法是加入一个隐藏开关，但这样会在正式版本中带上调试代码，也不理想。最好的方法是在不修改任何代码的前提下，也能够让程序崩溃。</p><a id="more"></a><p>这看起来似乎不可能，但实际上是可行的，而且做法简单得让人惊讶。Windows API有一个<code>CreateRemoteThread</code>函数，这个函数可以在指定的进程中创建一个线程，并且能够让这个线程执行任意代码——DLL注入就是通过这种方式实现的。显然，只要用这个函数创建一个会产生异常的线程就可以了。先来看一下这个函数的原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HANDLE                 hProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  SIZE_T                 dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPVOID                 lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  DWORD                  dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ LPDWORD                lpThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p><p>值得关注的是<code>hProcess</code>和<code>lpStartAddress</code>参数，其它参数的含义可以参考MSDN文档，这里不再赘述。先来看<code>lpStartAddress</code>参数，这个参数指定线程的入口点地址，这个地址必须是在目标进程的地址空间中。在本文的特殊需求下，我们并不需要传一个实际可执行的地址，只需要传入<code>0</code>即可。这样的话，该线程会尝试从0地址执行，这毫无疑问会引发访问违规异常，导致程序崩溃——这就达到了我们的目的。</p><p>再来看<code>hProcess</code>参数，这个参数表示目标进程的句柄，这个句柄必须具有以下访问权限：</p><ul><li>PROCESS_CREATE_THREAD</li><li>PROCESS_QUERY_INFORMATION</li><li>PROCESS_VM_OPERATION</li><li>PROCESS_VM_WRITE</li><li>PROCESS_VM_READ</li></ul><p>有了这些基础知识，我们就可以写一个简单的命令行程序来让指定的进程崩溃了。完整的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L"A PID is needed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L"Invalid PID."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE process_handle = OpenProcess(</span><br><span class="line">        PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,</span><br><span class="line">        FALSE,</span><br><span class="line">        pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process_handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L"Open process failed. Error: "</span> &lt;&lt; GetLastError() &lt;&lt; <span class="string">'.'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE thread_handle = CreateRemoteThread(process_handle, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (thread_handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L"Create remote thread failed. Error: "</span> &lt;&lt; GetLastError() &lt;&lt; <span class="string">'.'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L"Crashed. :)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设这个命令行程序的名称是<code>crasher.exe</code>，目标进程的PID是<code>10032</code>，那么只要像下面这样调用就能让这个进程崩溃：</p><pre><code>crasher.exe 10032</code></pre><p>如果你的目标进程是一个普通程序，那么本文到这里就结束了。但如果你的目标进程是一个服务程序，情况就有所不同了。CreateRemoteThread有一个限制，它不能跨会话来创建线程。例如，服务程序都在0号会话下运行，而制造崩溃的程序是在当前用户登录的会话下运行（必定不是0号会话），所以CreateRemoteThread的调用会失败。为了解决这个问题，需要让制造崩溃的程序转移到0号会话下运行。可以借助Sysinternals出品的<code>PsExec</code>工具来实现这个目的，只要执行下面的命令行即可：</p><pre><code>PsExec.exe -accepteula -s crasher.exe 10032</code></pre><p><code>-accepteula</code>参数表示接受Sysinternals的最终用户许可协议。Sysinternals的工具在首次使用的时候都会弹出最终用户许可协议对话框，使用这个参数可以防止对话框弹出。<code>-s</code>表示在系统会话，也就是0号会话中执行后面的命令。最终效果就是在0号会话中执行了<code>crasher.exe 10032</code>这个命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了验证程序崩溃信息的收集和上报机制，需要让程序崩溃。为了达到这个目的，一般的做法是临时在程序中加入引发异常的代码。这种做法只在开发人员自己编译的版本中有效，在正式版本中无法进行验证。另外一种方法是加入一个隐藏开关，但这样会在正式版本中带上调试代码，也不理想。最好的方法是在不修改任何代码的前提下，也能够让程序崩溃。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="异常" scheme="http://zplutor.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>使用ProcDump捕获程序崩溃信息</title>
    <link href="http://zplutor.github.io/2016/08/15/catch-application-crashing-information-with-procdump/"/>
    <id>http://zplutor.github.io/2016/08/15/catch-application-crashing-information-with-procdump/</id>
    <published>2016-08-15T14:04:57.000Z</published>
    <updated>2016-08-15T14:09:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>当程序崩溃的时候，捕获崩溃信息并进行上报对提升产品质量有很大帮助，它能发现很多在开发和测试阶段发现不了的问题。Windows的WER（Windows Error Reporting）组件在系统级别上提供了捕获崩溃信息的能力，它能够在程序崩溃时生成一个内存转储文件（即dump文件），该文件包含了引发崩溃的异常信息。然而，这个功能仅在Windows Vista SP1及更高的版本中存在，而且它是可配置的，用户可以阻止WER生成dump文件。这意味着我们不能依赖系统来捕获崩溃信息，而是要通过别的途径。</p><a id="more"></a><p>其中一个可选的方案是使用Sysinternals出品的ProcDump。ProcDump是一个命令行工具，它其中的一个功能就是用来捕获程序的崩溃信息。该方案的流程如下：</p><ul><li>在程序开始执行的时候，启动ProcDump，并且把自己的进程ID传递给它，让它一直监视该进程。</li><li>ProcDump一直在后台运行，直到程序正常退出，或者发生崩溃。在后一种情况下，ProcDump会在指定的目录生成dump文件。</li><li>程序下一次启动时，发现存在dump文件，进行上报。</li></ul><p>可见，这种方案非常简单，只要用正确的参数启动ProcDump即可。假设我们的程序安装在<code>C:\MyApp</code>，进程ID是<code>10032</code>，则启动ProcDump的命令行如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\MyApp\bin\procdump.exe&quot; -accepteula -e 10032 &quot;C:\MyApp\dump&quot;</span><br></pre></td></tr></table></figure></p><p>启动ProcDump时最好指定<code>procdump.exe</code>的绝对路径，避免进程工作目录改变带来的问题。第一个参数<code>-accepteula</code>表示接受Sysinternals的最终用户许可协议。Sysinternals的工具在首次使用的时候都会弹出最终用户许可协议对话框，使用这个参数可以防止对话框弹出。第二个参数<code>-e</code>表示在进程发生未处理异常（也就是崩溃）时生成dump文件。第四个参数是进程ID，表示让ProcDump监视哪个进程。最后一个参数指定dump文件存放的文件夹路径，要注意的是，这个文件夹必须要预先创建，否则ProcDump会认为这是一个文件路径，并向这个路径写数据，导致异常行为。</p><p>最后，程序需要在启动的时候拼接好上述命令行，并调用<code>CreateProcess</code>来启动该命令行。要记得在调用时给<code>dwCreationFlags</code>参数传入<code>CREATE_NO_WINDOW</code>，防止出现控制台窗口。</p><p>这个方案实现简单，学习成本低，即使不了解异常相关的机理也可以快速实现崩溃信息收集。但它有一个弊端：ProcDump是以调试器的的身份附加到指定进程上的，进程中发生的调试事件（例如线程的创建和销毁）会导致进程间通信开销，这会稍微影响程序的性能。如果这些性能开销不可接受，则要考虑其它的方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当程序崩溃的时候，捕获崩溃信息并进行上报对提升产品质量有很大帮助，它能发现很多在开发和测试阶段发现不了的问题。Windows的WER（Windows Error Reporting）组件在系统级别上提供了捕获崩溃信息的能力，它能够在程序崩溃时生成一个内存转储文件（即dump文件），该文件包含了引发崩溃的异常信息。然而，这个功能仅在Windows Vista SP1及更高的版本中存在，而且它是可配置的，用户可以阻止WER生成dump文件。这意味着我们不能依赖系统来捕获崩溃信息，而是要通过别的途径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="procdump" scheme="http://zplutor.github.io/tags/procdump/"/>
    
  </entry>
  
  <entry>
    <title>使用std::wstring_convert进行字符编码转换</title>
    <link href="http://zplutor.github.io/2016/07/03/convert-character-encoding-using-std-wstring-convert/"/>
    <id>http://zplutor.github.io/2016/07/03/convert-character-encoding-using-std-wstring-convert/</id>
    <published>2016-07-03T06:00:49.000Z</published>
    <updated>2018-04-08T16:57:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11新增的std::wstring_convert可以很方便地在std::string和std::wstring之间进行转换。例如，把一个std::wstring转换成以UTF-8编码的std::string：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::wstring_convert&lt;<span class="built_in">std</span>::codecvt_utf8&lt;<span class="keyword">wchar_t</span>&gt;&gt; converter;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">string</span> = converter.to_bytes(<span class="string">L"这是一个宽字符串"</span>);</span><br></pre></td></tr></table></figure><p>反过来，把一个以UTF-8编码的std::string转换成std::wstring：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::wstring_convert&lt;<span class="built_in">std</span>::codecvt_utf8&lt;<span class="keyword">wchar_t</span>&gt;&gt; converter;</span><br><span class="line"><span class="built_in">std</span>::wstring wide_string = converter.from_bytes(<span class="string">"\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2”);  //字符串的内容为“字符串”</span></span><br></pre></td></tr></table></figure></p><p>std::wstring_convert使用模板参数中指定的codecvt进行实际的转换工作，也就是说，std::string使用哪种字符编码由这个codecvt来决定。上面的例子用的是std::codecvt_utf8，即UTF-8编码。理论上，指定不同的codecvt，即可支持各种字符编码。但是，如何得到合适codecvt则是不小的问题。</p><p>来看一下std::wstring_convert其中一个构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wstring_convert(codecvt* pcvt = <span class="keyword">new</span> codecvt);</span><br></pre></td></tr></table></figure></p><p>在构造std::wstring_convert对象的时候需要传入一个codecvt对象的指针，如果没有传入，则默认使用<code>new codecvt</code>来创建。std::wstring_convert自行维护codecvt对象的生命周期，它的析构函数会调用delete操作符来删除该对象。这就限制了只能使用通过new操作符来创建的codecvt，而不能使用从std::locale中获取的codecvt。</p><p>在C++标准提供的codecvt中，能够直接用于std::wstring_convert的只有三个：std::codecvt_utf8，std::codecvt_utf16以及std::codecvt_utf8_utf16。可见，标准只支持UTF族的字符编码。为了获取其它字符编码的codecvt，需要使用std::codecvt_byname，这个类可以通过字符编码的名称来创建一个codecvt。这看起来挺不错，但遗憾的是，字符编码的名称并没有统一的标准，各个平台的支持情况都不一样。例如，在Windows下可以使用“chs”来创建简体中文编码的codecvt，在Mac OS X下则要使用“zh_cn.gb2312”；甚至在Mac OS X下，即使成功创建了这个codecvt，它也不能正常地转换。</p><p>下面以Windows为例，说明如何将std::codecvt_byname用于std::wstring_convert。由于历史原因，std::codecvt_byname的析构函数是protected的，std::wstring_convert不能对它调用delete，所以首先要自行定义一个类来继承std::codecvt_byname：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chs_codecvt</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::codecvt_byname&lt;<span class="keyword">wchar_t</span>, <span class="keyword">char</span>, <span class="built_in">std</span>::<span class="keyword">mbstate_t</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    chs_codecvt() : codecvt_byname(<span class="string">"chs"</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>chs_codecvt的默认析构函数是public的，从而让std::wstring_convert可以删除它。为方便起见，在chs_codecvt的构造函数中，直接把“chs”传给了std::codecvt_byname。</p><p>接下来的用法跟本文开头的例子基本一致：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::wstring_convert&lt;chs_codecvt&gt; converter;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">string</span> = converter.to_bytes(<span class="string">L"你好"</span>);</span><br><span class="line"><span class="built_in">std</span>::wstring wide_string = converter.from_bytes(<span class="string">"\xc4\xe3\xba\xc3”);  //字符串的内容为“你好”</span></span><br></pre></td></tr></table></figure></p><p>综上所述，只有UTF编码的转换是完全符合C++标准并且真正能够跨平台的，使用这些国际化的字符编码能够减少很多不必要的麻烦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++11新增的std::wstring_convert可以很方便地在std::string和std::wstring之间进行转换。例如，把一个std::wstring转换成以UTF-8编码的std::string：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
      <category term="字符串" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="字符编码" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>调用boost::filesystem::unique_path可能会失败</title>
    <link href="http://zplutor.github.io/2016/05/15/calling-boost-filesystem-unique-path-may-fail/"/>
    <id>http://zplutor.github.io/2016/05/15/calling-boost-filesystem-unique-path-may-fail/</id>
    <published>2016-05-15T12:48:57.000Z</published>
    <updated>2018-04-08T16:53:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>假如你的程序需要在指定目录下生成一个唯一的临时文件，而且恰好引入了boost库，那么你可能会选择使用boost::filesystem::unique_path来生成文件名，因为该函数似乎正是为了此目的而生的。但是要小心，该函数在某些环境下可能会失败，抛出“拒绝访问”的异常。</p><a id="more"></a><p>这里失败的原因并不是由于访问文件系统导致的，而是由于访问了Windows中与密码学相关的API。查看unique_path的源码，可以发现它内部调用了CryptAcquireContext和CryptGenRandom来生成随机数据，然后基于这些随机数据来生成文件名。由于未知的原因，在某些Windows系统上需要管理员权限才能成功调用CryptAcquireContext（正常情况下并不需要管理员权限），从而导致了unique_path失败。</p><p>所以，为了避免不必要的麻烦，直接使用GUID或者其它唯一性强的标识作为临时文件名即可。只有在涉及安全问题的情况下才应该考虑使用unique_path——此时就需要弄清楚为什么需要管理员权限才能调用CryptAcquireContext了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假如你的程序需要在指定目录下生成一个唯一的临时文件，而且恰好引入了boost库，那么你可能会选择使用boost::filesystem::unique_path来生成文件名，因为该函数似乎正是为了此目的而生的。但是要小心，该函数在某些环境下可能会失败，抛出“拒绝访问”的异常。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="boost" scheme="http://zplutor.github.io/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>STL中常用的集合操作函数</title>
    <link href="http://zplutor.github.io/2016/05/07/commonly-used-set-operation-functions-in-stl/"/>
    <id>http://zplutor.github.io/2016/05/07/commonly-used-set-operation-functions-in-stl/</id>
    <published>2016-05-07T13:24:41.000Z</published>
    <updated>2016-05-07T13:43:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>在实际的编程工作中，经常需要对两个集合进行各种操作，例如取交集、取并集等。在C++中，完全不需要自己来实现这些操作，因为STL已经为我们准备好了这些常用的集合操作函数。</p><a id="more"></a><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>STL的集合操作都基于排序区间，所以在调用这些函数之前要对集合排序。最常用的排序函数是<code>std::sort</code>，它的用法很简单，只要传入一对迭代器即可，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">vector</span>&#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::sort(<span class="built_in">vector</span>.begin(), <span class="built_in">vector</span>.end());</span><br><span class="line"><span class="comment">//vector的元素序列是 &#123; 2, 3, 5, 8, 9 &#125;</span></span><br></pre></td></tr></table></figure></p><p>std:sort默认使用<code>&lt;</code>操作符来比较元素，当然也可以使用自定义的比较函数来改变排序规则。例如，下面的例子使用<code>&gt;</code>操作符比较元素：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">vector</span>&#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::sort(<span class="built_in">vector</span>.begin(), <span class="built_in">vector</span>.end(), [](<span class="keyword">int</span> v1, <span class="keyword">int</span> v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//vector的元素序列是 &#123; 9, 8, 5, 3, 2 &#125;</span></span><br></pre></td></tr></table></figure></p><p>与std::sort一样，下文介绍的所有集合操作函数默认都使用&lt;操作符来比较元素，而且都可以在最后一个参数指定自定义的比较函数，这一点不再提及。但要注意的是，排序和集合操作使用的比较函数必须要一致，否则会有问题。另外，由于集合操作函数的输入都基于排序区间，所以这些函数的输出结果也是有序的，这点也不再提及。</p><p>STL保证std::sort的时间复杂度是<code>O(N·log(N))</code>，其中N为区间长度。</p><h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><p>对两个集合取交集可以使用<code>std::set_intersection</code>，该函数需要两对迭代器，以及一个输出迭代器，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector2&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">std</span>::set_intersection(</span><br><span class="line">    vector1.begin(), vector1.end(),  <span class="comment">//第一个区间</span></span><br><span class="line">    vector2.begin(), vector2.end(),  <span class="comment">//第二个区间</span></span><br><span class="line">    <span class="built_in">std</span>::back_inserter(result)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//result的元素序列是 &#123; 4, 6, 9 &#125;</span></span><br></pre></td></tr></table></figure></p><p>两个输入区间内的元素不会被修改，操作结果通过输出迭代器复制到另一个集合中。STL集合操作函数的用法都高度一致，下文其它函数的用法也是这样，仅仅是语义上不同。</p><p>STL保证std::set_intersection至多进行<code>2·(N1+N2-1)</code>次比较，其中N1是第一个区间的长度，N2是第二个区间的长度（N1和N2的定义下同）。</p><h2 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h2><p>对两个集合取并集可以使用<code>std::set_union</code>，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector2&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">std</span>::set_union(</span><br><span class="line">    vector1.begin(), vector1.end(),  <span class="comment">//第一个区间</span></span><br><span class="line">    vector2.begin(), vector2.end(),  <span class="comment">//第二个区间</span></span><br><span class="line">    <span class="built_in">std</span>::back_inserter(result)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//result的元素序列是 &#123; 1, 2, 3, 4, 6, 8, 9 &#125;</span></span><br></pre></td></tr></table></figure></p><p>STL保证std::set_union至多进行<code>2·(N1+N2-1)</code>次比较。</p><h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><p>对两个集合取差集可以使用<code>std::set_difference</code>，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector2&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">std</span>::set_difference(</span><br><span class="line">    vector1.begin(), vector1.end(),  <span class="comment">//第一个区间</span></span><br><span class="line">    vector2.begin(), vector2.end(),  <span class="comment">//第二个区间</span></span><br><span class="line">    <span class="built_in">std</span>::back_inserter(result)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//result的元素序列是 &#123; 1, 3 &#125;</span></span><br></pre></td></tr></table></figure></p><p>std::set_difference从第一个区间去除第二个区间的元素。</p><p>STL保证std::set_difference至多进行<code>2·(N1+N2-1)</code>次比较。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>合并两个集合可以使用<code>std::merge</code>，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector2&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">std</span>::merge(</span><br><span class="line">    vector1.begin(), vector1.end(),  <span class="comment">//第一个区间</span></span><br><span class="line">    vector2.begin(), vector2.end(),  <span class="comment">//第二个区间</span></span><br><span class="line">    <span class="built_in">std</span>::back_inserter(result)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//result的元素序列是 &#123; 1, 2, 3, 4, 4, 6, 6, 8, 9, 9 &#125;</span></span><br></pre></td></tr></table></figure></p><p>与std::set_union不同，std::merge不会去除重复的元素。</p><p>STL保证std::merge至多进行<code>N1+N2-1</code>次比较。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际的编程工作中，经常需要对两个集合进行各种操作，例如取交集、取并集等。在C++中，完全不需要自己来实现这些操作，因为STL已经为我们准备好了这些常用的集合操作函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>防止boost::asio::deadline_timer在修改系统时间后失效</title>
    <link href="http://zplutor.github.io/2016/04/16/prevent-boost-asio-deadline-timer-from-being-invalid-after-changing-system-time/"/>
    <id>http://zplutor.github.io/2016/04/16/prevent-boost-asio-deadline-timer-from-being-invalid-after-changing-system-time/</id>
    <published>2016-04-16T12:28:45.000Z</published>
    <updated>2018-04-08T16:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>boost::asio::deadline_timer使用的计量时间是系统时间，因此修改系统时间会影响deadline_timer的行为。例如，调用了expires_from_now设置1分钟超时后，立刻把系统时间改成一天前，那么要过一天时间才会超时。这个特性可能会影响程序功能的正常使用，因此我们通常想要的是一个不会受系统时间影响的定时器。</p><a id="more"></a><p>事实上，boost::asio::steady_timer就是一个这样的定时器，它基于std::chrono::steady_clock实现。std::chrono::steady_clock是一个稳定的时钟，不随系统时间变化而变化。既然如此，直接用steady_timer代替deadline_timer不就可以了吗？理论上来说是可以的，但实际上，在Visual C++ 2013环境下，这是行不通的，因为Visual C++ 2013标准库中的std::chronno::steady_clock并不符合标准，它仍然会受系统时间影响！</p><p>有三种方法可以解决这个问题。第一是升级到Visual C++ 2015，这个版本的std::chronno::steady_clock总算符合标准了；第二是修改boost的编译选项，定义BOOST_ASIO_DISABLE_STD_CHRONO宏，这样可以禁止boost使用std::chrono，转而使用boost::chrono；第三是本文要介绍的方法，即定制deadline_timer，让它变成稳定的定时器。</p><p>deadline_timer实际上是basic_deadline_timer的特化版本，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_deadline_timer&lt;boost::posix_time::ptime&gt; deadline_timer;</span><br></pre></td></tr></table></figure><p>basic_deadline_timer是一个模板类，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> Time,</span><br><span class="line">    <span class="keyword">typename</span> TimeTraits = boost::asio::time_traits&lt;Time&gt;,</span><br><span class="line">    <span class="keyword">typename</span> TimerService = deadline_timer_service&lt;Time, TimeTraits&gt;&gt;</span><br><span class="line">class basic_deadline_timer : <span class="keyword">public</span> basic_io_object&lt; TimerService &gt;</span><br></pre></td></tr></table></figure><p>从以上定义的模板参数可以看出，basic_deadline_timer提供了灵活的可定制性。这里我们关注的重点是前面两个模板参数，其中第一个参数Time指定时间值的类型，第二个参数TimeTraits指定时间值的特性类，特性类用来对时间值进行各种操作。TimeTraits使用boost::asio::time_traits<time>作为默认值，而boost::asio::time_traits只有一个针对boost::posix_time::ptime（即deadline_timer使用的时间值类型）的特化版本，从这个特化版本的定义可以看到TimeTraits需要提供哪些接口，如下所示：</time></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Time traits specialised for posix_time.</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_traits</span>&lt;boost::posix_time::ptime&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/// The time type.</span></span><br><span class="line">  <span class="keyword">typedef</span> boost::posix_time::ptime time_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The duration type.</span></span><br><span class="line">  <span class="keyword">typedef</span> boost::posix_time::time_duration duration_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the current time.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> time_type <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)</span></span><br><span class="line">    <span class="keyword">return</span> boost::posix_time::microsec_clock::universal_time();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)</span></span></span><br><span class="line">    <span class="keyword">return</span> boost::posix_time::second_clock::universal_time();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Add a duration to a time.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> time_type <span class="title">add</span><span class="params">(<span class="keyword">const</span> time_type&amp; t, <span class="keyword">const</span> duration_type&amp; d)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Subtract one time from another.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> duration_type <span class="title">subtract</span><span class="params">(<span class="keyword">const</span> time_type&amp; t1, <span class="keyword">const</span> time_type&amp; t2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 - t2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Test whether one time is less than another.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">less_than</span><span class="params">(<span class="keyword">const</span> time_type&amp; t1, <span class="keyword">const</span> time_type&amp; t2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 &lt; t2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Convert to POSIX duration type.</span></span><br><span class="line">  <span class="keyword">static</span> boost::posix_time::<span class="function">time_duration <span class="title">to_posix_duration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> duration_type&amp; d)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，TimeTraits需要提供<code>time_type</code>和<code>duration_type</code>两种类型来分别表示一个时间点和一段时间；需要提供<code>now</code>方法来获取当前时间；需要提供<code>add</code>、<code>subtract</code>和<code>less_than</code>方法来计算和比较时间；最后还需要<code>to_posix_duration</code>方法把<code>duration_type</code>类型转换成<code>boost::posix_time::time_duration</code>类型。</p><p>显然，对于定制的basic_deadline_timer，时间值类型Time可以是任意类型，并且它的含义并没有硬性规定，例如，它可以是以毫秒或纳秒为单位的时间，也可以是CPU时钟的周期数，只要提供了正确的TimeTraits特性类把这个定制的时间值转换成boost认识的时间值即可。</p><p>接下来要选择一种与系统时间无关的时间值类型来定制basic_deadline_timer。在Windows平台下，很容易想到可以使用QueryPerformanceCounter和QueryPerformanceFrequency，这两个API提供了高精度的时间度量，与系统时间无关。QueryPerformanceCounter用来查询当前CPU时钟的周期数，是64位整数，这个是理想的时间值类型。要把CPU时钟周期数转换成具体的时间还需要调用QueryPerformanceFrequency查询CPU时钟的频率，即1秒内的CPU时钟周期数，然后通过简单的计算即可得到。</p><p>下面的是使用QueryPerformanceCounter和QueryPerformanceFrequency定制的TimeTraits：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeTraits</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">int64_t</span> time_type;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">duration_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        duration_type() : value(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">        duration_type(<span class="built_in">std</span>::<span class="keyword">int64_t</span> value) : value(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">int64_t</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LARGE_INTEGER frequence_large_integer = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        QueryPerformanceFrequency(&amp;frequence_large_integer);</span><br><span class="line">        frequence = frequence_large_integer.QuadPart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> duration_type <span class="title">GetMinutes</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">int64_t</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> duration_type(minutes * <span class="number">60</span> * frequence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> duration_type <span class="title">GetSeconds</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">int64_t</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> duration_type(seconds * frequence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> duration_type <span class="title">GetMilliseconds</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">int64_t</span> milliseconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> duration_type(milliseconds * (frequence / <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> time_type <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LARGE_INTEGER counter = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        QueryPerformanceCounter(&amp;counter);</span><br><span class="line">        <span class="keyword">return</span> counter.QuadPart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> time_type <span class="title">add</span><span class="params">(time_type time, duration_type duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time + duration.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> duration_type <span class="title">subtract</span><span class="params">(time_type time1, time_type time2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> duration_type(time1 - time2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">less_than</span><span class="params">(time_type time1, time_type time2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time1 &lt; time2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> boost::posix_time::<span class="function">time_duration <span class="title">to_posix_duration</span><span class="params">(duration_type duration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">int64_t</span> microseconds = (duration.value * <span class="number">1000</span> * <span class="number">1000</span>) / frequence;</span><br><span class="line">        <span class="keyword">return</span> boost::posix_time::microseconds(microseconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TimeTraits();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">int64_t</span> frequence;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CPU时钟的频率是固定的，只需要调用QueryPerformanceFrequency查询一次即可，因此这里增加了<code>Initialize</code>方法来初始化CPU时钟频率，要在程序启动后的某个时机来调用该方法进行初始化。要注意的是<code>duration_type</code>不能跟<code>time_type</code>相同，这是TimeTraits的硬性规定，boost内部的代码依赖了这个规定，违反它会导致编译失败。所以要针对<code>duration_type</code>额外定义一个看似冗余的类型。</p><p>另一个值得注意的地方是，上面的定义增加了<code>GetMinutes</code>、<code>GetSeconds</code>和<code>GetMilliseconds</code>方法，这几个方法用来将具体的时间转换成我们定制的时间值，即CPU时钟周期数。这是因为在调用定时器的expires_from_now等方法设置超时值的时候，必须使用TimeTraits的duration_type，提供这几个方法可以方便使用。</p><p>最后，将这个定制的TimeTraits作为basic_deadline_timer的模板参数即可：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> boost::asio::basic_deadline_timer&lt;<span class="built_in">std</span>::<span class="keyword">int64_t</span>, TimeTraits&gt; Timer;</span><br></pre></td></tr></table></figure></p><p>使用方法基本上与dealine_timer一样，如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某个时机初始化TimeTraits</span></span><br><span class="line">TimeTraits::Initialize();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个地方定义io_service</span></span><br><span class="line">boost::asio::io_service io_service;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用定制的Timer</span></span><br><span class="line"><span class="function">Timer <span class="title">timer</span><span class="params">(io_service)</span></span>;</span><br><span class="line">timer.expires_from_now(TimeTraits::GetSecnods(<span class="number">10</span>));</span><br><span class="line">timer.wait();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;boost::asio::deadline_timer使用的计量时间是系统时间，因此修改系统时间会影响deadline_timer的行为。例如，调用了expires_from_now设置1分钟超时后，立刻把系统时间改成一天前，那么要过一天时间才会超时。这个特性可能会影响程序功能的正常使用，因此我们通常想要的是一个不会受系统时间影响的定时器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="boost" scheme="http://zplutor.github.io/tags/boost/"/>
    
      <category term="定时器" scheme="http://zplutor.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>C4250警告产生的原因及解决方法</title>
    <link href="http://zplutor.github.io/2016/02/24/reason-and-solution-for-c4250-warning/"/>
    <id>http://zplutor.github.io/2016/02/24/reason-and-solution-for-c4250-warning/</id>
    <published>2016-02-24T06:20:46.000Z</published>
    <updated>2016-04-16T12:06:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用MSVC编译以下代码会产生C4250警告：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::Print"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"C::Print"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    D d;</span><br><span class="line">    d.Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>警告信息为<code>warning C4250: “D”: 通过域控制继承“C::C::Print”</code>。这样的警告信息并没有什么价值，我们需要自己来分析一下。</p><p>上述代码塑造出了菱形继承关系，如下所示：</p><img src="/2016/02/24/reason-and-solution-for-c4250-warning/1.png"><p>根基类A定义了一个虚方法Print，因此在子类B和C中存在继承而来的Print，其中C重写了该方法。D多重继承于B和C，因此它会同时继承B和C的Print。这时问题来了，当对D的实例调用Print时，它应该调用B::Print还是C::Print呢？这里编译器做出了选择，它调用的是在基类中被重写的版本，也就是C::Print。然而，这很有可能不是我们想要的结果，所以编译器发出警告，提醒我们这里可能存在问题。</p><p>假如B也重写了Print，会怎么样呢？在这种情况下编译会失败，因为两个基类都重写了Print，编译器无法做出选择。</p><p>解决的方法很简单，只要在D中也重写Print即可，这样可以明确地告诉编译器，我们要调用的就是D::Print，从而消除了编译器的疑虑。在实现D::Print的时候，可能需要调用基类版本，这时要根据具体情况来决定调用哪个版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用MSVC编译以下代码会产生C4250警告：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="继承" scheme="http://zplutor.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>boost::thread_specific_ptr在Windows下可能导致内存泄露</title>
    <link href="http://zplutor.github.io/2016/02/23/boost-thread-specific-ptr-may-cause-memory-leak-under-Windows/"/>
    <id>http://zplutor.github.io/2016/02/23/boost-thread-specific-ptr-may-cause-memory-leak-under-Windows/</id>
    <published>2016-02-23T15:31:52.000Z</published>
    <updated>2018-04-08T16:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>boost::thread_specific_ptr用于定义线程局部变量，根据这个类的定义，当一个线程结束的时候，与之相关的变量都会被释放。然而，这个规则并不是在所有情况下都适用。在boost::thread_specific_ptr的文档中有这么一句话：</p><a id="more"></a><blockquote><p>Note: on some platforms, cleanup of thread-specific data is not performed for threads created with the platform’s native API. On those platforms such cleanup is only done for threads that are started with boost::thread unless boost::on_thread_exit() is called manually from that thread.</p></blockquote><p>这里的“some platforms”指的就是Windows（不明白为什么boost不在文档中明确说明，这样可以让Windows程序员少碰壁）。在这个平台下，只有通过boost::thread启动的线程才会在结束的时候释放boost::thread_specific_ptr中的变量，通过其它方式启动的线程则要主动调用boost::on_thread_exit函数才能释放这些变量。所以，如果非boost::thread线程访问了boost::thread_specific_ptr，又没有调用boost::on_thread_exit，就会造成内存泄露。</p><p>避免这个问题的方法就是尽量使用boost::thread启动线程，这是最省事的方法。然而并不是所有情况都能使用boost::thread，这时就要按照文档说的主动去调用boost::on_thread_exit了。这是一个非公开的方法，它的声明位于<code>boost\thread\detail\tss_hooks.hpp</code>。</p><p>最坏的情况是，线程是由第三方库启动的，并且无法修改这个库的源码，或者修改的代价很高。在这种情况下，只能避免让这些线程去访问boost::thread_specific_ptr。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;boost::thread_specific_ptr用于定义线程局部变量，根据这个类的定义，当一个线程结束的时候，与之相关的变量都会被释放。然而，这个规则并不是在所有情况下都适用。在boost::thread_specific_ptr的文档中有这么一句话：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="boost" scheme="http://zplutor.github.io/tags/boost/"/>
    
      <category term="线程" scheme="http://zplutor.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="内存泄露" scheme="http://zplutor.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>创建空std::string的最佳方式</title>
    <link href="http://zplutor.github.io/2016/02/18/best-way-to-create-empty-std-string/"/>
    <id>http://zplutor.github.io/2016/02/18/best-way-to-create-empty-std-string/</id>
    <published>2016-02-18T15:14:10.000Z</published>
    <updated>2018-04-08T16:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>创建一个空的std::string对象有多种方式，常见的有以下两种：</p><a id="more"></a><p>第一种是直接使用std::string的默认构造函数，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建变量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从函数返回</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetEmptyString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是由空的C字符串字面量转换，不论是显式的还是隐式的转换，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建变量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">string1</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> string2 = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从函数返回</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetEmptyString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方式的结果都是一样的，但是过程却有一点不同。第一种方式直截了当地创建一个空std::string对象，没有多余的操作；而第二种方式则多了一个转换过程——它要通过strlen之类的函数计算出字符串的长度。即便是空字符串，这个转换过程也会造成一些开销。所以，从理论上来说，第二种方式的性能会比较差。具体差了多少呢？可以使用以下代码进行测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> Count = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> os;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">clock_t</span> begin_time = clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; Count; ++count) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">        os &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">clock_t</span> end_time = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">double</span>(end_time - begin_time) / CLOCKS_PER_SEC &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    begin_time = clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; Count; ++count) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">        os &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end_time = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">double</span>(end_time - begin_time) / CLOCKS_PER_SEC &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; os.str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别用两种方式创建std::string对象一亿次，输出两者的耗时。每次创建字符串之后，都会把它输出到一个std::ostringstream对象中，这是为了避免在release模式下编译器把无实际作用的for循环优化掉。以下是在XCode中运行的输出结果：</p><pre><code>1.477661.97115</code></pre><p>可见，第二种方式确实会比第一种方式慢，不过差距十分微小：在创建一亿个std::string对象的级别下才慢了0.5秒，几乎可以忽略不计。尽管如此，对于追求效率的程序员来说，显然第一种方式更胜一筹。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建一个空的std::string对象有多种方式，常见的有以下两种：&lt;/p&gt;
    
    </summary>
    
    
      <category term="性能" scheme="http://zplutor.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
      <category term="字符串" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>使用内核对象实现单例程序</title>
    <link href="http://zplutor.github.io/2016/02/04/implement-singleton-application-with-kernal-object/"/>
    <id>http://zplutor.github.io/2016/02/04/implement-singleton-application-with-kernal-object/</id>
    <published>2016-02-04T13:51:05.000Z</published>
    <updated>2016-04-16T12:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于有些程序来说，运行多个实例没有意义，甚至会出现异常，所以有必要把程序实现成单例。有多种方法可以做到这一点，比较好的方法是使用内核对象。</p><a id="more"></a><p>内核对象是指存在于系统内核中的对象，而不仅仅存在于程序内部，这样多个程序实例之间就可以共享这些对象了。使用内核对象的思路很简单：程序启动之后检查一下是否存在特定的内核对象，如果不存在，说明这是第一个实例，可以正常运行；如果已存在，说明已经有实例在运行了，当前的实例要退出。内核对象在这里只是作为一个标识，标识是否有实例正在运行，至于它是哪一种内核对象则不重要。习惯上会使用Mutex内核对象，主要是因为它的名称与这里的用途相吻合，而且它的用法也很简单。</p><p>内核对象有具名和匿名之分。具名的内核对象与一个字符串关联，通过这个字符串可以找到对应的内核对象；匿名的内核对象则不具备这个特点。显然这里应该使用具名内核对象。</p><p>可以在程序的入口点来检查内核对象。下面是检查Mutex内核对象的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HANDLE mutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="string">L"SingletonApplication"</span>);</span><br><span class="line"><span class="keyword">if</span> ( (mutex == <span class="literal">NULL</span>) || (GetLastError() == ERROR_ALREADY_EXISTS) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常启动程序</span></span><br></pre></td></tr></table></figure><p>CreateMutex同时提供了创建和打开Mutex内核对象的功能。第三个参数指明了内核对象的名称，如果名为<code>SingletonApplication</code>的Mutex内核对象不存在，那么CreateMutex会创建一个新的对象，并返回它的句柄；如果已经存在这个内核对象，那么CreateMutex会打开它，并返回它的句柄，同时GetLastError会返回<code>ERROR_ALREADY_EXISTS</code>。在实际的应用中，应该把<code>SingletonApplication</code>替换成尽量不会与其它程序冲突的名称。</p><p>CreateMutex的第一个和第二个参数在这里的使用场景中并不重要，分别传入NULL和FALSE即可。CreateMutex如果失败会返回NULL，这种情况几乎不会发生，但基于完整性考虑这里还是要判断一下返回值是否为NULL。</p><p>在程序的实例退出之前，理论上来说是需要调用CloseHandle把内核对象关闭的。但实即使不这么做也不会有问题，因为进程结束的时候操作系统会把这个进程所有的资源回收，该内核对象自然会被关闭。</p><p>最后要注意的是，使用内核对象来实现单例程序是有风险的。因为内核对象全局可见，其它程序也能访问。例如WinObj工具可以查看系统中所有内核对象以及它们的名称。恶意程序完全可以抢先创建内核对象来阻止特定程序运行。所以如果安全性很重要的话，就要考虑更加安全的方式来实现单例程序了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于有些程序来说，运行多个实例没有意义，甚至会出现异常，所以有必要把程序实现成单例。有多种方法可以做到这一点，比较好的方法是使用内核对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="单例" scheme="http://zplutor.github.io/tags/%E5%8D%95%E4%BE%8B/"/>
    
      <category term="内核对象" scheme="http://zplutor.github.io/tags/%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>为什么std::tolower不能用于std::transform</title>
    <link href="http://zplutor.github.io/2016/01/02/why-can-t-std-tolower-be-used-with-std-transform/"/>
    <id>http://zplutor.github.io/2016/01/02/why-can-t-std-tolower-be-used-with-std-transform/</id>
    <published>2016-01-02T04:13:36.000Z</published>
    <updated>2018-04-08T16:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中，std::tolower和std::toupper函数（在本文中都用std::tolower指代两者）用于对一个字符进行大小写转换，将其与std::transform函数结合则可以对整个字符串进行大小写转换，如下所示：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">string</span> = <span class="string">"ABCDEF"</span>;</span><br><span class="line"><span class="built_in">std</span>::transform(</span><br><span class="line">    <span class="built_in">string</span>.begin(), </span><br><span class="line">    <span class="built_in">string</span>.end(), </span><br><span class="line">    <span class="built_in">string</span>.begin(), </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">tolower</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>以上代码在Visual C++下能编译成功，但是在XCode下却编译失败，错误信息为<code>No matching function for call to &#39;transform&#39;</code>。这是因为std::tolower函数存在两个重载，第一个定义于头文件cctype，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><p>第二个定义于头文件locale，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">charT</span> <span class="title">tolower</span>(<span class="title">charT</span> <span class="title">ch</span>, <span class="title">const</span> <span class="title">locale</span>&amp; <span class="title">loc</span>);</span></span><br></pre></td></tr></table></figure><p>cctype和locale都是很基础的模块，会被其它头文件引用，因此这两个重载通常都会同时出现。XCode的编译器由于不知道该选择哪个重载而报错。</p><p>然而，从理论上来说，编译器是可以知道如何选择的。std::transform在XCode中的源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIterator</span>, <span class="title">class</span> _<span class="title">OutputIterator</span>, <span class="title">class</span> _<span class="title">UnaryOperation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">_<span class="title">OutputIterator</span></span></span><br><span class="line"><span class="class"><span class="title">transform</span>(_<span class="title">InputIterator</span> __<span class="title">first</span>, _<span class="title">InputIterator</span> __<span class="title">last</span>, _<span class="title">OutputIterator</span> __<span class="title">result</span>, _<span class="title">UnaryOperation</span> __<span class="title">op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; __first != __last; ++__first, (<span class="keyword">void</span>) ++__result)</span><br><span class="line">        *__result = __op(*__first);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第七行，可以看到调用<code>__op</code>的时候只传了一个参数，因此无论如何只能选择std::tolower的第一个重载，编译器完全有能力做出这个推导。如果把上述std::transform的源码转移到Visual C++并且以同样的方式来调用，可以编译成功，可见这个推导是可行的。那为什么XCode的编译器没有这么做呢？一个可能的原因是效率问题，类型推导越精确会耗费越多编译时间。从这一点或许可以解释为什么Visual C++的编译速度这么慢。</p><p>那么，应该如何解决这个问题呢？有两种方法，第一种方法是把std::tolower换成::tolower，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(</span><br><span class="line">    <span class="built_in">string</span>.begin(), </span><br><span class="line">    <span class="built_in">string</span>.end(), </span><br><span class="line">    <span class="built_in">string</span>.begin(), </span><br><span class="line">    ::<span class="built_in">tolower</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>默认情况下，在全局名称空间中，tolower只有一种声明形式，因此没有问题。但前提是没有使用<code>using namespace</code>语句把std名称空间的内容导入全局名称空间——然而这种用法很常见，因此使用::tolower并不一定有效。</p><p>第二种方法是显式指定使用std::tolower的第一个重载，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(</span><br><span class="line">    <span class="built_in">string</span>.begin(), </span><br><span class="line">    <span class="built_in">string</span>.end(), </span><br><span class="line">    <span class="built_in">string</span>.begin(), </span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>)&gt;(<span class="built_in">std</span>::<span class="built_in">tolower</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这种做法带来了编码负担，因为每次使用的时候都要回忆一下std::tolower的声明形式，并且要输入更多字符。所以最好用一个函数把它封装起来，一劳永逸。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C++中，std::tolower和std::toupper函数（在本文中都用std::tolower指代两者）用于对一个字符进行大小写转换，将其与std::transform函数结合则可以对整个字符串进行大小写转换，如下所示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
      <category term="字符串" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>实现一个可编辑的Windowless RichEdit</title>
    <link href="http://zplutor.github.io/2015/12/06/implement-an-editable-windowless-richedit/"/>
    <id>http://zplutor.github.io/2015/12/06/implement-an-editable-windowless-richedit/</id>
    <published>2015-12-06T13:16:04.000Z</published>
    <updated>2016-04-16T12:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文在《创建一个最简单的Windowless RichEdit》一文的基础上，介绍如何让Windowless RichEdit支持编辑功能。</p><a id="more"></a><h2 id="激活并设置焦点"><a href="#激活并设置焦点" class="headerlink" title="激活并设置焦点"></a>激活并设置焦点</h2><p>Windowless RichEdit需要同时处于两种状态下才能够编辑：一是活动状态，二是有输入焦点状态。</p><p>默认情况下Windowless RichEdit是处于不活动状态的，使用ITextServices的OnTxInPlaceActivate方法即可切换到活动状态。该方法接受一个类型为<code>const RECT*</code>的参数，表示Windowless RichEdit的客户区域，一般情况下传入nullptr即可，因为Windowless RichEdit总是会调用ITextHost的TxGetClientRect方法取得这个区域。也就是说我们还要实现TxGetClientRect：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetClientRect</span><span class="params">(LPRECT prc)</span> override </span>&#123;</span><br><span class="line">    GetClientRect(hwnd_, prc);</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，默认情况下Windowless RichEdit处于无输入焦点状态，需要使用ITextServices的TxSendMessage方法向它发送一个WM_SETFOCUS消息来切换到有输入焦点状态。所有能通过消息完成的操作都使用TxSendMessage方法，这样可以使Windowless RichEdit与Windows的消息处理更好地融合，也避免在ITextServices接口中暴露过多方法。</p><p>这两种状态可以在父窗口的WM_SETFOCUS消息中同时设置，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS: &#123;</span><br><span class="line"></span><br><span class="line">    g_text_service-&gt;OnTxInPlaceActivate(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    LRESULT result = <span class="number">0</span>;</span><br><span class="line">    g_text_service-&gt;TxSendMessage(message, wParam, lParam, &amp;result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应地，使用ITextServices的OnTxInPlaceDeactivate方法可以切换回不活动状态；使用TxSendMessage发送WM_KILLFOCUS消息可以切换回无焦点状态。可以在父窗口的WM_KILLFOCUS消息中同时设置，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KILLFOCUS: &#123;</span><br><span class="line"></span><br><span class="line">    g_text_service-&gt;OnTxInPlaceDeactivate();</span><br><span class="line">    </span><br><span class="line">    LRESULT result = <span class="number">0</span>;</span><br><span class="line">    g_text_service-&gt;TxSendMessage(message, wParam, lParam, &amp;result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示输入光标"><a href="#显示输入光标" class="headerlink" title="显示输入光标"></a>显示输入光标</h2><p>Windowless RichEdit不负责显示输入光标，它会调用ITextHost的一系列方法进行回调，由实现者来负责显示。下列方法是与输入光标相关的：</p><ul><li>TxGetDC</li><li>TxReleaseDC</li><li>TxCreateCaret</li><li>TxShowCaret</li><li>TxSetCaretPos</li></ul><p>一般情况下，实现这几个方法很简单，只要调用相应的API即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">TxGetDC</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GetDC(hwnd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INT <span class="title">TxReleaseDC</span><span class="params">(HDC hdc)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ReleaseDC(hwnd_, hdc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TxCreateCaret</span><span class="params">(HBITMAP hbmp, INT xWidth, INT yHeight)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CreateCaret(hwnd_, hbmp, xWidth, yHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TxShowCaret</span><span class="params">(BOOL fShow)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fShow) &#123;</span><br><span class="line">        <span class="keyword">return</span> ShowCaret(hwnd_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HideCaret(hwnd_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TxSetCaretPos</span><span class="params">(INT x, INT y)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SetCaretPos(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TxGetDC和TxReleaseDC看起来似乎与后面三个方法无关，但却是必须实现的。如果TxGetDC返回了无效的HDC，那么后面三个方法就不会被调用。</p><h2 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h2><p>往Windowless RichEdit中输入字符很简单，只要让它处理下列键盘消息即可：</p><ul><li>WM_KEYDOWN</li><li>WM_KEYUP</li><li>WM_CHAR</li></ul><p>这同样是使用TxSendMessage方法完成，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line"><span class="keyword">case</span> WM_KEYUP:</span><br><span class="line"><span class="keyword">case</span> WM_CHAR: &#123;</span><br><span class="line"></span><br><span class="line">    LRESULT result = <span class="number">0</span>;</span><br><span class="line">    g_text_service-&gt;TxSendMessage(message, wParam, lParam, &amp;result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，Windowless RichEdit还需要重绘以显示输入的字符，它会调用ITextHost的TxInvalidateRect方法。该方法的实现也非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TxInvalidateRect</span><span class="params">(LPCRECT prc, BOOL fMode)</span> override </span>&#123;</span><br><span class="line">    InvalidateRect(hwnd_, prc, fMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鼠标相关"><a href="#鼠标相关" class="headerlink" title="鼠标相关"></a>鼠标相关</h2><p>鼠标在进行文字编辑时也有重要的作用。例如，当鼠标移动到可编辑的文本框上时，指针会变成<code>I</code>形状，此时点击鼠标可以修改输入光标的位置；拖拽鼠标可以选择一段文字。下面是实现这些功能的方法。</p><p>鼠标指针的改变需要调用ITextServices的OnTxSetCursor来触发，理想的调用点是在处理WM_SETCURSOR消息的时候，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETCURSOR: &#123;</span><br><span class="line"></span><br><span class="line">    HDC hdc = GetDC(hwnd);</span><br><span class="line">    </span><br><span class="line">    POINT position = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    GetCursorPos(&amp;position);</span><br><span class="line">    ScreenToClient(hwnd, &amp;position);</span><br><span class="line">    </span><br><span class="line">    RECT rect = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    GetClientRect(hwnd, &amp;rect);</span><br><span class="line">    </span><br><span class="line">    g_text_service-&gt;OnTxSetCursor(</span><br><span class="line">    DVASPECT_CONTENT, </span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">nullptr</span>, </span><br><span class="line">    <span class="literal">nullptr</span>, </span><br><span class="line">    hdc, </span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    &amp;rect, </span><br><span class="line">    position.x, </span><br><span class="line">    position.y</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    ReleaseDC(hwnd, hdc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意不能直接用TxSendMessage发送WM_SETCURSOR消息，这样做并不能得到想要的效果。</p><p>然后Windowless RichEdit会调用ITextHost的TxSetCursor来设置鼠标指针，只要在该方法中调用SetCursor即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TxSetCursor</span><span class="params">(HCURSOR hcur, BOOL fText)</span> override </span>&#123;</span><br><span class="line">    SetCursor(hcur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，要让Windowless RichEdit处理下列鼠标消息：</p><ul><li>WM_MOUSEMOVE</li><li>WM_LBUTTONDOWN</li><li>WM_LBUTTONUP</li></ul><p>同样是使用TxSendMessage完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONUP: &#123;</span><br><span class="line"></span><br><span class="line">    LRESULT result = <span class="number">0</span>;</span><br><span class="line">    g_text_service-&gt;TxSendMessage(message, wParam, lParam, &amp;result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Windowless RichEdit会在需要的时候调用ITextHost的TxSetCapture来捕获或释放鼠标。该方法的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TxSetCapture</span><span class="params">(BOOL fCapture)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fCapture) &#123;</span><br><span class="line">        SetCapture(hwnd_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ReleaseCapture();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>在本文的最后，附上完整的示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlbase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Richedit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TextServ.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextHost</span> :</span> <span class="keyword">public</span> ITextHost &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TextHost(HWND hwnd) : hwnd_(hwnd) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    HRESULT __<span class="function">stdcall <span class="title">QueryInterface</span><span class="params">(REFIID riid, <span class="keyword">void</span>** ppvObject)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ppvObject == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> E_POINTER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((riid == IID_IUnknown) || (riid == IID_ITextHost)) &#123;</span><br><span class="line">            *ppvObject = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> S_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppvObject = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> E_NOINTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG __<span class="function">stdcall <span class="title">AddRef</span><span class="params">(<span class="keyword">void</span>)</span> override </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    ULONG __<span class="function">stdcall <span class="title">Release</span><span class="params">(<span class="keyword">void</span>)</span> override </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HDC <span class="title">TxGetDC</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GetDC(hwnd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">INT <span class="title">TxReleaseDC</span><span class="params">(HDC hdc)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReleaseDC(hwnd_, hdc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowScrollBar</span><span class="params">(INT fnBar, BOOL fShow)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxEnableScrollBar</span><span class="params">(INT fuSBFlags, INT fuArrowflags)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollRange</span><span class="params">(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollPos</span><span class="params">(INT fnBar, INT nPos, BOOL fRedraw)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxInvalidateRect</span><span class="params">(LPCRECT prc, BOOL fMode)</span> override </span>&#123;</span><br><span class="line">        InvalidateRect(hwnd_, prc, fMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxViewChange</span><span class="params">(BOOL fUpdate)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxCreateCaret</span><span class="params">(HBITMAP hbmp, INT xWidth, INT yHeight)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CreateCaret(hwnd_, hbmp, xWidth, yHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowCaret</span><span class="params">(BOOL fShow)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fShow) &#123;</span><br><span class="line">            <span class="keyword">return</span> ShowCaret(hwnd_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> HideCaret(hwnd_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetCaretPos</span><span class="params">(INT x, INT y)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SetCaretPos(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetTimer</span><span class="params">(UINT idTimer, UINT uTimeout)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxKillTimer</span><span class="params">(UINT idTimer)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxScrollWindowEx</span><span class="params">(INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxSetCapture</span><span class="params">(BOOL fCapture)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fCapture) &#123;</span><br><span class="line">            SetCapture(hwnd_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ReleaseCapture();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxSetFocus</span><span class="params">()</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxSetCursor</span><span class="params">(HCURSOR hcur, BOOL fText)</span> override </span>&#123;</span><br><span class="line">        SetCursor(hcur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxScreenToClient</span><span class="params">(LPPOINT lppt)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxClientToScreen</span><span class="params">(LPPOINT lppt)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxActivate</span><span class="params">(LONG * plOldState)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxDeactivate</span><span class="params">(LONG lNewState)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetClientRect</span><span class="params">(LPRECT prc)</span> override </span>&#123;</span><br><span class="line">        GetClientRect(hwnd_, prc);</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetViewInset</span><span class="params">(LPRECT prc)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetCharFormat</span><span class="params">(<span class="keyword">const</span> CHARFORMATW **ppCF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (char_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            char_format_ = <span class="built_in">std</span>::make_unique&lt;CHARFORMATW&gt;();</span><br><span class="line">            char_format_-&gt;cbSize = <span class="keyword">sizeof</span>(CHARFORMATW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppCF = char_format_.get();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetParaFormat</span><span class="params">(<span class="keyword">const</span> PARAFORMAT **ppPF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (para_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            para_format_ = <span class="built_in">std</span>::make_unique&lt;PARAFORMAT&gt;();</span><br><span class="line">            para_format_-&gt;cbSize = <span class="keyword">sizeof</span> PARAFORMAT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppPF = para_format_.get();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">COLORREF <span class="title">TxGetSysColor</span><span class="params">(<span class="keyword">int</span> nIndex)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GetSysColor(nIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetBackStyle</span><span class="params">(TXTBACKSTYLE *pstyle)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetMaxLength</span><span class="params">(DWORD *plength)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetScrollBars</span><span class="params">(DWORD *pdwScrollBar)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPasswordChar</span><span class="params">(_Out_ TCHAR *pch)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetAcceleratorPos</span><span class="params">(LONG *pcp)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetExtent</span><span class="params">(LPSIZEL lpExtent)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxCharFormatChange</span><span class="params">(<span class="keyword">const</span> CHARFORMATW * pCF)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxParaFormatChange</span><span class="params">(<span class="keyword">const</span> PARAFORMAT * pPF)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPropertyBits</span><span class="params">(DWORD dwMask, DWORD *pdwBits)</span> override </span>&#123;</span><br><span class="line">        *pdwBits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxNotify</span><span class="params">(DWORD iNotify, <span class="keyword">void</span> *pv)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HIMC <span class="title">TxImmGetContext</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxImmReleaseContext</span><span class="params">(HIMC himc)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetSelectionBarWidth</span><span class="params">(LONG *lSelBarWidth)</span> override </span>&#123;</span><br><span class="line">        *lSelBarWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HWND hwnd_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CHARFORMATW&gt; char_format_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PARAFORMAT&gt; para_format_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="keyword">const</span> IID IID_ITextServices = &#123;</span><br><span class="line">    <span class="number">0x8d33f740</span>,</span><br><span class="line">    <span class="number">0xcf58</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9d</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="keyword">const</span> IID IID_ITextHost = &#123;</span><br><span class="line">    <span class="number">0xc5bdd8d0</span>,</span><br><span class="line">    <span class="number">0xd26e</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9e</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TextHost&gt; g_text_host;</span><br><span class="line">CComPtr&lt;ITextServices&gt; g_text_service;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="keyword">char</span>*, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WNDCLASSEX default_class = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    default_class.cbSize = <span class="keyword">sizeof</span>(default_class);</span><br><span class="line">    default_class.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    default_class.lpfnWndProc = WindowProcedure;</span><br><span class="line">    default_class.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    default_class.cbWndExtra = <span class="keyword">sizeof</span>(LONG_PTR);</span><br><span class="line">    default_class.hInstance = <span class="literal">NULL</span>;</span><br><span class="line">    default_class.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">    default_class.hCursor = LoadCursor(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    default_class.hbrBackground = <span class="keyword">reinterpret_cast</span>&lt;HBRUSH&gt;(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">    default_class.lpszMenuName = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.lpszClassName = <span class="string">L"WindowlessRichEdit"</span>;</span><br><span class="line">    default_class.hIconSm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    RegisterClassEx(&amp;default_class);</span><br><span class="line"></span><br><span class="line">    HWND window_handle = CreateWindowEx(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="string">L"WindowlessRichEdit"</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        WS_OVERLAPPEDWINDOW | WS_VISIBLE,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE: &#123;</span><br><span class="line"></span><br><span class="line">        g_text_host = <span class="built_in">std</span>::make_shared&lt;TextHost&gt;(hwnd);</span><br><span class="line"></span><br><span class="line">        HMODULE module_handle = LoadLibrary(<span class="string">L"riched20.dll"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(_stdcall*CreateTextServicesFunction)</span><span class="params">(IUnknown*, ITextHost*, IUnknown**)</span></span>;</span><br><span class="line">        CreateTextServicesFunction create_function = <span class="keyword">reinterpret_cast</span>&lt;CreateTextServicesFunction&gt;(GetProcAddress(module_handle, <span class="string">"CreateTextServices"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> IID* iid_text_service = <span class="keyword">reinterpret_cast</span>&lt;IID*&gt;(GetProcAddress(module_handle, <span class="string">"IID_ITextServices"</span>));</span><br><span class="line"></span><br><span class="line">        CComPtr&lt;IUnknown&gt; unknown;</span><br><span class="line">        create_function(<span class="literal">nullptr</span>, g_text_host.get(), &amp;unknown);</span><br><span class="line">        unknown-&gt;QueryInterface(*iid_text_service, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;g_text_service));</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;TxSetText(<span class="string">L"Windowless RichEdit"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_PAINT: &#123;</span><br><span class="line"></span><br><span class="line">        PAINTSTRUCT paint_struct;</span><br><span class="line">        HDC hdc = BeginPaint(hwnd, &amp;paint_struct);</span><br><span class="line"></span><br><span class="line">        RECT rect;</span><br><span class="line">        GetClientRect(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;TxDraw(</span><br><span class="line">            DVASPECT_CONTENT,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            hdc,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;LPCRECTL&gt;(&amp;rect),</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        EndPaint(hwnd, &amp;paint_struct);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_SETFOCUS: &#123;</span><br><span class="line">    </span><br><span class="line">        g_text_service-&gt;OnTxInPlaceActivate(<span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line">        LRESULT result = <span class="number">0</span>;</span><br><span class="line">        g_text_service-&gt;TxSendMessage(message, wParam, lParam, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_KILLFOCUS: &#123;</span><br><span class="line">    </span><br><span class="line">        g_text_service-&gt;OnTxInPlaceDeactivate();</span><br><span class="line">        </span><br><span class="line">        LRESULT result = <span class="number">0</span>;</span><br><span class="line">        g_text_service-&gt;TxSendMessage(message, wParam, lParam, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">    <span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">    <span class="keyword">case</span> WM_CHAR:&#123;</span><br><span class="line">    </span><br><span class="line">        LRESULT result = <span class="number">0</span>;</span><br><span class="line">        g_text_service-&gt;TxSendMessage(message, wParam, lParam, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_SETCURSOR: &#123;</span><br><span class="line">    </span><br><span class="line">        HDC hdc = GetDC(hwnd);</span><br><span class="line">        </span><br><span class="line">        POINT position = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        GetCursorPos(&amp;position);</span><br><span class="line">        ScreenToClient(hwnd, &amp;position);</span><br><span class="line">        </span><br><span class="line">        RECT rect = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        GetClientRect(hwnd, &amp;rect);</span><br><span class="line">        </span><br><span class="line">        g_text_service-&gt;OnTxSetCursor(</span><br><span class="line">            DVASPECT_CONTENT, </span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="literal">nullptr</span>, </span><br><span class="line">            <span class="literal">nullptr</span>, </span><br><span class="line">            hdc, </span><br><span class="line">            <span class="literal">nullptr</span>, </span><br><span class="line">            &amp;rect, </span><br><span class="line">            position.x, </span><br><span class="line">            position.y</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        ReleaseDC(hwnd, hdc);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONUP: &#123;</span><br><span class="line">    </span><br><span class="line">        LRESULT result = <span class="number">0</span>;</span><br><span class="line">        g_text_service-&gt;TxSendMessage(message, wParam, lParam, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> CallWindowProc(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文在《创建一个最简单的Windowless RichEdit》一文的基础上，介绍如何让Windowless RichEdit支持编辑功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="Windowless RichEdit" scheme="http://zplutor.github.io/tags/Windowless-RichEdit/"/>
    
      <category term="RichEdit" scheme="http://zplutor.github.io/tags/RichEdit/"/>
    
      <category term="ITextHost" scheme="http://zplutor.github.io/tags/ITextHost/"/>
    
      <category term="ITextService" scheme="http://zplutor.github.io/tags/ITextService/"/>
    
      <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
  </entry>
  
  <entry>
    <title>KeyWindow 0.1.2</title>
    <link href="http://zplutor.github.io/2015/11/28/keywindow-0-1-2/"/>
    <id>http://zplutor.github.io/2015/11/28/keywindow-0-1-2/</id>
    <published>2015-11-28T05:20:30.000Z</published>
    <updated>2017-04-02T06:47:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>KeyWindow是一个通过快捷键快速调整窗口布局的工具。</p><a id="more"></a><p>OS X的窗口管理是个麻烦的事情。当需要同时使用多个窗口的时候，我们希望能够在同一个屏幕上平铺这些窗口。例如，把浏览器窗口充满屏幕左半边，把文本编辑器窗口充满屏幕右半边。为了达到这个目的，必须拖动这些窗口并且调整它们的大小，效率很低下。虽然OS X 10.11新增了SplitView功能，但它仍然需要拖动窗口，不够快捷。</p><p>那么，最快捷的方式是什么呢？当然是通过键盘快捷键。OS X不支持通过快捷键改变窗口的布局，但是KeyWindow带来了这个功能。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在KeyWindow中配置窗口的布局以及对应的快捷键。</p><img src="/2015/11/28/keywindow-0-1-2/1.jpg"><p>通过快捷键调整窗口布局。</p><img src="/2015/11/28/keywindow-0-1-2/2.jpg"><h2 id="程序信息"><a href="#程序信息" class="headerlink" title="程序信息"></a>程序信息</h2><ul><li>系统要求：OS X 10.10及以上。</li><li>支持语言：简体中文；英文。</li><li>下载地址：<a href="https://github.com/Zplutor/KeyWindow/releases/download/v0.1.2/KeyWindow.0.1.2.dmg" target="_blank" rel="noopener">https://github.com/Zplutor/KeyWindow/releases/download/v0.1.2/KeyWindow.0.1.2.dmg</a></li><li>项目地址：<a href="https://github.com/Zplutor/KeyWindow" target="_blank" rel="noopener">https://github.com/Zplutor/KeyWindow</a></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>KeyWindow是一个开源项目，如果你也喜欢这个小工具，欢迎来为它添砖加瓦。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;KeyWindow是一个通过快捷键快速调整窗口布局的工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="KeyWindow" scheme="http://zplutor.github.io/tags/KeyWindow/"/>
    
      <category term="macOS" scheme="http://zplutor.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>RAND_poll函数在Windows下存在的问题</title>
    <link href="http://zplutor.github.io/2015/11/25/RAND-poll-function-s-issues-on-Windows/"/>
    <id>http://zplutor.github.io/2015/11/25/RAND-poll-function-s-issues-on-Windows/</id>
    <published>2015-11-24T16:26:09.000Z</published>
    <updated>2015-11-24T16:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>RAND_poll函数是OpenSSL中用于初始化伪随机数生成器的函数，当首次调用诸如RAND_bytes等需要生成随机数的函数时，会先调用该函数进行初始化。在实际使用中发现，RAND_poll函数在Windows下存在一些问题，需要小心提放，否则可能会对程序造成不良影响。</p><a id="more"></a><h2 id="慢"><a href="#慢" class="headerlink" title="慢"></a>慢</h2><p>RAND_poll的第一个问题是慢。早在2009年就有人反映这个问题，说这个函数居然要耗费超过一分钟的时间。要明白为什么RAND_poll这么慢，就要了解它的实现原理。为了保证伪随机数的不可预见性，需要用尽可能多的随机信息去初始化生成器，因此RAND_poll尝试收集程序运行时的各种环境信息。其中包括当前进程的内存信息，这是通过枚举每一个堆中已分配的前80个内存块来得到的。即使对于单个堆的数量有限制，总的枚举的次数仍然可能很多，况且用于枚举的API本身性能并不好，导致整体上耗费了大量时间。</p><p>这个问题在2009年之后的OpenSSL版本中得到了缓解。之所以说“缓解”，是因为RAND_poll的算法并没有改变，它仍然要枚举每个堆的内存块，只不过在枚举的过程中加上了时间检测，如果发现已经超过一秒就不再继续枚举了。因此，该函数最多耗时一秒多一点，这个时间对于某些场景来说仍然是比较慢的。</p><p>关于这个问题的讨论，可以参考 <a href="https://rt.openssl.org/Ticket/Display.html?id=2100&amp;user=guest&amp;pass=guest" target="_blank" rel="noopener">https://rt.openssl.org/Ticket/Display.html?id=2100&amp;user=guest&amp;pass=guest</a> 。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>RAND_poll的第二个问题是它有一定几率导致死锁。原因还是在于枚举堆内存块——用于枚举的API会把进程所有的堆逐个加锁，在这个过程中，假如有其它线程也在操作堆，那么很有可能导致死锁。</p><p>按道理来说，死锁这么严重的问题应该尽早解决，然而奇怪的是，这个问题一直留存至今。综合网上的各种讨论来看，原因或许是这样的：OpenSSL认为这是Windows的问题，一个公开的系统API绝不应该导致程序死锁；而微软则声称这个API仅用于调试目的，不应该在正常的场合下使用。双方都认为这是对方的责任，因此谁都不愿意去修改。</p><p>关于这个问题的分析，可以参考 <a href="http://0cch.com/debugging/2015/09/08/foxmail-hung.html" target="_blank" rel="noopener">http://0cch.com/debugging/2015/09/08/foxmail-hung.html</a> 。</p><h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><p>综上所述，RAND_poll的两个问题对程序的性能和稳定性都有影响。那么应该如何避免呢？很简单，只需要在程序入口点调用一下RAND_bytes，让它初始化伪随机数生成器即可。之所以在这个时间点来初始化，一是因为这时候堆的数量以及分配的内存块还很少，不会耗费太多时间去枚举；二是因为这时候只有一个主线程，不会有其它线程来同时操作堆，也就不会出现死锁。测试结果显示，在这个时间点调用RAND_poll只用了不到100毫秒的时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RAND_poll函数是OpenSSL中用于初始化伪随机数生成器的函数，当首次调用诸如RAND_bytes等需要生成随机数的函数时，会先调用该函数进行初始化。在实际使用中发现，RAND_poll函数在Windows下存在一些问题，需要小心提放，否则可能会对程序造成不良影响。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RAND_poll" scheme="http://zplutor.github.io/tags/RAND-poll/"/>
    
      <category term="RAND_bytes" scheme="http://zplutor.github.io/tags/RAND-bytes/"/>
    
      <category term="OpenSSL" scheme="http://zplutor.github.io/tags/OpenSSL/"/>
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="性能" scheme="http://zplutor.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="死锁" scheme="http://zplutor.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>创建一个最简单的Windowless RichEdit</title>
    <link href="http://zplutor.github.io/2015/11/22/create-a-simplest-windowless-richedit/"/>
    <id>http://zplutor.github.io/2015/11/22/create-a-simplest-windowless-richedit/</id>
    <published>2015-11-22T13:39:58.000Z</published>
    <updated>2016-04-16T12:18:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>RichEdit是Windows上很常用的富文本控件，它有一个无窗口化的版本，即Windowless RichEdit，关于它的介绍，可以参考官方文档：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx</a> 。Windowless RichEdit与普通RichEdit在行为表现上毫无二致，但是在使用方法上却有较大的差异；而且Windowless RichEdit的官方文档少之又少，说明不够全面，甚至连一个完整的示例也没有；更甚者，在不同的Windows平台和开发环境下，Windowless RichEdit的用法都有差异。这让初次接触Windowless RichEdit的人举步维艰，处处碰壁，正应了“万事开头难”这句话。因此，本文聚焦于“开头”，介绍一下创建一个最简单的Windowless RichEdit需要做哪些事情。</p><a id="more"></a><h2 id="Windowless-RichEdit的接口"><a href="#Windowless-RichEdit的接口" class="headerlink" title="Windowless RichEdit的接口"></a>Windowless RichEdit的接口</h2><p>Windowless RichEdit是一个COM组件，使用者需要用到两个接口，分别是ITexService和ITextHost。ITextService表示Windowless RichEdit控件本身，提供了一系列访问该控件的方法。ITextHost是一个回调接口，需要由使用者实现，并传递给ITextService，当ITextService有需要的时候会调用该接口的方法。</p><h2 id="实现ITextHost"><a href="#实现ITextHost" class="headerlink" title="实现ITextHost"></a>实现ITextHost</h2><p>在创建ITextService的时候需要传递一个ITextHost对象给它，所以首先要做的是实现ITextHost。ITextHost定义于TextServ.h，它包含了一系列回调方法，其中下面几个是必须要实现的：</p><ul><li>TxGetPropertyBits</li><li>TxGetCharFormat</li><li>TxGetParaFormat</li><li>TxGetSysColor</li><li>TxGetSelectionBarWidth</li></ul><p>TxGetPropertyBits用于获取Windowless RichEdit的各种属性，例如是否支持多行，是否支持富文本等。最简单的实现方式是使用默认属性，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetPropertyBits</span><span class="params">(DWORD dwMask, DWORD* pdwBits)</span> override </span>&#123;</span><br><span class="line">    *pdwBits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该方法的返回值不是S_OK，在创建ITextService的时候会失败。</p><p>TxGetCharFormat和TxGetParaFormat分别用于获取默认的字符格式和段落格式。字符格式包括字体、大小、颜色、加粗、倾斜等属性；段落格式包括对齐方式等属性。最简单的实现方式是使用默认的格式，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetCharFormat</span><span class="params">(<span class="keyword">const</span> CHARFORMATW** ppCF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (char_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        char_format_ = <span class="built_in">std</span>::make_unique&lt;CHARFORMATW&gt;();</span><br><span class="line">        char_format_-&gt;cbSize = <span class="keyword">sizeof</span>(CHARFORMATW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ppCF = char_format_.get();</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetParaFormat</span><span class="params">(<span class="keyword">const</span> PARAFORMAT** ppPF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (para_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        para_format_ = <span class="built_in">std</span>::make_unique&lt;PARAFORMAT&gt;();    </span><br><span class="line">        para_format_-&gt;cbSize = <span class="keyword">sizeof</span> PARAFORMAT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ppPF = para_format_.get();</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法都要取得结构体的指针，这要求实现者自己来维护这些结构体的生命周期。这里使用std::unique_ptr智能指针来维护这两个结构体，并且把它们作为成员变量。这两个结构体除了cbSize之外，其它字段都可以置为0，表示使用默认设置。</p><p>如果这两个方法的返回值不是S_OK，在创建ITextService的时候会失败。</p><p>TxGetSysColor用于获取各种默认颜色值，例如背景颜色、字符颜色等。如果没有特殊需求，只要调用GetSysColor即可，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">TxGetSysColor</span><span class="params">(<span class="keyword">int</span> nIndex)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GetSysColor(nIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TxGetSelectionBarWidth用于获取selection bar的宽度。所谓selection bar就是位于控件左侧的竖直长条形区域，这块区域不可见，当鼠标移动到上面时，鼠标指针会水平翻转，此时点击左键就可以快速选择一整行的内容。之所以要实现这个方法，是因为Windowless RichEdit没有初始化表示selection bar宽度的变量，导致这个宽度在大部分情况下远远超出了Windowless RichEdit的可视区域，造成文字绘制不出来的假象。所以初始化这个变量的任务要由实现者来完成了，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetSelectionBarWidth</span><span class="params">(LONG *lSelBarWidth)</span> override </span>&#123;</span><br><span class="line">    *lSelBarWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建ITextService"><a href="#创建ITextService" class="headerlink" title="创建ITextService"></a>创建ITextService</h2><p>实现了ITextHost之后，即可使用函数CreateTextServices来创建ITextService，该函数也位于TextServ.h，其声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CreateTextServices</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_  IUnknown  *punkOuter,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_  ITextHost *pITextHost,</span></span></span><br><span class="line"><span class="function"><span class="params">    _Out_ IUnknown  **ppUnk</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数punkOuter用于对象聚合，一般情况下传nullptr即可；第二个参数plTextHost即ITextHost对象；第三个参数ppUnk是获取返回结果的输出参数，注意该参数的实际类型是IUnknown，而不是ITextService，所以之后还要再调用一次QueryInterface来取得ITextService。</p><p>官方文档指出使用CreateTextServices时需要导入riched20.lib这个库，但是在Visual Studio 2013环境下是找不到这个文件的，所以只能动态加载riched20.dll并且找出CreateTextServices的地址。更旧的Visual Studio版本可能没有这个问题。</p><p>同样的，查询ITextService时用到的IID_ITextService常量也要用这种方式来得到。不过，据说在riched20.dll中导出的IID_ITextService常量是错误的，使用它查询不到ITextService。但在Windows 7下试验过是可以的，可能在这个版本的Windows中已经修复了这个问题。如果从DLL中拿出来的IID_ITextService确实有问题，那么可以自己来定义这个常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTERN_C <span class="keyword">const</span> IID IID_ITextServices = &#123;</span><br><span class="line">    <span class="number">0x8d33f740</span>,</span><br><span class="line">    <span class="number">0xcf58</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9d</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过动态加载DLL来创建ITextService的过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">g_text_host = <span class="built_in">std</span>::make_shared&lt;TextHost&gt;();</span><br><span class="line"></span><br><span class="line">HMODULE module_handle = LoadLibrary(<span class="string">L"riched20.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(_stdcall*CreateTextServicesFunction)</span><span class="params">(IUnknown*, ITextHost*, IUnknown**)</span></span>;</span><br><span class="line">CreateTextServicesFunction create_function = <span class="keyword">reinterpret_cast</span>&lt;CreateTextServicesFunction&gt;(GetProcAddress(module_handle, <span class="string">"CreateTextServices"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IID* iid_text_service = <span class="keyword">reinterpret_cast</span>&lt;IID*&gt;(GetProcAddress(module_handle, <span class="string">"IID_ITextServices"</span>));</span><br><span class="line"></span><br><span class="line">CComPtr&lt;IUnknown&gt; unknown;</span><br><span class="line">create_function(<span class="literal">nullptr</span>, g_text_host.get(), &amp;unknown);</span><br><span class="line">unknown-&gt;QueryInterface(*iid_text_service, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;g_text_service));</span><br></pre></td></tr></table></figure><p>上述代码通过LoadLibrary加载riched20.dll，然后通过GetProcAddress得到CreateTextServices和IID_ITextService的地址。注意，当还在使用ITextService的时候，不能调用FreeLibrary卸载riched20.dll，否则会出错。</p><h2 id="绘制Windowless-RichEdit"><a href="#绘制Windowless-RichEdit" class="headerlink" title="绘制Windowless RichEdit"></a>绘制Windowless RichEdit</h2><p>最后要做的就是把Windowless RichEdit显示出来，只要调用ITextService的TxDraw方法即可完成。该方法的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxDraw</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD          dwDrawAspect,</span></span></span><br><span class="line"><span class="function"><span class="params">    LONG           lindex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>           *pvAspect,</span></span></span><br><span class="line"><span class="function"><span class="params">    DVTARGETDEVICE *ptd,</span></span></span><br><span class="line"><span class="function"><span class="params">    HDC            hdcDraw,</span></span></span><br><span class="line"><span class="function"><span class="params">    HDC            hicTargetDev,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCRECTL       lprcBounds,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCRECTL       lprcWBounds,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPRECT         lprcUpdate,</span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL CALLBACK  *pfnContinue,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD          dwContinue,</span></span></span><br><span class="line"><span class="function"><span class="params">    LONG           lViewId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法的参数繁多，但大部分情况下只需要关注其中的<code>dwDrawAspect</code>、<code>hdcDraw</code>和<code>lprcBounds</code>即可。dwDrawAspect指定要绘制控件的哪一部分，传入DVASPECT_CONTENT即可，表示绘制控件内容；hdcDraw即用来绘制的DeviceContext句柄；lprcBounds指定要绘制的区域。其它参数只要指定无效值即可，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RECT rect;</span><br><span class="line">GetClientRect(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">g_text_service-&gt;TxDraw(</span><br><span class="line">    DVASPECT_CONTENT,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    hdc,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;LPCRECTL&gt;(&amp;rect),</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lprcBounds的使用的类型是RECTL，与平常使用的RECT不一样，但是它们的定义是一模一样的，因此可以使用强制类型转换。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>在本文的最后，附上完整的示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlbase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Richedit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TextServ.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextHost</span> :</span> <span class="keyword">public</span> ITextHost &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HRESULT __<span class="function">stdcall <span class="title">QueryInterface</span><span class="params">(REFIID riid, <span class="keyword">void</span>** ppvObject)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ppvObject == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> E_POINTER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((riid == IID_IUnknown) || (riid == IID_ITextHost)) &#123;</span><br><span class="line">            *ppvObject = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> S_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppvObject = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> E_NOINTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG __<span class="function">stdcall <span class="title">AddRef</span><span class="params">(<span class="keyword">void</span>)</span> override </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG __<span class="function">stdcall <span class="title">Release</span><span class="params">(<span class="keyword">void</span>)</span> override </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HDC <span class="title">TxGetDC</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">INT <span class="title">TxReleaseDC</span><span class="params">(HDC hdc)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowScrollBar</span><span class="params">(INT fnBar, BOOL fShow)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxEnableScrollBar</span><span class="params">(INT fuSBFlags, INT fuArrowflags)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollRange</span><span class="params">(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollPos</span><span class="params">(INT fnBar, INT nPos, BOOL fRedraw)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxInvalidateRect</span><span class="params">(LPCRECT prc, BOOL fMode)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxViewChange</span><span class="params">(BOOL fUpdate)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxCreateCaret</span><span class="params">(HBITMAP hbmp, INT xWidth, INT yHeight)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowCaret</span><span class="params">(BOOL fShow)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetCaretPos</span><span class="params">(INT x, INT y)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetTimer</span><span class="params">(UINT idTimer, UINT uTimeout)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxKillTimer</span><span class="params">(UINT idTimer)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxScrollWindowEx</span><span class="params">(INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxSetCapture</span><span class="params">(BOOL fCapture)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxSetFocus</span><span class="params">()</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxSetCursor</span><span class="params">(HCURSOR hcur, BOOL fText)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxScreenToClient</span><span class="params">(LPPOINT lppt)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxClientToScreen</span><span class="params">(LPPOINT lppt)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxActivate</span><span class="params">(LONG * plOldState)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxDeactivate</span><span class="params">(LONG lNewState)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetClientRect</span><span class="params">(LPRECT prc)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetViewInset</span><span class="params">(LPRECT prc)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetCharFormat</span><span class="params">(<span class="keyword">const</span> CHARFORMATW **ppCF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (char_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            char_format_ = <span class="built_in">std</span>::make_unique&lt;CHARFORMATW&gt;();</span><br><span class="line">            char_format_-&gt;cbSize = <span class="keyword">sizeof</span>(CHARFORMATW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppCF = char_format_.get();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetParaFormat</span><span class="params">(<span class="keyword">const</span> PARAFORMAT **ppPF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (para_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            para_format_ = <span class="built_in">std</span>::make_unique&lt;PARAFORMAT&gt;();    </span><br><span class="line">            para_format_-&gt;cbSize = <span class="keyword">sizeof</span> PARAFORMAT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppPF = para_format_.get();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">COLORREF <span class="title">TxGetSysColor</span><span class="params">(<span class="keyword">int</span> nIndex)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GetSysColor(nIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetBackStyle</span><span class="params">(TXTBACKSTYLE *pstyle)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetMaxLength</span><span class="params">(DWORD *plength)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetScrollBars</span><span class="params">(DWORD *pdwScrollBar)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPasswordChar</span><span class="params">(_Out_ TCHAR *pch)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetAcceleratorPos</span><span class="params">(LONG *pcp)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetExtent</span><span class="params">(LPSIZEL lpExtent)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxCharFormatChange</span><span class="params">(<span class="keyword">const</span> CHARFORMATW * pCF)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxParaFormatChange</span><span class="params">(<span class="keyword">const</span> PARAFORMAT * pPF)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPropertyBits</span><span class="params">(DWORD dwMask, DWORD *pdwBits)</span> override </span>&#123;</span><br><span class="line">        *pdwBits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxNotify</span><span class="params">(DWORD iNotify, <span class="keyword">void</span> *pv)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HIMC <span class="title">TxImmGetContext</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxImmReleaseContext</span><span class="params">(HIMC himc)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetSelectionBarWidth</span><span class="params">(LONG *lSelBarWidth)</span> override </span>&#123;</span><br><span class="line">        *lSelBarWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CHARFORMATW&gt; char_format_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;PARAFORMAT&gt; para_format_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="keyword">const</span> IID IID_ITextServices = &#123;</span><br><span class="line">    <span class="number">0x8d33f740</span>,</span><br><span class="line">    <span class="number">0xcf58</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9d</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="keyword">const</span> IID IID_ITextHost = &#123;</span><br><span class="line">    <span class="number">0xc5bdd8d0</span>,</span><br><span class="line">    <span class="number">0xd26e</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9e</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TextHost&gt; g_text_host;</span><br><span class="line">CComPtr&lt;ITextServices&gt; g_text_service;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="keyword">char</span>*, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WNDCLASSEX default_class = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    default_class.cbSize = <span class="keyword">sizeof</span>(default_class);</span><br><span class="line">    default_class.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    default_class.lpfnWndProc = WindowProcedure;</span><br><span class="line">    default_class.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    default_class.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    default_class.hInstance = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.hIcon = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.hCursor = LoadCursor(<span class="literal">nullptr</span>, IDI_APPLICATION);</span><br><span class="line">    default_class.hbrBackground = <span class="keyword">reinterpret_cast</span>&lt;HBRUSH&gt;(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">    default_class.lpszMenuName = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.lpszClassName = <span class="string">L"WindowlessRichEdit"</span>;</span><br><span class="line">    default_class.hIconSm = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    RegisterClassEx(&amp;default_class);</span><br><span class="line"></span><br><span class="line">    HWND window_handle = CreateWindowEx(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="string">L"WindowlessRichEdit"</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        WS_OVERLAPPEDWINDOW | WS_VISIBLE,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE: &#123;</span><br><span class="line"></span><br><span class="line">        g_text_host = <span class="built_in">std</span>::make_shared&lt;TextHost&gt;();</span><br><span class="line"></span><br><span class="line">        HMODULE module_handle = LoadLibrary(<span class="string">L"riched20.dll"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(_stdcall*CreateTextServicesFunction)</span><span class="params">(IUnknown*, ITextHost*, IUnknown**)</span></span>;</span><br><span class="line">        CreateTextServicesFunction create_function = <span class="keyword">reinterpret_cast</span>&lt;CreateTextServicesFunction&gt;(GetProcAddress(module_handle, <span class="string">"CreateTextServices"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> IID* iid_text_service = <span class="keyword">reinterpret_cast</span>&lt;IID*&gt;(GetProcAddress(module_handle, <span class="string">"IID_ITextServices"</span>));</span><br><span class="line"></span><br><span class="line">        CComPtr&lt;IUnknown&gt; unknown;</span><br><span class="line">        create_function(<span class="literal">nullptr</span>, g_text_host.get(), &amp;unknown);</span><br><span class="line">        unknown-&gt;QueryInterface(*iid_text_service, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;g_text_service));</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;TxSetText(<span class="string">L"Windowless RichEdit"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_PAINT: &#123;</span><br><span class="line"></span><br><span class="line">        PAINTSTRUCT paint_struct;</span><br><span class="line">        HDC hdc = BeginPaint(hwnd, &amp;paint_struct);</span><br><span class="line"></span><br><span class="line">        RECT rect;</span><br><span class="line">        GetClientRect(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;TxDraw(</span><br><span class="line">            DVASPECT_CONTENT,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            hdc,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;LPCRECTL&gt;(&amp;rect),</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        EndPaint(hwnd, &amp;paint_struct);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> CallWindowProc(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RichEdit是Windows上很常用的富文本控件，它有一个无窗口化的版本，即Windowless RichEdit，关于它的介绍，可以参考官方文档：&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx&lt;/a&gt; 。Windowless RichEdit与普通RichEdit在行为表现上毫无二致，但是在使用方法上却有较大的差异；而且Windowless RichEdit的官方文档少之又少，说明不够全面，甚至连一个完整的示例也没有；更甚者，在不同的Windows平台和开发环境下，Windowless RichEdit的用法都有差异。这让初次接触Windowless RichEdit的人举步维艰，处处碰壁，正应了“万事开头难”这句话。因此，本文聚焦于“开头”，介绍一下创建一个最简单的Windowless RichEdit需要做哪些事情。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="Windowless RichEdit" scheme="http://zplutor.github.io/tags/Windowless-RichEdit/"/>
    
      <category term="RichEdit" scheme="http://zplutor.github.io/tags/RichEdit/"/>
    
      <category term="ITextHost" scheme="http://zplutor.github.io/tags/ITextHost/"/>
    
      <category term="ITextService" scheme="http://zplutor.github.io/tags/ITextService/"/>
    
      <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
  </entry>
  
  <entry>
    <title>WM_TIMER消息是否会在消息队列中堆积</title>
    <link href="http://zplutor.github.io/2015/11/09/whether-WM-TIMER-message-would-accumulate-in-message-queue/"/>
    <id>http://zplutor.github.io/2015/11/09/whether-WM-TIMER-message-would-accumulate-in-message-queue/</id>
    <published>2015-11-09T15:29:31.000Z</published>
    <updated>2016-04-16T12:19:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows界面开发中，启动定时器的最常用方法是使用SetTimer这个API。通过这个API启动的定时器会持续不断地往窗口消息队列中投递WM_TIMER消息，直到调用了KillTimer来停止。一个有趣的问题是，假如定时器的消息程序处理不过来，即处理WM_TIMER的时间比定时器的间隔时间长，会发生什么事情呢？消息队列中是否会堆积越来越多的WM_TIMER消息？官方文档中并没有指出这个问题，只能通过实践来找出答案。</p><a id="more"></a><p>定时器有多种使用场景，下面针对每种场景分别进行试验。</p><h2 id="一个窗口一个定时器"><a href="#一个窗口一个定时器" class="headerlink" title="一个窗口一个定时器"></a>一个窗口一个定时器</h2><p>首先是最简单的使用场景，在一个窗口中启动一个定时器。使用下面的代码生成一个Windows应用程序（为了便于阅读，省略了注册窗口类和创建窗口的代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line">DWORD g_begin_tick_count = <span class="number">0</span>;</span><br><span class="line">DWORD g_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kTimerId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="keyword">char</span>*, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RegisterClassEx(...);</span><br><span class="line">    HWND window_handle = CreateWindowEx(...);</span><br><span class="line"></span><br><span class="line">    g_begin_tick_count = GetTickCount();</span><br><span class="line">    SetTimer(window_handle, kTimerId, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstringstream stream;</span><br><span class="line">        stream &lt;&lt; <span class="string">L"Process WM_TIMER. "</span> </span><br><span class="line">            &lt;&lt; <span class="string">L"TimerId: "</span> &lt;&lt; wParam &lt;&lt; <span class="string">". "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Counter: "</span> &lt;&lt; ++g_counter &lt;&lt; <span class="string">", "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Time: "</span> &lt;&lt; GetTickCount() - g_begin_tick_count &lt;&lt; <span class="string">'.'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstring <span class="built_in">string</span> = stream.str();</span><br><span class="line">        OutputDebugString(<span class="built_in">string</span>.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_counter &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            Sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> CallWindowProc(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个间隔时间为1秒的定时器，在处理WM_TIMER的时候，输出定时器ID，消息个数以及当前时间。<code>g_counter</code>全局变量记录处理过的WM_TIMER消息的数量；时间的计算使用GetTickCount函数，单位是毫秒。在处理前面4个WM_TIMER的时候，使用Sleep函数使程序挂起5秒，模拟处理时间过长的情景。</p><p>程序总的挂起时间是<code>4*5=20</code>秒，在这段时间内，定时器理应触发20次，即投递20个WM_TIMER消息，但是程序只能处理其中的3个（第一个不算）。假如WM_TIMER消息会堆积，那么从第5个开始，由于不再挂起程序，这些堆积的消息可以一口气处理完。观察程序是否会在短时间内连续输出，即可验证这个假设。</p><p>启动程序，静置一段时间之后，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 3, Time: 11029.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 6, Time: 21294.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 7, Time: 22308.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 8, Time: 23322.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 9, Time: 24336.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 10, Time: 25350.</span><br></pre></td></tr></table></figure><p>可以看到，在处理了第5个WM_TIMER消息之后，紧接着就处理了第6个，接下来每隔1秒处理一个，并没有一口气处理了一批。也就是说，WM_TIMER消息并不会堆积。</p><h2 id="一个窗口多个定时器"><a href="#一个窗口多个定时器" class="headerlink" title="一个窗口多个定时器"></a>一个窗口多个定时器</h2><p>如果一个窗口中多有个定时器，其中某个定时器处理不过来，对其它的定时器有什么影响呢？继续进行试验，把上面的代码稍作修改，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line">DWORD g_begin_tick_count = <span class="number">0</span>;</span><br><span class="line">DWORD g_counter1 = <span class="number">0</span>;</span><br><span class="line">DWORD g_counter2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kTimerId1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kTimerId2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="keyword">char</span>*, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RegisterClassEx(...);</span><br><span class="line">    HWND window_handle = CreateWindowEx(...);</span><br><span class="line"></span><br><span class="line">    g_begin_tick_count = GetTickCount();</span><br><span class="line">    SetTimer(window_handle, kTimerId1, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    SetTimer(window_handle, kTimerId2, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstringstream stream;</span><br><span class="line">        stream &lt;&lt; <span class="string">L"Process WM_TIMER. "</span> </span><br><span class="line">            &lt;&lt; <span class="string">L"TimerId: "</span> &lt;&lt; wParam &lt;&lt; <span class="string">". "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Counter: "</span> &lt;&lt; (wParam == kTimerId1 ? ++g_counter1 : ++g_counter2) &lt;&lt; <span class="string">", "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Time: "</span> &lt;&lt; GetTickCount() - g_begin_tick_count &lt;&lt; <span class="string">'.'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstring <span class="built_in">string</span> = stream.str();</span><br><span class="line">        OutputDebugString(<span class="built_in">string</span>.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wParam == kTimerId1) &amp;&amp; (g_counter1 &lt; <span class="number">5</span>)) &#123;</span><br><span class="line">            Sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> CallWindowProc(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了两个间隔都是1秒的定时器，分别用<code>g_counter1</code>和<code>g_counter2</code>两个全局变量来记录它们处理过的WM_TIMER消息的数量。同样地，在处理第一个定时器的前4个WM_TIMER消息时，调用Sleep函数挂起程序5秒。第二个定时器的WM_TIMER消息不做特殊处理。</p><p>启动程序，静置一段时间之后，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 2. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 3, Time: 11030.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 3, Time: 11030.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 6, Time: 21295.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 6, Time: 21295.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 7, Time: 22309.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 7, Time: 22309.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 8, Time: 23323.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 8, Time: 23323.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 9, Time: 24337.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 9, Time: 24337.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 10, Time: 25351.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 10, Time: 25351.</span><br></pre></td></tr></table></figure><p>两个定时器的行为基本一致，而且跟上一个场景一样，在连续处理了第5个和第6个WM_TIMER消息之后，还是每隔1秒处理一个。可见，第一个定时器处理不过来，会影响到第二个定时器，但是它们的WM_TIMER消息都不会堆积。</p><h2 id="多个窗口多个定时器"><a href="#多个窗口多个定时器" class="headerlink" title="多个窗口多个定时器"></a>多个窗口多个定时器</h2><p>最后再看看在不同窗口中启动多个定时器的场景。修改上一个场景的代码，在另一个窗口中创建第二个定时器，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="keyword">char</span>*, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RegisterClassEx(...);</span><br><span class="line">    HWND window_handle1 = CreateWindowEx(...);</span><br><span class="line">    HWND window_handle2 = CreateWindowEx(...);</span><br><span class="line"></span><br><span class="line">    g_begin_tick_count = GetTickCount();</span><br><span class="line">    SetTimer(window_handle1, kTimerId1, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    SetTimer(window_handle2, kTimerId2, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的代码保持不变。</p><p>启动程序，静置一段时间之后，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 2. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 3, Time: 11030.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 3, Time: 11030.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 6, Time: 21295.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 6, Time: 21295.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 7, Time: 22309.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 7, Time: 22309.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 8, Time: 23323.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 8, Time: 23323.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 9, Time: 24337.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 9, Time: 24337.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 10, Time: 25351.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 10, Time: 25351.</span><br></pre></td></tr></table></figure><p>结果跟第二个场景一模一样，可见即使是不同窗口中的定时器，WM_TIMER消息也不会堆积。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上三个场景的试验，可以得出这个结论：同一个定时器的WM_TIMER消息在消息队列中至多存在一个，不会堆积。</p><p>要注意的是，即使WM_TIMER消息不会堆积，在使用定时器时仍然要小心避免处理时间比间隔时间长的情况。由试验结果可以看到，一旦出现这种情况，消息队列中总会存在一个WM_TIMER消息等待处理，程序会忙于处理这些WM_TIMER消息，一刻都不停歇，就像陷入了一个循环，这对程序有严重的影响。</p><p>由于各种因素的影响，对于同样的处理逻辑，每次执行所用的时间很可能都不一样。所以，如果担心处理时间过长，可以通过更安全的方式来使用定时器，即模拟一次性定时器：在开始处理WM_TIMER消息的时候，调用KillTimer停止定时器；处理完成之后，再调用SetTimer重新开启定时器。例如，把第一个场景中处理WM_TIMER的代码改成以下的安全方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line"></span><br><span class="line">        KillTimer(hwnd, kTimerId);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstringstream stream;</span><br><span class="line">        stream &lt;&lt; <span class="string">L"Process WM_TIMER. "</span> </span><br><span class="line">            &lt;&lt; <span class="string">L"TimerId: "</span> &lt;&lt; wParam &lt;&lt; <span class="string">". "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Counter: "</span> &lt;&lt; ++g_counter &lt;&lt; <span class="string">", "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Time: "</span> &lt;&lt; GetTickCount() - g_begin_tick_count &lt;&lt; <span class="string">'.'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstring <span class="built_in">string</span> = stream.str();</span><br><span class="line">        OutputDebugString(<span class="built_in">string</span>.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_counter &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            Sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SetTimer(hwnd, kTimerId, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> CallWindowProc(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，静置一段时间之后，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 2, Time: 7036.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 3, Time: 13058.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 4, Time: 19079.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 5, Time: 25101.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 6, Time: 26115.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 7, Time: 27129.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 8, Time: 28143.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 9, Time: 29157.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 10, Time: 30171.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 11, Time: 31185.</span><br></pre></td></tr></table></figure><p>通过这种方式，不管处理时间有多长，在处理完一个WM_TIMER消息之后，总会真正等待1秒才处理下一个，避免了程序长时间处于繁忙状态的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Windows界面开发中，启动定时器的最常用方法是使用SetTimer这个API。通过这个API启动的定时器会持续不断地往窗口消息队列中投递WM_TIMER消息，直到调用了KillTimer来停止。一个有趣的问题是，假如定时器的消息程序处理不过来，即处理WM_TIMER的时间比定时器的间隔时间长，会发生什么事情呢？消息队列中是否会堆积越来越多的WM_TIMER消息？官方文档中并没有指出这个问题，只能通过实践来找出答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="定时器" scheme="http://zplutor.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
      <category term="WM_TIMER" scheme="http://zplutor.github.io/tags/WM-TIMER/"/>
    
      <category term="消息队列" scheme="http://zplutor.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如何让std::shared_ptr持有IUnknown对象</title>
    <link href="http://zplutor.github.io/2015/10/31/how-to-maintain-iunknown-object-in-shared-ptr/"/>
    <id>http://zplutor.github.io/2015/10/31/how-to-maintain-iunknown-object-in-shared-ptr/</id>
    <published>2015-10-31T03:26:46.000Z</published>
    <updated>2018-04-08T16:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11新增的智能指针std::shared_ptr使用引用计数来管理对象的生命周期，而COM提供的IUnknown接口也使用引用计数来管理自身的生命周期。理论上来说，在同一个环境中不应该同时使用两套引用计数方案，不然会造成混乱，带来很多麻烦。然而实际上，需要同时使用这两种方案的情况并不少见，有时的确需要用std::shared_ptr来持有COM对象。虽然这种做法看上去丑陋，并且是可以用别的方法来避免的，但本文不讨论这些方面，只聚焦于问题的本身。</p><a id="more"></a><p>得益于std::shared_ptr提供的灵活性，持有COM对象是十分简单的。在默认情况下，当std::shared_ptr的引用计数达到0时，它会调用delete操作符来销毁持有的对象。然而在构造std::shared_ptr的时候，可以传入一个自定义的删除器，来改变它默认的删除行为。删除器可以是函数、仿函数或者lambda表达式等可调用的函数对象。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> deletor = [](<span class="keyword">int</span>* p) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deleting "</span> &lt;&lt; p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; i1(<span class="keyword">new</span> <span class="keyword">int</span>(), deletor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; i2 = i1;</span><br><span class="line">    i1.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用一个lambda表达式作为变量<code>i1</code>的删除器，该删除器在销毁int之前会打印出一行消息。删除器会随着std::shared_ptr一同拷贝或赋值，所以不必担心删除器会丢失。在上面的代码中，变量<code>i2</code>接管了删除器，在程序退出之前依然会打印出那条消息。</p><p>显然，对于COM对象来说，只要在删除器里调用Release方法来替换delete操作符即可。下面是将IUnknown对象转成std::shared_ptr的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IUnknown&gt; ConvertToSharedPtr(IUnknown* unknown) &#123;</span><br><span class="line"></span><br><span class="line">    unknown-&gt;AddRef();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IUnknown&gt;(unknown, [](IUnknown* p) &#123; p-&gt;Release(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在将COM对象传递给std::shared_ptr之前务必要调用AddRef方法增加它的引用计数。这样一来，在同一个对象上存在着两个引用计数：IUnknown的引用计数是主要的，只有当这个引用计数达到0时，对象才会被销毁；std::shared_ptr的引用计数是次要的，当这个引用计数达到0时，只会把IUnknown的引用计数减一。两者和谐共存，不会相互影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++11新增的智能指针std::shared_ptr使用引用计数来管理对象的生命周期，而COM提供的IUnknown接口也使用引用计数来管理自身的生命周期。理论上来说，在同一个环境中不应该同时使用两套引用计数方案，不然会造成混乱，带来很多麻烦。然而实际上，需要同时使用这两种方案的情况并不少见，有时的确需要用std::shared_ptr来持有COM对象。虽然这种做法看上去丑陋，并且是可以用别的方法来避免的，但本文不讨论这些方面，只聚焦于问题的本身。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
      <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
      <category term="IUnknown" scheme="http://zplutor.github.io/tags/IUnknown/"/>
    
      <category term="智能指针" scheme="http://zplutor.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
      <category term="引用计数" scheme="http://zplutor.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何调试在std::thread子线程中抛出的C++异常</title>
    <link href="http://zplutor.github.io/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/"/>
    <id>http://zplutor.github.io/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/</id>
    <published>2015-10-11T12:06:41.000Z</published>
    <updated>2018-04-08T16:56:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11标准库新增的std::thread类可以方便地开启子线程。然而有个奇怪的现象是，如果在这些子线程中抛出了未处理的C++异常而导致程序崩溃，那么在生成的dump文件中将还原不出异常发生时的调用栈。可以通过下面的方法来展示这个现象。</p><a id="more"></a><p>首先使用以下代码生成一个控制台程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread* g_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.at(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    g_thread = <span class="keyword">new</span> <span class="built_in">std</span>::thread(ThreadEntry);</span><br><span class="line">    g_thread-&gt;join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，就是通过std::thread创建一个子线程，并且在这个子线程中访问一个空的std::vector中的元素，让它抛出C++异常。务必要使用Release配置来生成程序，不能使用Debug配置。</p><p>接下来，在资源管理器中直接运行该程序，注意不要通过调试器来运行。一般会在第二次运行的时候，出现下面的Windows错误报告窗口：</p><img src="/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/1.png"><p>在详细信息中的C:\Users\Zplutor\AppData\Local\Temp\WERBF98.tmp.mdmp文件即是Windows错误报告为崩溃的程序生成的dump文件，里面包含了程序崩溃时的一些信息，例如函数调用栈。该文件在关闭了错误报告窗口时即被删除，所以要先把这个文件复制出来。</p><p>最后，用WinDbg打开这个dump文件，先用.ecxr命令切换到异常环境，再用k命令显示调用栈，结果显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; k</span><br><span class="line">  *** Stack trace for last set context - .thread/.cxr resets it</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">0095f07c 6ba8dc5f msvcr120!abort+0x38 [f:\dd\vctools\crt\crtw32\misc\abort.c @ 90]</span><br><span class="line">0095f0ac 6b99f353 msvcr120!terminate+0x33 [f:\dd\vctools\crt\crtw32\eh\hooks.cpp @ 96]</span><br><span class="line">0095f8fc 6ba1c01d msvcp120!_Call_func+0x2e [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f934 6ba1c001 msvcr120!_callthreadstartex+0x1b [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]</span><br><span class="line">0095f940 7685ee6c msvcr120!_threadstartex+0x7c [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]</span><br><span class="line">0095f94c 77053ab3 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">0095f98c 77053a86 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">0095f9a4 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure><p>可以看到，显示出来的调用栈几乎没有用处，只能看出子线程在开始之后就调用了terminate函数来终止程序，完全看不出来是什么原因导致的。</p><p>在调试的时候，如果遇到难以逾越的问题，不妨大胆地进行推测，并根据这些推测进行尝试。推测不一定是正确的，但是在尝试的过程中很可能会发现新的解法。在当前这个例子中，即使不了解std::thread子线程的具体实现，也不难根据上面的调用栈推测出来。下面是一种可能的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Call_func() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ThreadEntry();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        terminate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_Call_func函数用来调用在std::thread的构造函数中传进来的入口函数，在本例中即是ThreadEntry。该入口函数通过一对try/catch包裹起来，凡是在它里面抛出来的未处理异常都会被捕获，继而调用terminate函数来终止程序。由于terminate是在_Call_func函数中调用的，所以从调用栈上来看，terminate的上一个栈帧必然是_Call_func，ThreadEntry内部的所有栈帧都被跳过了。</p><p>根据以上的推测可知，异常发生时的调用栈还原不出来，只是因为它的栈帧被跳过了而已，假如这些栈帧还保留着，那肯定还是能还原出来的。继续观察上述的调用栈，发现_Call_func和terminate的栈帧之间尚有大约2KB（根据ChildEBP计算得来，0095f8fc - 0095f0ac）的内容，因此可以有八九分把握确定被跳过的栈帧就在这里面。</p><p>接下来要通过手工方式寻找那些被跳过的栈帧。从terminate栈帧的ChildEBP开始，使用dps命令逐步向上寻找。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; dps 0095f0ac l32</span><br><span class="line">0095f0ac  0095f8fc</span><br><span class="line">0095f0b0  6b99f353 msvcp120!_Call_func+0x2e [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f0b4  6ba097f2 msvcr120!_NLG_Return [f:\dd\vctools\crt\crtw32\eh\i386\lowhelpr.asm @ 64]</span><br><span class="line">0095f0b8  0095f8f0</span><br><span class="line">0095f0bc  0095f37c</span><br><span class="line">0095f0c0  0095f0d0</span><br><span class="line">0095f0c4  0095f8f0</span><br><span class="line">0095f0c8  00000000</span><br><span class="line">0095f0cc  0095f8fc</span><br><span class="line">0095f0d0  0095f0fc</span><br><span class="line">0095f0d4  6ba09861 msvcr120!_CallCatchBlock2+0x4f [f:\dd\vctools\crt\crtw32\eh\i386\trnsctrl.cpp @ 502]</span><br><span class="line">0095f0d8  6b99f34d msvcp120!_Call_func+0x28 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f0dc  0095f8f0</span><br><span class="line">0095f0e0  00000100</span><br><span class="line">0095f0e4  0095f158</span><br><span class="line">0095f0e8  6ba09ffc msvcr120!CatchGuardHandler [f:\dd\vctools\crt\crtw32\eh\i386\trnsctrl.cpp @ 535]</span><br><span class="line">0095f0ec  c29105eb</span><br><span class="line">0095f0f0  6b9b4bc0 msvcp120!_CTA4?AVsystem_errorstd+0x7c</span><br><span class="line">0095f0f4  0095f8f0</span><br><span class="line">0095f0f8  00000001</span><br><span class="line">0095f0fc  0095f168</span><br><span class="line">0095f100  6ba0999c msvcr120!CallCatchBlock+0x87 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1400]</span><br><span class="line">0095f104  0095f8f0</span><br><span class="line">0095f108  6b9b4bc0 msvcp120!_CTA4?AVsystem_errorstd+0x7c</span><br><span class="line">0095f10c  6b99f34d msvcp120!_Call_func+0x28 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f110  00000000</span><br><span class="line">0095f114  00000100</span><br><span class="line">0095f118  c2910467</span><br><span class="line">0095f11c  0095f8f0</span><br><span class="line">0095f120  6b9b4bac msvcp120!_CTA4?AVsystem_errorstd+0x68</span><br><span class="line">0095f124  0095f8f0</span><br><span class="line">0095f128  0095f898</span><br><span class="line">0095f12c  00000000</span><br><span class="line">0095f130  00000000</span><br><span class="line">0095f134  00000000</span><br><span class="line">0095f138  00000000</span><br><span class="line">0095f13c  0095f128</span><br><span class="line">0095f140  0095f8dc</span><br><span class="line">0095f144  6b9ff756 msvcr120!_getptd+0x6 [f:\dd\vctools\crt\crtw32\startup\tidtable.c @ 337]</span><br><span class="line">0095f148  00000000</span><br><span class="line">0095f14c  6b99f34d msvcp120!_Call_func+0x28 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f150  0095f118</span><br><span class="line">0095f154  c291048b</span><br><span class="line">0095f158  0095f2a8</span><br><span class="line">0095f15c  6ba0a0d5 msvcr120!_except_handler4 [f:\dd\vctools\crt\crtw32\misc\i386\chandler4gs.c @ 84]</span><br><span class="line">0095f160  a9a46ccf</span><br><span class="line">0095f164  00000001</span><br><span class="line">0095f168  0095f1a4</span><br><span class="line">0095f16c  6ba09a50 msvcr120!CatchIt+0x69 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1211]</span><br><span class="line">0095f170  0095f37c</span><br></pre></td></tr></table></figure><p>这个寻找过程需要耐心和运气，因为dps命令输出的结果非常多，而且有些并不是真正的栈帧。在不了解C++异常处理的情况下只能逐个排查，排查的方法是，使用k命令从该栈帧开始回溯调用栈，看看最终能不能到达KiUserExceptionDispatcher的栈帧。例如，可以从上面结果的最后一个栈帧CatchIt开始回溯。要注意，根据栈帧的结构，0095f16c存放的是返回地址，上一个0095f168存放的才是ebp，所以应使用0095f168来回溯。结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; k = 0095f168</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">0095f07c 6ba8dc5f msvcr120!abort+0x38 [f:\dd\vctools\crt\crtw32\misc\abort.c @ 90]</span><br><span class="line">0095f168 6ba09a50 msvcr120!terminate+0x33 [f:\dd\vctools\crt\crtw32\eh\hooks.cpp @ 96]</span><br><span class="line">0095f1a4 6ba095ab msvcr120!CatchIt+0x69 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1211]</span><br><span class="line">0095f220 6ba09638 msvcr120!FindHandler+0x27b [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 689]</span><br><span class="line">0095f254 6ba096ba msvcr120!__InternalCxxFrameHandler+0xd6 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 439]</span><br><span class="line">0095f290 770372b9 msvcr120!__CxxFrameHandler3+0x26 [f:\dd\vctools\crt\crtw32\eh\i386\trnsctrl.cpp @ 301]</span><br><span class="line">0095f2b4 7703728b ntdll!ExecuteHandler2+0x26</span><br><span class="line">0095f2d8 7700f9d7 ntdll!ExecuteHandler+0x24</span><br><span class="line">0095f364 77037117 ntdll!RtlDispatchException+0x127</span><br><span class="line">0095f364 00000000 ntdll!KiUserExceptionDispatcher+0xf</span><br></pre></td></tr></table></figure><p>这个调用栈最终到达了KiUserExceptionDispatcher，也就是我们要找的栈帧。为什么要找KiUserExceptionDispatcher的栈帧呢？这是因为在Windows下所有异常都是通过KiUserExceptionDispatcher这个函数抛出来的，这个函数具有两个类型分别为PEXCEPTION_RECORD和PCONTEXT的参数，分别指向异常信息以及异常发生时的线程环境信息。</p><p>既然找到了KiUserExceptionDispatcher的栈帧，那么可以换用kb命令，显示出它的参数列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; kb = 0095f168</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">（略）</span><br><span class="line">0095f364 00000000 0095f37c 0095f39c 0095f37c ntdll!KiUserExceptionDispatcher+0xf</span><br></pre></td></tr></table></figure><p>可知PEXCEPTION_RECORD的值是0095f37c，PCONTEXT的值是0095f39c。</p><p>WinDbg提供了.exr命令来显示PEXCEPTION_RECORD的内容，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; .exr 0095f37c</span><br><span class="line">ExceptionAddress: 74c4812f (KERNELBASE!RaiseException+0x00000058)</span><br><span class="line">   ExceptionCode: e06d7363 (C++ EH exception)</span><br><span class="line">  ExceptionFlags: 00000001</span><br><span class="line">NumberParameters: 3</span><br><span class="line">   Parameter[0]: 19930520</span><br><span class="line">   Parameter[1]: 0095f898</span><br><span class="line">   Parameter[2]: 6b9b5734</span><br><span class="line">  pExceptionObject: 0095f898</span><br><span class="line">  _s_ThrowInfo    : 6b9b5734</span><br><span class="line">  Type            : class std::out_of_range</span><br><span class="line">  Type            : class std::logic_error</span><br><span class="line">  Type            : class std::exception</span><br></pre></td></tr></table></figure><p>可以看到这是一个C++异常，并且类型是std::out_of_range。</p><p>WinDbg亦提供了.cxr命令，可以切换到指定PCONTEXT的线程环境，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; .cxr 0095f39c</span><br><span class="line">eax=0095f7f8 ebx=00431ee8 ecx=00000003 edx=00000000 esi=6b9b5734 edi=0095f898</span><br><span class="line">eip=74c4812f esp=0095f7f8 ebp=0095f848 iopl=0         nv up ei pl nz ac po nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212</span><br><span class="line">KERNELBASE!RaiseException+0x58:</span><br><span class="line">74c4812f c9              leave</span><br></pre></td></tr></table></figure><p>至此，异常发生时的各种寄存器信息一览无余。此时使用k命令即可得到异常发生时的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; k</span><br><span class="line">  *** Stack trace for last set context - .thread/.cxr resets it</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">0095f848 6ba09339 KERNELBASE!RaiseException+0x58</span><br><span class="line">0095f888 6b983a3a msvcr120!_CxxThrowException+0x5b [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]</span><br><span class="line">0095f8a4 00c2104c msvcp120!std::_Xout_of_range+0x2e [f:\dd\vctools\crt\crtw32\stdcpp\xthrow.cpp @ 24]</span><br><span class="line">0095f8cc 00c211ac ConsoleApplication!ThreadEntry+0x4c [c:\users\zplutor\documents\projects\tests\consoleapplication\main.cpp @ 9]</span><br><span class="line">0095f8d4 6b99f33c ConsoleApplication!std::_LaunchPad&lt;std::_Bind&lt;1,void,void (__cdecl*const)(void)&gt; &gt;::_Go+0xc [c:\program files\microsoft visual studio 12.0\vc\include\thr\xthread @ 187]</span><br><span class="line">0095f8fc 6ba1c01d msvcp120!_Call_func+0x17 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 28]</span><br><span class="line">0095f934 6ba1c001 msvcr120!_callthreadstartex+0x1b [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]</span><br><span class="line">0095f940 7685ee6c msvcr120!_threadstartex+0x7c [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]</span><br><span class="line">0095f94c 77053ab3 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">0095f98c 77053a86 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">0095f9a4 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure><p>本文开头提到的现象并不是std::thread特有的。事实上，如果在捕获了一个异常之后的处理过程中又抛出了一个新的异常，那么旧异常的调用栈会被新异常的调用栈覆盖。在本文的例子中，_Call_func捕获了第一个异常之后，调用了terminate函数，terminate继而又调用了abort函数来抛出新的异常。使用本文提到的方法，就可以应对这种情况，还原出旧异常的调用栈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++11标准库新增的std::thread类可以方便地开启子线程。然而有个奇怪的现象是，如果在这些子线程中抛出了未处理的C++异常而导致程序崩溃，那么在生成的dump文件中将还原不出异常发生时的调用栈。可以通过下面的方法来展示这个现象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
      <category term="线程" scheme="http://zplutor.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="WinDbg" scheme="http://zplutor.github.io/tags/WinDbg/"/>
    
      <category term="异常" scheme="http://zplutor.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>使用预编译头提高编译速度</title>
    <link href="http://zplutor.github.io/2015/09/28/use-precompiled-header-to-speed-up-compilation/"/>
    <id>http://zplutor.github.io/2015/09/28/use-precompiled-header-to-speed-up-compilation/</id>
    <published>2015-09-28T04:00:51.000Z</published>
    <updated>2016-04-16T12:23:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是预编译头"><a href="#什么是预编译头" class="headerlink" title="什么是预编译头"></a>什么是预编译头</h2><p>在介绍预编译头之前，有必要了解一下C/C++的编译方式。C/C++的编译单元是源文件（带有.c、.cc、.cpp等扩展名的文件），在编译一个源文件之前，预处理器会把这个源文件中所有通过#include指令包含进来的头文件递归地展开，也就是把所有直接或间接包含的头文件原封不动地插入进来。当这个过程结束之后，才开始编译。</p><a id="more"></a><p>这种编译方式的缺点是会使头文件被重复编译。假如有一百个源文件都包含了Windows.h，那么这个头文件会在一百个源文件中展开，它里面的代码会被重复编译了一百次，尽管每次编译的结果都相同。对于具有成千上万个源文件的大型项目来说，重复编译是难以接受的，会浪费大量的编译时间。</p><p>为了解决这个问题，预编译头应运而生。顾名思义，预编译头就是预先把头文件编译好，在编译源文件的时候直接取用这些编译结果，避免对头文件重复编译。这项技术能大幅提高C++的编译速度。</p><p>Visual C++生成的扩展名为.pch的文件即是预编译头生成的结果。</p><h2 id="如何使用预编译头"><a href="#如何使用预编译头" class="headerlink" title="如何使用预编译头"></a>如何使用预编译头</h2><p>Visual C++对预编译头的设置并不直观，容易造成误解。在这里详细介绍一下如何启用预编译头。以下操作是在Visual Studio 2013上进行的，不过Visual Studio各版本之间的差异不大，更早或更新的版本也适用。</p><p>首先要做的，是在项目中添加一个头文件以及源文件，这两个文件是给预编译头这个机制使用的。它们的名称并没有限制，这里把它们命名为precompiled.h和precompiled.cpp（Visual C++使用的默认名字是StdAfx.h和StdAfx.cpp）。</p><p>precompiled.h将被指定成预编译头文件，所有在这个头文件中的代码都会被预编译。可以把任意代码添加到这个文件，一般的做法是把常用的头文件包含进来，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/format.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>precompiled.cpp则为precompiled.h提供了编译的载体，因为C/C++只能对源文件编译，而不能对头文件编译。precompiled.cpp只需要包含precompiled.h即可（由于示例项目的需要，包含语句中包含了相对路径）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"win/precompiled.h"</span></span></span><br></pre></td></tr></table></figure><p>接下来，指定通过precompiled.cpp来生成预编译结果。在“解决方案资源管理器中”，右击precompiled.cpp文件，在弹出的菜单中点击“属性”，打开该文件的属性页窗口。</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/1.png"><p>在属性页窗口中，打开“预编译头”配置页，设置“预编译头”选项的值为“创建（/Yc）”，设置“预编译头文件”选项的值为“win/precompiled.h”。如下图所示：</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/2.png"><p>点击确定完成设置。如此一来，在编译precompiled.cpp的时候就会生成预编译结果，也就是.pch文件。</p><p>设置了生成预编译结果之后，还需要设置使用预编译结果。在“解决方案资源管理器中”，右击项目节点，在弹出的菜单中点击“属性”，打开项目的属性页窗口。</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/3.png"><p>同样地，在属性页窗口中打开“预编译头”配置页，设置“预编译头”选项的值为“使用（/Yu）”，设置“预编译头文件”选项的值为“win/precompiled.h”。要注意“预编译头”选项的值跟之前的不同。如下图所示：</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/4.png"><p>最后，需要在所有的源文件中包含预编译头文件，并且该文件必须是第一个包含的。这是使用预编译头的硬性规定，假如不遵守这个规定，编译会失败。重复地在所有源文件中添加预编译头文件很繁琐，所幸的是Visual C++提供了强制在所有源文件中包含指定头文件的选项。同样在项目的属性页窗口中，打开“C/C++”分类下的“高级”配置页，在“强制包含文件”的选项中，添加“win/precompiled.h”即可，如下图所示：</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/5.png"><p>至此，预编译头的设置就完成了。注意，在预编译头文件之后再重复包含该文件内已包含的头文件并不会有问题，所以不必特意去掉那些重复的包含语句。</p><h2 id="预编译头性能实测"><a href="#预编译头性能实测" class="headerlink" title="预编译头性能实测"></a>预编译头性能实测</h2><p>预编译头对编译性能有多大的提升呢？这里用一个实际的项目进行测试。该项目共有1006个头文件和源文件，分别在关闭和打开预编译头的情况下重新生成整个项目两次，记录下生成的开始时间和结束时间。最终得到的数据如下：</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/6.png"><p>可以看到，使用了预编译头之后，编译性能有了30%以上的提升，节省了不少时间。当然，这里的数据只是一个参考值，实际的提升程度得视项目的具体情况而定。一般来说，预编译头文件中包含的头文件被使用得越多，性能提升越明显。</p><h2 id="使用预编译头的注意事项"><a href="#使用预编译头的注意事项" class="headerlink" title="使用预编译头的注意事项"></a>使用预编译头的注意事项</h2><p>既然预编译头有这样的好处，那么是不是加入预编译的头文件越多越好呢？答案是否定的。上文已经提到，使用预编译头的时候必须在所有源文件中包含预编译头文件，由此造成的影响是，一旦其中的头文件发生了变化，不论这个变化有多细微，整个项目都要重新编译。把一个会被频繁修改的头文件包含到预编译头文件中是非常不明智的做法，因此，理想的选择是下列几乎不会修改的头文件：</p><ul><li>操作系统API头文件，例如Windows.h。</li><li>C/C++标准库头文件，例如string。</li><li>第三方库头文件，例如boost/filesystem.hpp。</li></ul><p>另外一个要注意的是，C++的预编译头是不能用在C上的，反之亦然。也就是说，假如预编译头是通过.cpp源文件生成的，那么在.c源文件中使用了这个预编译头就会导致编译出错。有方法可以分别为这两种语言生成和使用不同的预编译头，不过这样做稍显复杂，最简单的做法是把源文件的扩展名改成.cpp，统一使用C++即可，这在大部分情况下都是可行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是预编译头&quot;&gt;&lt;a href=&quot;#什么是预编译头&quot; class=&quot;headerlink&quot; title=&quot;什么是预编译头&quot;&gt;&lt;/a&gt;什么是预编译头&lt;/h2&gt;&lt;p&gt;在介绍预编译头之前，有必要了解一下C/C++的编译方式。C/C++的编译单元是源文件（带有.c、.cc、.cpp等扩展名的文件），在编译一个源文件之前，预处理器会把这个源文件中所有通过#include指令包含进来的头文件递归地展开，也就是把所有直接或间接包含的头文件原封不动地插入进来。当这个过程结束之后，才开始编译。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="编译" scheme="http://zplutor.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="预编译头" scheme="http://zplutor.github.io/tags/%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>使用流式输出写调试日志</title>
    <link href="http://zplutor.github.io/2015/08/29/write-debug-log-streamly/"/>
    <id>http://zplutor.github.io/2015/08/29/write-debug-log-streamly/</id>
    <published>2015-08-29T12:50:54.000Z</published>
    <updated>2016-04-16T12:25:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>日志是一种有效的调试手段。但是日志写得太频繁会降低程序性能，所以一般采取的策略是，大部分日志只在调试版的程序中输出，少量重要的日志才在发行版的程序中输出。为了控制调试日志的输出，通常会使用下面的简便方法：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOG(format, ...) printf(format, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOG(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面的代码定义了一个DLOG宏，当处于调试模式时，DLOG会展开成对printf函数（或者类似函数）的调用；否则什么也不做。使用这个宏之后，调试日志对发行版程序没有任何影响。</p><p>但是，由于printf固有的特点，使用这种方式写日志存在一些缺陷。最主要的是，格式化字符串中的形参与实参的个数和类型必须一致，否则，要么输出的信息不正确，要么程序直接崩溃。这种问题只有在真正执行的时候才显现出来，假如错误的DLOG调用位于深层次的条件语句中，那么它很可能会一直隐藏在那里。</p><p>不要觉得这种低级错误不会发生。根据实际经验来看，写了一句日志导致程序崩溃的尴尬情况还是挺常见的。</p><p>C++标准库使用的流式输出解决了上述缺陷。所谓流式输出，就像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Today is "</span> &lt;&lt; <span class="number">2015</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">'.'</span>;</span><br></pre></td></tr></table></figure><p>这种方式不需要事先定义格式字符串，不必再担心实参个数和类型的匹配问题。更重要的是，如果实参不能被输出，在编译阶段就会出错，而不是等到运行的时候才出错。流式输出使用上更简便，安全性更高，假如能使用这种方式来写日志，无疑会提高开发效率。</p><p>流式输出的使用方式与printf截然不同，显然不能再使用可变参数宏来定义DLOG了。所以接下来的问题是，如何定义DLOG以支持流式输出。要是不能做到在发行版程序中完全消除调试日志的影响，那么它也只是一个不实用的花瓶。</p><p>这个问题看起来似乎很难，实际上并非如此。早已有人找到了解决方法——在Chromium中就是使用流式输出写日志的。Chromium是开源项目，可以直接从它的代码中寻找答案。不过它的相关代码中封装了太多功能，理解起来并不容易。在经过一番抽丝剥茧之后，这里还原出它的核心思想。</p><p>首先，根据是否处于调试模式定义ENABLE_DEBUG_LOG宏，这个宏仅仅是布尔值的简单替换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENABLE_DEBUG_LOG true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENABLE_DEBUG_LOG false</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接下来，把DLOG宏定义成一个问号表达式，为了便于理解，把这个定义分成多行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOG()                 \</span></span><br><span class="line">    ! ENABLE_DEBUG_LOG  ?      \</span><br><span class="line">        (<span class="keyword">void</span>)<span class="number">0</span>         :      \</span><br><span class="line">        Vodify() &amp; <span class="built_in">std</span>::<span class="built_in">cout</span></span><br></pre></td></tr></table></figure><p>问号表达式首先判断一下是否启用调试日志。如果不启用，则执行第一个分支，把0转换成void，也就是什么都不做。这是一种罕见的语法，可以把任意表达式转型为void。如果启用，则执行第二个分支，创建一个Vodify对象，并调用它的&amp;操作符。下面是Vodify类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vodify</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> <span class="built_in">std</span>::ostream&amp;) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Vodify类是一个辅助类，它只有一个空的operator&amp;方法，其作用仅仅是为了使问号表达式两个分支的返回值相同。由于前面一个分支的返回值是void，第二个分支的返回值也必须是void，否则编译不通过。</p><p>一个提供了&lt;&lt;操作符的输出流对象必须放在最后面，这是为了接收后面的输出参数。在这里简单使用了std::cout对象。Vodify的operator&amp;方法必须能够接收这个对象的引用。</p><p>现在，可以这样来使用DLOG：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLOG() &lt;&lt; <span class="string">"Today is "</span> &lt;&lt; <span class="number">2015</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">'.'</span>;</span><br></pre></td></tr></table></figure><p>这句代码展开之后变成了下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">! ENABLE_DEBUG_LOG  ?</span><br><span class="line">    (<span class="keyword">void</span>)<span class="number">0</span>         :</span><br><span class="line">    Vodify() &amp; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Today is "</span> &lt;&lt; <span class="number">2015</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">'.'</span>;</span><br></pre></td></tr></table></figure><p>如果ENABLE_DEBUG_LOG为true，那么第二个分支会执行。&lt;&lt;操作符的优先级比&amp;操作符高，后面的一串&lt;&lt;调用会先执行，最后再调用Vodify对象的&amp;操作符，使整个表达式的返回值为void。</p><p>如果ENABLE_DEBUG_LOG为false，那么第二个分支永远都不会执行，无论它有多复杂。这是在编译期间就可以确定的，在发行版的程序中这部分代码完全可以优化掉，也就达到了调试日志不影响发行版程序的目的。</p><p>基于以上的核心思想，可以衍变出各种不同的版本来支持更丰富的功能，例如日志等级、日志分类等。C++中有很多小技巧，使用得当的话对程序开发有很大帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志是一种有效的调试手段。但是日志写得太频繁会降低程序性能，所以一般采取的策略是，大部分日志只在调试版的程序中输出，少量重要的日志才在发行版的程序中输出。为了控制调试日志的输出，通常会使用下面的简便方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="流式输出" scheme="http://zplutor.github.io/tags/%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/"/>
    
      <category term="日志" scheme="http://zplutor.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>C++拼接SQL语句的高效方法</title>
    <link href="http://zplutor.github.io/2015/08/14/fast-way-to-concatenate-sql-in-cpp/"/>
    <id>http://zplutor.github.io/2015/08/14/fast-way-to-concatenate-sql-in-cpp/</id>
    <published>2015-08-14T06:18:32.000Z</published>
    <updated>2016-04-16T12:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>访问数据库的应用程序一般都通过字符串拼接的方式来构造SQL语句。例如，可以使用boost的format，或者类似的拼接方法：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sql = boost::str(boost::format(<span class="string">"select %1%, %2%, %3%, %4% from %5% where %1% = ?;"</span>)</span><br><span class="line">                             % kUserIdColumnName</span><br><span class="line">                             % kUserNameColumnName</span><br><span class="line">                             % kUserEmailColumnName</span><br><span class="line">                             % kUserPhoneColumnName</span><br><span class="line">                             % kUserTableName);         </span><br></pre></td></tr></table></figure><p>上面的例子构造了一条从用户信息表获取用户信息的SQL语句，这并没有什么问题。但仔细想想，在运行时构造SQL语句是毫无必要的，因为这种SQL语句基本上不会在程序运行的时候改变。假如每次查询都要进行这样的拼接过程，那么这部分的性能就白白浪费掉了。另一种做法是把sql变量定义成局部静态变量，这样只需要拼接一次就可以了。不过要是这段代码运行在并发环境中，还需要考虑线程安全的问题，这会带来一些额外的工作。</p><p>当然啦，这种重复构造字符串本身的开销是非常小的，一般不会造成性能问题。但如果你是完美主义者，希望榨干最后一滴性能，那么可以考虑一下下面介绍的方法。</p><p>这种方法基于C++的字符串语法糖：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span> = <span class="string">"Curlion is "</span> <span class="string">"a C++ wrapper"</span></span><br><span class="line">                     <span class="string">" for libcurl’s "</span>            <span class="string">"multi socket "</span></span><br><span class="line">                     <span class="string">"interface."</span>; </span><br></pre></td></tr></table></figure><p>上述语句等效于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span> = <span class="string">"Curlion is a C++ wrapper for libcurl’s multi socket interface."</span>;</span><br></pre></td></tr></table></figure><p>也就是说，如果两个字符串字面量之间只包含空白字符，那么它们会被合并成一个。这个合并发生在编译时，不消耗运行时时间。</p><p>为了使用这种拼接方式，我们首先要把表名和列名变量修改成用宏来定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kUserTableName <span class="meta-string">"user"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kUserIdColumnName <span class="meta-string">"id"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kUserNameColumnName <span class="meta-string">"name"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kUserEmailColumnName <span class="meta-string">"email"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kUserPhoneColumnName <span class="meta-string">"phone"</span></span></span><br></pre></td></tr></table></figure>    <p>然后就可以修改拼接方式了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* sql = <span class="string">"select "</span></span><br><span class="line">                  kUserIdColumnName <span class="string">", "</span></span><br><span class="line">                  kUserNameColumnName <span class="string">", "</span></span><br><span class="line">                  kUserEmailColumnName <span class="string">", "</span></span><br><span class="line">                  kUserEmailColumnName <span class="string">", "</span></span><br><span class="line">                  kUserPhoneColumnName</span><br><span class="line">                  <span class="string">" from "</span> kUserTableName</span><br><span class="line">                  <span class="string">" where "</span> kUserIdColumnName <span class="string">" = ?;"</span>;</span><br></pre></td></tr></table></figure>    <p>这样一来，sql相当于一个常量，不需要初始化，完全不消耗运行时的性能。另外，这么做也有一个好处，就是使得SQL语句的可读性有了一定提高。使用format的方法经常要手工一个个地去匹配参数列表，很繁琐也容易出错。特别是那些有一串长长的参数列表的复杂语句，看起来很恐怖。现在这种方法则好得多，参数直接放在了它所在的位置，一目了然。</p><p>使用宏来定义表名和列名可能会令人感到不安。但我觉得这是宏的合理使用，不会带来什么不良后果，因为表名和列名基本上只会用于SQL语句拼接的场景。有时候为了追求性能或者其他方面的目标，的确要牺牲一些代码的“观赏性”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;访问数据库的应用程序一般都通过字符串拼接的方式来构造SQL语句。例如，可以使用boost的format，或者类似的拼接方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="字符串" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="SQL" scheme="http://zplutor.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>如何设置libcurl的动态超时值</title>
    <link href="http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/"/>
    <id>http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/</id>
    <published>2015-05-22T08:53:03.000Z</published>
    <updated>2016-04-16T12:26:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>针对连接超时，libcurl提供了两个设置选项，分别是CURLOPT_CONNECTTIMEOUT和CURLOPT_TIMEOUT。CURLOPT_CONNECTTIMEOUT设置的是连接阶段的超时值，而CURLOPT_TIMEOUT设置的是整个连接从开始到结束的超时值。libcurl把连接阶段的超时独立出来是好事，它给予了调用者更多的控制权，提高灵活性。但让人不解的是，libcurl没有提供动态超时值的设置，而只能设置固定的超时值。</p><a id="more"></a><p>所谓动态超时值，指的是允许连接空闲的最大时间值，也就是说，只有当连接没有数据传输的时候才开始计算超时时间。这也是平常说的超时的含义。正如上文所说，libcurl对超时的定义是允许连接执行的时间，这个定义在实际应用中会带来问题。例如，每个连接要传输的数据量是不一样的，为了让所有连接都能够正常执行，需要在执行之前计算出确切的超时值。然而这几乎不可能做到，因为网络环境时刻在变化，前一刻计算出来的超时值很快就不合适了。虽然固定超时值也有它特有的用途，但在绝大部分情况下它都不是我们想要的。</p><p>好在libcurl提供了很高的灵活性，我们可以借助另外两个设置选项，变通地实现动态超时值。这两个设置选项是CURLOPT_LOW_SPEED_LIMIT和CURLOPT_LOW_SPEED_TIME，它们的含义是：当连接以低于CURLOPT_LOW_SPEED_LIMIT的速率执行了CURLOPT_LOW_SPEED_TIME的时间时，它就会被终止。一个微妙的地方是，当连接由于这个原因被终止时，它的错误码是CURLE_OPERATION_TIMEOUT。与其说是巧合，倒不如说这是libcurl特意为动态超时值提供的一个更灵活的接口。</p><p>通过这两个设置选项，可以这样来设置动态超时值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(curl_handle, CURLOPT_LOW_SPEED_LIMIT, <span class="number">1</span>);</span><br><span class="line">curl_easy_setopt(curl_handle, CURLOPT_LOW_SPEED_TIME, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>要注意的是，CURLOPT_LOW_SPEED_LIMIT的单位是字节/秒，CURLOPT_LOW_SPEED_TIME的单位是秒。这样一来，若在10秒内连接的速率都是低于1字节/秒（也就是无数据传输），它就被认为超时了。</p><p>如何设置动态超时值的问题到这里就结束了。但是显然还有另一个问题值得深究：连接的速率是怎么计算的呢？官方文档并没有解释清楚，不过既然libcurl是开源的，那么可以从它的源代码中寻找答案。检查速率的代码位于speedcheck.c的Curl_speedcheck函数中；计算速率的代码位于progress.c的Curl_pgrsUpdate函数中。下面简单解释一下计算速率的过程。</p><p>libcurl使用一个长度为5的循环数组来记录速率信息，速率信息包含了当前时间以及当前总数据量，总数据量取的是总下载数据量和总上传数据量的最大值。每隔一秒钟libcurl就会记录当前的速率信息；由于使用了循环数组，最旧的信息会被丢弃。例如，在第四秒时候，循环数组里的内容是这样的：</p><img src="/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/1.png"><p>第七秒的时候，循环数组里的内容是这样的：</p><img src="/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/2.png"><p>以此类推。接下来，会使用最新的速率信息和最旧的速率信息来计算速率。例如，在第四秒时，速率是这样算的：</p><pre><code>(total4 - total1) / (time4 - time1)</code></pre><p>在第七秒时，速率是这样算的：</p><pre><code>(total7 - total3) / (time7 - time3)</code></pre><p>总之，连接的速率指的是在最近至多五秒内的平均速率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;针对连接超时，libcurl提供了两个设置选项，分别是CURLOPT_CONNECTTIMEOUT和CURLOPT_TIMEOUT。CURLOPT_CONNECTTIMEOUT设置的是连接阶段的超时值，而CURLOPT_TIMEOUT设置的是整个连接从开始到结束的超时值。libcurl把连接阶段的超时独立出来是好事，它给予了调用者更多的控制权，提高灵活性。但让人不解的是，libcurl没有提供动态超时值的设置，而只能设置固定的超时值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="libcurl" scheme="http://zplutor.github.io/tags/libcurl/"/>
    
      <category term="超时" scheme="http://zplutor.github.io/tags/%E8%B6%85%E6%97%B6/"/>
    
  </entry>
  
</feed>
