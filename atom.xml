<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zplutor&#39;s</title>
  
  
  <link href="http://zplutor.github.io/atom.xml" rel="self"/>
  
  <link href="http://zplutor.github.io/"/>
  <updated>2023-05-02T08:01:08.485Z</updated>
  <id>http://zplutor.github.io/</id>
  
  <author>
    <name>Zplutor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何正确地实现QueryInterface</title>
    <link href="http://zplutor.github.io/2023/05/02/how-to-properly-implement-queryinterface/"/>
    <id>http://zplutor.github.io/2023/05/02/how-to-properly-implement-queryinterface/</id>
    <published>2023-05-02T07:49:24.000Z</published>
    <updated>2023-05-02T08:01:08.485Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows编程中，在与系统组件打交道时，我们会经常用到COM接口，对于 <code>QueryInterface()</code> 函数不会感到陌生。相较之下，实现COM接口的需求少得多，一旦需要我们自己来实现COM接口，缺乏经验者很可能会在一些平时不会注意到的问题上碰壁。我最近就在实现 <code>QueryInterface()</code> 的时候遇到了一点麻烦，花了不少时间来排查，最终发现起因原来只是一个低级错误。</p><span id="more"></span><p>事情的背景是这样的：我要往RichEdit中插入一个OLE对象，需要实现一个自定义的类，这个类要实现 <code>IOleObject</code> 和 <code>IViewObject</code> 两个COM接口。我仿照从其它地方找到的示例，实现了这样的 <code>QueryInterface()</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyOLEObject</span> : <span class="keyword">public</span> IOleObject, <span class="keyword">public</span> IViewObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">HRESULT <span class="title">QueryInterface</span><span class="params">(REFIID riid, LPVOID* ppvObj)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ppvObj) &#123;</span><br><span class="line">            <span class="keyword">return</span> E_INVALIDARG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (riid == IID_IUnknown || </span><br><span class="line">            riid == IID_IOleObject || </span><br><span class="line">            riid == IID_IViewObject) &#123;</span><br><span class="line"></span><br><span class="line">            *ppvObj = (<span class="type">void</span>*)<span class="keyword">this</span>;</span><br><span class="line">            <span class="built_in">AddRef</span>();</span><br><span class="line">            <span class="keyword">return</span> S_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppvObj = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> E_NOINTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个实现看上去没什么问题， <code>MyOLEObject</code> 仅支持 <code>IUnknown</code> 、 <code>IOleObject</code> 和 <code>IViewObject</code> 三个COM接口，所以判断 <code>riid</code> 是这三个接口的ID就返回this，很合理。</p><p>但是程序一运行起来就出现奇怪的问题，每当插入这个OLE对象的时候， <code>IOleObject</code> 的 <code>SetClientSite()</code> 函数会被调用，传进来的指针的值居然是1，导致我一用到这个指针，程序就崩溃了。 </p><img src="/2023/05/02/how-to-properly-implement-queryinterface/1.png" class=""><p>我百思不得其解，排查了很久之后才发现是 <code>QueryInterface()</code> 的实现错了，正确的实现应该是下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyOLEObject</span> : <span class="keyword">public</span> IOleObject, <span class="keyword">public</span> IViewObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">HRESULT <span class="title">QueryInterface</span><span class="params">(REFIID riid, LPVOID* ppvObj)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ppvObj) &#123;</span><br><span class="line">            <span class="keyword">return</span> E_INVALIDARG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (riid == IID_IUnknown || riid == IID_IOleObject) &#123;</span><br><span class="line">            *ppvObj = <span class="built_in">static_cast</span>&lt;IOleObject*&gt;(<span class="keyword">this</span>);</span><br><span class="line">            <span class="built_in">AddRef</span>();</span><br><span class="line">            <span class="keyword">return</span> S_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (riid == IID_IViewObject) &#123;</span><br><span class="line">            *ppvObj = <span class="built_in">static_cast</span>&lt;IViewObject*&gt;(<span class="keyword">this</span>);</span><br><span class="line">            <span class="built_in">AddRef</span>();</span><br><span class="line">            <span class="keyword">return</span> S_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppvObj = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> E_NOINTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个实现把 <code>IViewObject</code> 的判断单独分离出来，并且先把this转换成了 <code>IViewObject*</code> 再返回。</p><p>这背后的原因是：多重继承导致类对象的内存布局发生变化，this并不等于 <code>IViewObject*</code> ，所以不能直接将this作为 <code>IViewObject*</code> 返回。</p><p>我们先来看一下 <code>MyOLEObject</code> 的继承关系图：</p><img src="/2023/05/02/how-to-properly-implement-queryinterface/2.png" class=""><p>这是一个菱形的继承结构，在这个结构下 <code>MyOLEObject</code> 对象的内存布局是这样的：</p><img src="/2023/05/02/how-to-properly-implement-queryinterface/3.png" class=""><p>绿色部分是继承自 <code>IOleObject</code> 的数据，蓝色部分是继承自 <code>IViewObject</code> 的数据，白色部分是 <code>MyOLEObject</code> 自己的数据。由于基类都是COM接口，所以绿色和蓝色每个格子的数据实际上只含一个虚函数表指针。</p><p>从图中可以看出，this和 <code>IOleObject*</code> 都指向相同的绿色部分，所以在 <code>QueryInterface()</code> 内，如果 <code>riid</code> 是这个接口的ID，可以直接返回this。但是 <code>IViewObject*</code> 指向的是蓝色部分，跟this不一样，所以不能直接返回this。在一开始错误的实现中，我把this强制转型成 <code>void*</code> 返回，返回的是绿色部分的数据，即把 <code>IOleObject</code> 错当成了 <code>IViewObject</code> 返回。当外部调用 <code>IViewObject</code> 的函数时，就会错误地调用到了 <code>IOleObject</code> 的函数，所以参数的值都是错乱的。</p><p>而在正确的实现中，我通过 <code>static_cast</code> 将this转换成 <code>IViewObject*</code> ，编译器会正确地取出指向蓝色部分的指针。</p><p>最后再提一下 <code>IUnknown</code> 。由于 <code>IOleObject</code> 和 <code>IViewObject</code> 各自继承了 <code>IUnknown</code> ，所以在最终的对象内存在两份 <code>IUnknown</code> 的数据，即有两个 <code>IUnknown</code> 的虚函数表指针，它们其实都指向同一份函数实现，所以理论上在 <code>QueryInterface()</code> 内返回任意一个 <code>IUnknown*</code> 都是可以的。但是要注意以下写法会导致编译失败：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*ppvObj = <span class="built_in">static_cast</span>&lt;IUnknown*&gt;(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>因为编译器不知道应该使用哪一份 <code>IUnknown</code> 数据，我们必须显式地指定，要么用 <code>IOleObject</code> 的，要么用 <code>IViewObject</code> 的。</p><p>综上所述，当我们在实现 <code>QueryInterface()</code> 函数的时候，正确的做法是依次将this转型成对应的COM接口指针再返回，而不是一刀切地强制转型成 <code>void*</code> 来返回。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Windows编程中，在与系统组件打交道时，我们会经常用到COM接口，对于 &lt;code&gt;QueryInterface()&lt;/code&gt; 函数不会感到陌生。相较之下，实现COM接口的需求少得多，一旦需要我们自己来实现COM接口，缺乏经验者很可能会在一些平时不会注意到的问题上碰壁。我最近就在实现 &lt;code&gt;QueryInterface()&lt;/code&gt; 的时候遇到了一点麻烦，花了不少时间来排查，最终发现起因原来只是一个低级错误。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
  </entry>
  
  <entry>
    <title>在Windowless RichEdit中插入OLE对象</title>
    <link href="http://zplutor.github.io/2023/04/15/insert-ole-object-into-windowless-rich-edit/"/>
    <id>http://zplutor.github.io/2023/04/15/insert-ole-object-into-windowless-rich-edit/</id>
    <published>2023-04-15T12:38:53.000Z</published>
    <updated>2023-04-15T14:07:07.531Z</updated>
    
    <content type="html"><![CDATA[<p>RichEdit支持在文本中插入OLE对象，OLE对象中可以显示任意自定义的内容，从而达到丰富的显示效果，例如文字和图片在同一行中混合显示。本文在<a href="http://zplutor.github.io/2015/12/06/implement-an-editable-windowless-richedit/">《实现一个可编辑的Windowless RichEdit》</a>一本的基础上，介绍如何在Windowless RichEdit中插入OLE对象。完整的示例代码可以在 <a href="https://github.com/Zplutor/WindowlessRichEdit-Example">WindowlessRichEdit-Example</a> 获得。</p><span id="more"></span><h2 id="实现自定义的OLE对象"><a href="#实现自定义的OLE对象" class="headerlink" title="实现自定义的OLE对象"></a>实现自定义的OLE对象</h2><p>在插入OLE对象之前，我们首先要实现一个自定义的OLE对象。这个对象必须实现以下两个COM接口：</p><ul><li><code>IOleObject</code>，所有OLE对象都需要实现的基础接口。</li><li><code>IViewObject</code>，用于显示OLE对象的接口。</li></ul><p><code>IOleObject</code> 有不少虚函数需要实现，但其实所有函数都可以不实现，全都返回 <code>E_NOTIMPL</code> 也是可以的。在本文的例子中，OLE对象仅用于显示，没有任何行为，所以对于<code>IOleObject</code>的所有函数都返回了 <code>E_NOTIMPL</code>。</p><p><code>IViewObject</code> 只有一个 <code>Draw()</code> 函数需要实现，用来绘制OLE对象的内容。其它函数都可以不实现，返回 <code>E_NOTIMPL</code> 即可。 <code>Draw()</code> 的参数列表比较长：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">Draw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwDrawAspect,</span></span></span><br><span class="line"><span class="params"><span class="function">    LONG lindex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* pvAspect,</span></span></span><br><span class="line"><span class="params"><span class="function">    DVTARGETDEVICE* ptd,</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdcTargetDev,</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdcDraw,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCRECTL lprcBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCRECTL lprcWBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL(*pfnContinue)(ULONG_PTR dwContinue),</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG_PTR dwContinue</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>大部分参数用于复杂的OLE对象或者特殊的绘制场景（例如打印机），对于简单的OLE对象，通常只需要关注 <code>hdcDraw</code> 和 <code>lprcBounds</code> 这两个参数就可以了。<code>hdcDraw</code> 表示用于绘制的设备句柄， <code>lprcBounds</code> 表示OLE对象在 <code>hdcDraw</code> 中的绘制区域，我们只能在这个区域中进行绘制。</p><p>在这个示例的OLE对象中，我们只是简单地将OLE对象填充成蓝色，以显示它的存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyOLEObject</span> : <span class="keyword">public</span> IOleObject, <span class="keyword">public</span> IViewObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">HRESULT <span class="title">Draw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dwDrawAspect,</span></span></span><br><span class="line"><span class="params"><span class="function">        LONG lindex,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* pvAspect,</span></span></span><br><span class="line"><span class="params"><span class="function">        DVTARGETDEVICE* ptd,</span></span></span><br><span class="line"><span class="params"><span class="function">        HDC hdcTargetDev,</span></span></span><br><span class="line"><span class="params"><span class="function">        HDC hdcDraw,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPCRECTL lprcBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPCRECTL lprcWBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">        BOOL(*pfnContinue)(ULONG_PTR dwContinue),</span></span></span><br><span class="line"><span class="params"><span class="function">        ULONG_PTR dwContinue)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        HBRUSH brush = <span class="built_in">CreateSolidBrush</span>(<span class="built_in">RGB</span>(<span class="number">0xaa</span>, <span class="number">0xcc</span>, <span class="number">0xee</span>));</span><br><span class="line">        <span class="built_in">FillRect</span>(hdcDraw, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> RECT*&gt;(lprcBounds), brush);</span><br><span class="line">        <span class="built_in">DeleteObject</span>(brush);</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其它函数实现...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意， <code>lprcBounds</code> 的类型是 <code>RECTL</code> 指针，而 <code>FillRect</code> 的参数类型是 <code>RECT</code> 指针，虽然两者的类型不一样，但内存布局实际上是一样的，所以可以直接将 <code>lprcBounds</code> 转成 <code>RECT</code> 指针。</p><p>此外，我们要给这个OLE对象定义一个类ID，在插入的时候要用到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> GUID CLSID_MyOLEObject = &#123; </span><br><span class="line">    <span class="number">0xe16f8acd</span>, </span><br><span class="line">    <span class="number">0x5b3a</span>, </span><br><span class="line">    <span class="number">0x4167</span>, </span><br><span class="line">    &#123; <span class="number">0xa4</span>, <span class="number">0x49</span>, <span class="number">0xdc</span>, <span class="number">0x57</span>, <span class="number">0xd</span>, <span class="number">0xd4</span>, <span class="number">0x44</span>, <span class="number">0x59</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="插入OLE对象"><a href="#插入OLE对象" class="headerlink" title="插入OLE对象"></a>插入OLE对象</h2><p>接下来，就可以往RichEdit中插入这个OLE对象了。插入OLE对象大致上需要两步：</p><ul><li>给RichEdit发送 <code>EM_GETOLEINTERFACE</code> 消息，获取 <code>IRichEditOle</code> 接口，这个接口提供了一系列用于操作OLE对象的函数。</li><li>调用 <code>IRichEditOle</code> 的 <code>InsertObject()</code> 函数，插入OLE对象。</li></ul><p><code>InsertObject</code> 的参数是一个 <code>REOBJECT</code> 结构，我们需要填充这个结构的字段：</p><ul><li><code>cbStruct</code> ，结构的大小，填 <code>sizeof(REOBJECT)</code> 即可。</li><li><code>cp</code> ，OLE对象的插入位置，填0插入到文本第一个字符的位置，填1插入到第二字符的位置，以此类推。可以填常量 <code>REO_CP_SELECTION</code> ，表示插入到当前光标选中的位置。</li><li><code>clsid</code> ，OLE对象的类ID，填上文中定义的 <code>CLSID_MyOLEObject</code> 。</li><li><code>poleobj</code> ，要插入的OLE对象的指针。注意，OLE对象插入后，RichEdit会调用 <code>AddRef()</code> 来增加它的引用计数，所以在插入之后我们要调用 <code>Release()</code> 来减少引用计数，避免内存泄露。</li><li><code>pstg</code> ， <code>IStorage</code> 接口的指针，一般不需要设置，传 <code>nullptr</code> 即可。</li><li><code>polesite</code> ， <code>IOleClientSite</code> 接口的指针，用于OLE对象与其所在的容器进行交互。调用 <code>IRichEditOle</code> 的 <code>GetClientSite()</code> 函数获取这个指针并传入即可。</li><li><code>sizel</code>，OLE对象的大小，注意这个大小是以HIMETRIC为单位，即0.01毫米。可以使用 <code>AtlPixelToHiMetric()</code> 函数将像素大小转换成HIMETRIC大小。</li><li><code>dvaspect</code> ，使用哪个“外表”来绘制OLE对象，一个OLE对象可能有多个外表，例如缩略图、图标等。普通的OLE对象通常只有一个默认的外表，填 <code>DVASPECT_CONTENT</code> 即可。</li><li><code>dwFlags</code>，OLE对象的一些属性设置。常用的有两个：<ul><li><code>REO_BELOWBASELINE</code> 表示OLE对象的底部与文字的底部对齐。如果没有这个设置，OLE对象的底部会与文字基线对齐，这会导致OLE对象的位置偏上。</li><li><code>REO_OWNERDRAWSELECT</code> 表示OLE对象的选中态由自己来绘制。如果没有这个设置，OLE对象在被选中的时候，会以反色来显示（如白变黑），这通常不是我们想要的效果，所以要加上这个设置，我们自己来绘制被选中时的样式。</li></ul></li><li><code>dwUser</code> ，一个自定义的数值，跟当前插入的OLE对象绑定，一般用不到。</li></ul><p>以下是插入OLE对象的代码片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从TextService取出IRichEditOle接口</span></span><br><span class="line">CComPtr&lt;IRichEditOle&gt; rich_edit_ole&#123;&#125;;</span><br><span class="line">g_text_service-&gt;<span class="built_in">TxSendMessage</span>(EM_GETOLEINTERFACE, <span class="number">0</span>, (LPARAM)&amp;rich_edit_ole, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出IOleClientSite接口</span></span><br><span class="line">CComPtr&lt;IOleClientSite&gt; client_site&#123;&#125;;</span><br><span class="line">rich_edit_ole-&gt;<span class="built_in">GetClientSite</span>(&amp;client_site);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建要插入的OLE对象</span></span><br><span class="line">CComPtr&lt;MyOLEObject&gt; ole_object;</span><br><span class="line">ole_object.<span class="built_in">Attach</span>(<span class="keyword">new</span> <span class="built_in">MyOLEObject</span>(g_text_service));</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充REOBJECT的字段</span></span><br><span class="line">REOBJECT object_info&#123;&#125;;</span><br><span class="line">object_info.cbStruct = <span class="built_in">sizeof</span>(object_info);</span><br><span class="line">object_info.clsid = CLSID_MyOLEObject;</span><br><span class="line">object_info.poleobj = ole_object;</span><br><span class="line">object_info.polesite = client_site;</span><br><span class="line">object_info.pstg = <span class="literal">nullptr</span>;</span><br><span class="line">object_info.dvaspect = DVASPECT_CONTENT;</span><br><span class="line">object_info.cp = REO_CP_SELECTION;</span><br><span class="line">object_info.dwFlags = REO_BELOWBASELINE | REO_OWNERDRAWSELECT;</span><br><span class="line"></span><br><span class="line">SIZEL size_in_pixels&#123;&#125;;</span><br><span class="line">size_in_pixels.cx = MyOLEObject::Width;</span><br><span class="line">size_in_pixels.cy = MyOLEObject::Height;</span><br><span class="line"><span class="built_in">AtlPixelToHiMetric</span>(&amp;size_in_pixels, &amp;object_info.sizel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入OLE对象</span></span><br><span class="line">rich_edit_ole-&gt;<span class="built_in">InsertObject</span>(&amp;object_info);</span><br></pre></td></tr></table></figure><h2 id="判断OLE对象是否被选中"><a href="#判断OLE对象是否被选中" class="headerlink" title="判断OLE对象是否被选中"></a>判断OLE对象是否被选中</h2><p>我们在插入OLE对象的时候指定了 <code>REO_OWNERDRAWSELECT</code> 设置，意味着我们需要自己来绘制OLE对象的选中态。现在，不论该OLE对象是否被选中，都显示同样的蓝色，没有区分度。所以，接下来要修改 <code>Draw()</code> 函数的实现，在OLE对象被选中时显示不同的颜色。</p><p>RichEdit没有任何接口或者通知可以直接告诉我们OLE对象是否被选中，所以我们只能自己去判断。判断的方法如下：</p><ul><li>给RichEdit发送 <code>EM_EXGETSEL</code> 消息，获取当前选中的范围。</li><li>调用 <code>IRichEditOle</code> 的 <code>GetObjectCount()</code> 和 <code>GetObject()</code> 函数，遍历取出每一个OLE对象的位置，如果遍历到的OLE对象就是当前对象，再看看是否在选中的范围中。</li></ul><p>以下是判断OLE对象是否被选中的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyOLEObject::IsSelected</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出选中的范围</span></span><br><span class="line">    CHARRANGE select_range&#123;&#125;;</span><br><span class="line">    text_service_-&gt;<span class="built_in">TxSendMessage</span>(EM_EXGETSEL, <span class="number">0</span>, <span class="built_in">reinterpret_cast</span>&lt;LPARAM&gt;(&amp;select_range), <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有选中范围，当前对象自然也没有被选中</span></span><br><span class="line">    <span class="keyword">if</span> (select_range.cpMin == select_range.cpMax) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CComPtr&lt;IRichEditOle&gt; rich_edit_ole&#123;&#125;;</span><br><span class="line">    text_service_-&gt;<span class="built_in">TxSendMessage</span>(EM_GETOLEINTERFACE, <span class="number">0</span>, (LPARAM)&amp;rich_edit_ole, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有OLE对象</span></span><br><span class="line">    <span class="keyword">auto</span> object_count = rich_edit_ole-&gt;<span class="built_in">GetObjectCount</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; object_count; ++index) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出OLE对象</span></span><br><span class="line">        REOBJECT object_info&#123;&#125;;</span><br><span class="line">        object_info.cbStruct = <span class="built_in">sizeof</span>(object_info);</span><br><span class="line">        HRESULT hresult = rich_edit_ole-&gt;<span class="built_in">GetObject</span>(index, &amp;object_info, REO_GETOBJ_POLEOBJ);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hresult)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//OLE对象取出来之后需要释放它的引用计数，这里使用CComPtr来自动释放</span></span><br><span class="line">        CComPtr&lt;IOleObject&gt; ole_object;</span><br><span class="line">        ole_object.<span class="built_in">Attach</span>(object_info.poleobj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到当前OLE对象了</span></span><br><span class="line">        <span class="keyword">if</span> (ole_object.p == <span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前OLE对象的位置在选中范围内，也就意味着它被选中了</span></span><br><span class="line">            <span class="keyword">if</span> ((select_range.cpMin == <span class="number">0</span> &amp;&amp; select_range.cpMax == <span class="number">-1</span>) ||</span><br><span class="line">                (select_range.cpMin &lt;= object_info.cp &amp;&amp; object_info.cp &lt; select_range.cpMax)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在选中范围外，没被选中</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没找到当前的OLE对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IRichEditOle</code> 的 <code>GetObject()</code> 也需要传入 <code>REOBJECT</code> 结构，不过此时只需要设置 <code>cbStruct</code> 字段即可，其它字段都由该函数来填充。调用成功后， <code>REOBJECT</code> 的 <code>cp</code> 字段表示OLE对象在文本中的位置，将其与选中范围比较即可知道它是否被选中了。如果文本被全选了， <code>CHARRANGE</code> 的 <code>cpMin</code> 是0， <code>cpMax</code> 是-1，所以比较的时候要区分两种场景。</p><p>虽然 <code>REOBJECT</code> 的 <code>dwFlags</code> 字段有一个 <code>REO_SELECTED</code> 的值，似乎可以用来判断OLE对象是否被选中，但这个值只有在OLE对象被单独选中的时候才会设置，如果选中的是一段文字和OLE对象，则不会设置，所以不能依赖这个值。</p><p>调用 <code>GetObject()</code> 的时候，最后一个参数传入 <code>REO_GETOBJ_POLEOBJ</code> ， <code>REOBJECT</code> 中才会填充 <code>poleobj</code> 字段。这个指针是增加了引用计数的，所以用完之后我们要手动地减少它的引用计数。在上面的代码中，使用了 <code>CComPtr</code> 来自动释放。</p><p>以下是修改后的 <code>Draw()</code> 函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">MyOLEObject::Draw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwDrawAspect,</span></span></span><br><span class="line"><span class="params"><span class="function">    LONG lindex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* pvAspect,</span></span></span><br><span class="line"><span class="params"><span class="function">    DVTARGETDEVICE* ptd,</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdcTargetDev,</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdcDraw,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCRECTL lprcBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCRECTL lprcWBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL(*pfnContinue)(ULONG_PTR dwContinue),</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG_PTR dwContinue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> background_color = <span class="built_in">IsSelected</span>() ? <span class="built_in">RGB</span>(<span class="number">0x88</span>, <span class="number">0xaa</span>, <span class="number">0xcc</span>) : <span class="built_in">RGB</span>(<span class="number">0xaa</span>, <span class="number">0xcc</span>, <span class="number">0xee</span>);</span><br><span class="line">    HBRUSH brush = <span class="built_in">CreateSolidBrush</span>(background_color);</span><br><span class="line">    <span class="built_in">FillRect</span>(hdcDraw, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> RECT*&gt;(lprcBounds), brush);</span><br><span class="line">    <span class="built_in">DeleteObject</span>(brush);</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改鼠标光标的样式"><a href="#修改鼠标光标的样式" class="headerlink" title="修改鼠标光标的样式"></a>修改鼠标光标的样式</h2><p>OLE对象并不是文字，但RichEdit在某些时候仍然会将它当做文字来对待。例如，当鼠标移动到OLE对象之上时，光标仍然会显示成 <code>I</code> 样式，但在大部分情况下我们希望它显示成默认的箭头样式。</p><p>为了修改鼠标光标在OLE对象上的样式，我们要在处理 <code>WM_SETCURSOR</code> 消息，在调用 <code>ITextServices</code> 的 <code>OnTxSetCursor()</code> 之前（详情可参考<a href="http://zplutor.github.io/2015/12/06/implement-an-editable-windowless-richedit/">《实现一个可编辑的Windowless RichEdit》</a>），判断鼠标是否位于OLE对象之上。判断的方法如下：</p><ul><li>调用 <code>IRichEditOle</code> 的 <code>QueryInterface()</code> 函数，取出它的 <code>ITextDocument</code> 接口。</li><li>调用 <code>ITextDocument</code> 的 <code>RangeFromPoint()</code> 函数，根据鼠标位置取出最接近的文本，返回的是 <code>ITextRange</code> 接口。</li><li>调用 <code>ITextRange</code> 的 <code>GetEmbeddedObject()</code> 函数，取出OLE对象。如果返回空指针，则说明鼠标不在OLE对象上，反之则在OLE对象上。</li></ul><p>以下是获取鼠标位置之下的OLE对象的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CComPtr&lt;MyOLEObject&gt; <span class="title">GetOLEObjectAtMouseCursor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取鼠标在屏幕上的位置</span></span><br><span class="line">    POINT position&#123;&#125;;</span><br><span class="line">    <span class="built_in">GetCursorPos</span>(&amp;position);</span><br><span class="line"></span><br><span class="line">    CComPtr&lt;IRichEditOle&gt; rich_edit_ole;</span><br><span class="line">    g_text_service-&gt;<span class="built_in">TxSendMessage</span>(EM_GETOLEINTERFACE, <span class="number">0</span>, (LPARAM)&amp;rich_edit_ole, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出ITextDocument接口</span></span><br><span class="line">    CComPtr&lt;ITextDocument&gt; text_document;</span><br><span class="line">    HRESULT hresult = rich_edit_ole-&gt;<span class="built_in">QueryInterface</span>(IID_ITextDocument, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;text_document));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hresult)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出最接近鼠标的文本</span></span><br><span class="line">    CComPtr&lt;ITextRange&gt; text_range;</span><br><span class="line">    hresult = text_document-&gt;<span class="built_in">RangeFromPoint</span>(position.x, position.y, &amp;text_range);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hresult)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出文本中的OLE对象</span></span><br><span class="line">    CComPtr&lt;IUnknown&gt; ole_object;</span><br><span class="line">    hresult = text_range-&gt;<span class="built_in">GetEmbeddedObject</span>(&amp;ole_object);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hresult)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CComPtr&lt;MyOLEObject&gt; <span class="title">my_ole_object</span><span class="params">(<span class="keyword">dynamic_cast</span>&lt;MyOLEObject*&gt;(ole_object.p))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> my_ole_object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>ITextDocument</code> 的 <code>RangeFromPoint()</code> 函数使用的是屏幕坐标，调用 <code>GetCursorPos()</code> 来拿鼠标位置刚刚好。此外，RichEdit会调用 <code>ITextHost</code> 的 <code>TxScreenToClient()</code> 函数来将屏幕坐标转换成客户区坐标，所以我们也要实现这个函数，简单地调用 <code>ScreenToClient()</code> 即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyTextHost::TxScreenToClient</span><span class="params">(LPPOINT lppt)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ScreenToClient</span>(hwnd_, lppt);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意，<code>RangeFromPoint()</code> 函数在旧版本的RichEdit中存在bug，取到的文本不准。具体表现是：当坐标位于OLE对象的后半部分时，取到的是下一个位置的文本；只有坐标位于OLE对象的前半部分时才能取到正确的文本。最新的RichEdit 4.0没有这个问题，所以建议尽可能使用新版本的RichEdit。只要在调用 <code>LoadLibrary()</code> 的时候指定 <code>msftedit.dll</code> 即可使用最新版本的RichEdit：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用最新版本的RichEdit</span></span><br><span class="line">HMODULE module_handle = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;msftedit.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用旧版本的RichEdit</span></span><br><span class="line">HMODULE module_handel = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;riched20.dll&quot;</span>);</span><br></pre></td></tr></table></figure><p>可参考 <a href="https://learn.microsoft.com/en-us/windows/win32/controls/about-rich-edit-controls">About Rich Edit Controls</a> 以获取更多关于RichEdit版本的信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RichEdit支持在文本中插入OLE对象，OLE对象中可以显示任意自定义的内容，从而达到丰富的显示效果，例如文字和图片在同一行中混合显示。本文在&lt;a href=&quot;http://zplutor.github.io/2015/12/06/implement-an-editable-windowless-richedit/&quot;&gt;《实现一个可编辑的Windowless RichEdit》&lt;/a&gt;一本的基础上，介绍如何在Windowless RichEdit中插入OLE对象。完整的示例代码可以在 &lt;a href=&quot;https://github.com/Zplutor/WindowlessRichEdit-Example&quot;&gt;WindowlessRichEdit-Example&lt;/a&gt; 获得。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
    <category term="RichEdit" scheme="http://zplutor.github.io/tags/RichEdit/"/>
    
  </entry>
  
  <entry>
    <title>C++20协程入门教程</title>
    <link href="http://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/"/>
    <id>http://zplutor.github.io/2022/03/25/cpp-coroutine-beginner/</id>
    <published>2022-03-24T16:05:57.000Z</published>
    <updated>2022-03-26T05:45:22.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>随着Visual Studio 2022的发布，C++20终于来到了我们的眼前，在这个标准的新特性之中，最吸引人之一的是协程，对于饱受异步调用之繁琐写法的人来说，协程似乎是解决异步问题的灵丹妙药。</p><span id="more"></span><p>最初我对协程一无所知，当我开始学习它的时候，才发现它的复杂程度超出了我的预期。在网络上关于C++协程的文章有很多，但能够从初学者的角度把协程的基础原理讲清楚的寥寥无几。而且在 <a href="http://cppreference.com/">cppreference.com</a> 上关于协程的页面仍然是未完成的状态，不少组件的文档仍然是空缺的。</p><p>在这样的背景下，学习过程是比较曲折的。我阅读了各种不同的文章，运行并调试其中的示例代码，最终才理解了C++的协程是怎么回事。在这篇文章中，我将自己的学习经历作为参考，从入门的角度来介绍C++协程。希望这篇文章能帮助大家更容易学习和理解协程。</p><h2 id="2-什么是协程"><a href="#2-什么是协程" class="headerlink" title="2. 什么是协程"></a>2. 什么是协程</h2><p>学习协程遇到的第一个问题是：什么是协程？一个简短的回答是：协程是一个函数，它可以暂停以及恢复执行。按照我们对普通函数的理解，函数暂停意味着线程停止运行了（就像命中了断点一样），那协程的不同之处在哪里呢？区别在于，普通函数是线程相关的，函数的状态跟线程紧密关联；而协程是线程无关的，它的状态与任何线程都没有关系。</p><p>这个解释比较抽象，为了更好地理解，我们先来回顾一下函数的调用机制。在调用一个函数的时候，线程的栈上会记录这个函数的状态（参数、局部变量等），这是通过移动栈顶指针来完成的。例如，函数 <code>Foo()</code> 调用 <code>Bar()</code> 的过程如下所示：</p><img src="/2022/03/25/cpp-coroutine-beginner/1.png" class=""><p>首先，“地址3”到“地址2”这段空间，是分配给 <code>Foo()</code> 保存状态使用的，栈顶指针指向“地址2”；当调用 <code>Bar()</code> 的时候，栈顶指针移动到“地址1”，此时“地址2”到“地址1”这段空间是分配给 <code>Bar()</code> 保存状态使用的。当 <code>Bar()</code> 执行完毕，栈顶指针移动回“地址2”， <code>Bar()</code> 的状态被销毁，内存空间被回收。</p><p>由此可见，函数状态的维护完全依赖于线程栈，脱离了线程，函数就不复存在，所以说函数是线程相关的。</p><p>而协程不一样，协程的状态是保存在堆内存上的。假设 <code>Bar()</code> 是一个协程，那么调用它的过程如下所示：</p><img src="/2022/03/25/cpp-coroutine-beginner/2.png" class=""><p>首先， <code>Bar()</code> 的状态所需的内存会在堆上分配，独立于线程栈而存在。传递给它的参数都会复制到这个状态中，而局部变量会直接在这个状态中创建。调用 <code>Bar()</code> 的时候，由于本质上还是一个函数调用，所以栈顶指针也会往下移动，在栈上给执行 <code>Bar()</code> 所需的状态分配空间，其中会有一个引用指向在堆上的状态，这样一来， <code>Bar()</code> 就可以像一个普通函数那样执行了，线程也可以访问到位于堆上的状态。</p><p>如果协程需要暂停，那么当前执行到的代码位置会记录到堆的状态中。然后栈上的执行时状态被销毁，栈顶指针移动以回收空间，就像普通函数结束时那样。在下一次恢复执行时，堆状态中记录的暂停位置会读取出来，从这个位置接着执行。这样就实现了一个可暂停和恢复执行的函数。</p><p>由此可见，当协程执行的时候，它跟普通函数一样，也是需要依赖线程栈；但是，一旦它暂停了，它的状态就会独立保存在堆中，此时它跟任何线程都没有关系，调用它的线程可以继续去做其它事情而不会停止。在下一次恢复执行时，协程可以由上次执行的线程来执行，也可以由另外一个完全不同的线程来执行。所以说协程是线程无关的。</p><h2 id="3-协程的优点"><a href="#3-协程的优点" class="headerlink" title="3. 协程的优点"></a>3. 协程的优点</h2><p>协程的优点主要在于，它能优化异步逻辑的代码，使代码可读性更高。举个例子，假设我们有一个组件叫 <code>IntReader</code> ，它的功能是从一个访问速度很慢的设备上读取一个整数值，因此它提供的接口是异步的，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BeginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::srand(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="literal">nullptr</span>)));</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> value = std::rand();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//使用 value ...</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>BeginRead()</code> 开启了一个新的线程来生成一个随机的整数，模拟异步操作。作为一个仅用于示范的代码，这里尽量保持精简。</p><p>为了获取到 <code>IntReader</code> 的结果，传统的做法是提供一个回调函数，当操作完成的时候，通过回调函数告知使用者。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BeginRead</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([callback]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::srand(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="literal">nullptr</span>)));</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> value = std::rand();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            callback(value);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader;</span><br><span class="line">    reader.<span class="built_in">BeginRead</span>([](<span class="type">int</span> result) &#123;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; result &lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们需要调用多个 IntReader ，把它们的结果加起来再输出，那么基于回调的代码就会很难看了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    reader1.<span class="built_in">BeginRead</span>([](<span class="type">int</span> result1) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> total = result1;</span><br><span class="line"></span><br><span class="line">        IntReader reader2;</span><br><span class="line">        reader2.<span class="built_in">BeginRead</span>([total](<span class="type">int</span> result2) &#123;</span><br><span class="line"></span><br><span class="line">            total += result2;</span><br><span class="line"></span><br><span class="line">            IntReader reader3;</span><br><span class="line">            reader3.<span class="built_in">BeginRead</span>([total](<span class="type">int</span> result3) &#123;</span><br><span class="line">            </span><br><span class="line">                total += result3;</span><br><span class="line">                std::cout &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不仅需要一层套一层，还要在每层回调之间传递结果，这就是俗称的“回调地狱”。而有了协程，这些问题都迎刃而解，我们可以这样来调用 <code>IntReader</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> total = <span class="keyword">co_await</span> reader1;</span><br><span class="line"></span><br><span class="line">    IntReader reader2;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader2;</span><br><span class="line"></span><br><span class="line">    IntReader reader3;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader3;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑顿时清晰了不少，看上去就像同步调用那样。在每一个调用 co_await 的地方，协程都会暂停下来，等 IntReader 操作完成之后再从这个地方恢复执行。接下来，我们来看下如何实现这种效果。</p><h2 id="4-实现一个协程"><a href="#4-实现一个协程" class="headerlink" title="4. 实现一个协程"></a>4. 实现一个协程</h2><p>在C++中，只要在函数体内出现了 <code>co_await</code> 、<code>co_return</code> 和 <code>co_yield</code> 这三个操作符中的其中一个，这个函数就成为了协程。我们先来关注一下 <code>co_await</code> 操作符。</p><h3 id="4-1-co-await-和-Awaitable"><a href="#4-1-co-await-和-Awaitable" class="headerlink" title="4.1. co_await 和 Awaitable"></a>4.1. co_await 和 Awaitable</h3><p><code>co_await</code> 的作用是让协程暂停下来，等待某个操作完成之后再恢复执行。在上面的协程示例中，我们对 <code>IntReader</code> 调用了 <code>co_await</code> 操作符，目前这是不可行的，因为 <code>IntReader</code> 是我们自定义的类型，编译器不理解它，不知道它什么时候操作完成，不知道如何获取操作结果。为了让编译器理解我们的类型，C++定义了一个协议规范，只要我们的类型按照这个规范实现好，就可以在 <code>co_await</code> 使用了。</p><p>这个规范称作 Awaitable，它定义了若干个函数，传给 <code>co_await</code> 操作符的对象必须实现这些函数。这些函数包括：</p><ul><li><p><code>await_ready()</code>，返回类型是 <code>bool</code>。协程在执行 <code>co_await</code> 的时候，会先调用 <code>await_ready()</code> 来询问“操作是否已完成”，如果函数返回了 <code>true</code> ，协程就不会暂停，而是继续往下执行。实现这个函数的原因是，异步调用的时序是不确定的，如果在执行 <code>co_await</code> 之前就已经启动了异步操作，那么在执行 <code>co_await</code> 的时候异步操作有可能已经完成了，在这种情况下就不需要暂停，通过<code>await_ready()</code>就可以到达到这个目的。</p></li><li><p><code>await_suspend()</code>，有一个类型为 <code>std::coroutine_handle&lt;&gt;</code> 的参数，返回类型可以是 <code>void</code> 或者 <code>bool</code> 。如果 <code>await_ready()</code> 返回了 <code>false</code> ，意味着协程要暂停，那么紧接着会调用这个函数。该函数的目的是用来接收协程句柄（也就是<code>std::coroutine_handle&lt;&gt;</code> 参数），并在异步操作完成的时候通过这个句柄让协程恢复执行。协程句柄类似于函数指针，它表示一个协程实例，调用句柄上的对应函数，可以让这个协程恢复执行。</p><p><code>await_suspend()</code> 的返回类型一般为 <code>void</code>，但也可以是 <code>bool</code> ，这时候的返回值用来控制协程是否真的要暂停，这里是第二次可以阻止协程暂停的机会。如果该函数返回了 <code>false</code> ，协程就不会暂停（注意返回值的含义跟 <code>await_ready()</code> 是相反的）。</p></li><li><p><code>await_resume()</code>，返回类型可以是 <code>void</code> ，也可以是其它类型，它的返回值就是 <code>co_await</code> 操作符的返回值。当协程恢复执行，或者不需要暂停的时候，会调用这个函数。</p></li></ul><p>接下来，我们修改一下 IntReader ，让它符合 Awaitable 规范。下面是完整的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([<span class="keyword">this</span>, handle]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::srand(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="literal">nullptr</span>)));</span></span></span><br><span class="line"><span class="params"><span class="function">            value_ = std::rand();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            handle.resume();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> total = <span class="keyword">co_await</span> reader1;</span><br><span class="line"></span><br><span class="line">    IntReader reader2;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader2;</span><br><span class="line"></span><br><span class="line">    IntReader reader3;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader3;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintInt</span>();</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; line) &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先忽略返回类型 <code>Task</code> ，下文会专门介绍协程的返回类型。在这个例子中，对于 <code>await_ready()</code> 函数，我们总是返回 false，即协程总是要暂停。然后我们把子线程改成在 <code>await_supsend()</code> 中启动，也就是在协程暂停的时候来启动，因此不再需要 <code>BeginRead()</code> 函数了。子线程生成随机数之后，保存在 <code>value_</code> 成员变量中，然后调用协程句柄的 <code>resume()</code> 函数来恢复协程执行。最后通过 <code>await_resume()</code> 函数把结果返回给调用者。</p><p>值得关注的地方是线程的执行。在 <code>main()</code> 函数中，主线程调用了 <code>PrintInt()</code> ，执行到 <code>co_await reader1</code> 这一行，协程暂停了，于是主线程退出 <code>PrintInt()</code> ，返回到 <code>main()</code> 继续往下执行，最后在 while 循环中等待用户输入。接下来，在 <code>reader1</code>中启动的子线程调用了协程句柄的 <code>resume()</code> ，所以从 <code>co_await reader1</code> 中恢复执行的是这个子线程，直到 <code>co_await reader2</code> ，协程再次暂停，子线程退出。以此类推，后面的流程分别由 <code>reader2</code> 和 <code>reader3</code> 中启动的子线程来继续执行。所以，在 <code>PrintInt()</code> 这个协程内，总共有四个线程参与了执行。这里的关键点是：哪个线程调用协程句柄的 <code>resume()</code> ，就由哪个线程恢复协程执行。建议在IDE中设置断点来观察这个示例程序的执行流程，以便更好地理解。</p><h3 id="4-2-预定义的-Awaitable-类型"><a href="#4-2-预定义的-Awaitable-类型" class="headerlink" title="4.2. 预定义的 Awaitable 类型"></a>4.2. 预定义的 Awaitable 类型</h3><p>C++预定义了两个符合 Awaitable 规范的类型： <code>std::suspend_never</code> 和 <code>std::suspend_always</code> 。顾名思义，这两个类型分别表示“不暂停”和“要暂停”，实际上它们的区别仅在于 <code>await_ready()</code> 函数的返回值， <code>std::suspend_never</code> 会返回 true，而 <code>std::suspend_always</code> 会返回 false。除此之外，这两个类型的 <code>await_supsend()</code> 和 <code>await_resume()</code> 函数实现都是空的。</p><p>这两个类型是工具类，用来作为 <code>promise_type</code> 部分函数的返回类型，以控制协程在某些时机是否要暂停。下文会详细介绍 <code>promise_type</code> 。</p><h3 id="4-3-协程的返回类型和-promise-type"><a href="#4-3-协程的返回类型和-promise-type" class="headerlink" title="4.3. 协程的返回类型和 promise_type"></a>4.3. 协程的返回类型和 promise_type</h3><p>现在我们把关注点聚焦在协程的返回类型上。C++对协程的返回类型只有一个要求：包含名为 <code>promise_type</code> 的内嵌类型。跟上文介绍的 Awaitable 一样， <code>promise_type</code> 需要符合C++规定的协议规范，也就是要定义几个特定的函数。 <code>promise_type</code> 是协程的一部分，当协程被调用，在堆上为其状态分配空间的时候，同时也会在其中创建一个对应的 <code>promise_type</code> 对象。通过在它上面定义的函数，我们可以与协程进行数据交互，以及控制协程的行为。</p><p><code>promise_type</code> 要实现的第一个函数是 <code>get_return_object()</code> ，用来创建协程的返回值。在协程内，我们不需要显式地创建返回值，这是由编译器隐式调用 <code>get_return_object()</code> 来创建并返回的。这个关系看起来比较怪异， <code>promise_type</code> 是返回类型的内嵌类型，但编译器不会直接创建返回值，而是先创建一个 <code>promise_type</code> 对象，再通过这个对象来创建返回值。</p><img src="/2022/03/25/cpp-coroutine-beginner/3.png" class=""><p>那么协程的返回值有什么用呢？这取决于协程的设计者的意图，取决于他想要以什么样的方式来使用协程。例如，在上文的示例中，<code>PrintInt()</code> 这个协程只是输出一个整数，不需要与调用者有交互，所以它的返回值只是一个空壳。 假如我们想实现一个 <code>GetInt()</code> 协程，它会返回一个整数给调用者，由调用者来输出结果，那么就需要对协程的返回类型做一些修改了。</p><h3 id="4-4-co-return"><a href="#4-4-co-return" class="headerlink" title="4.4. co_return"></a>4.4. co_return</h3><p>我们现在把 <code>PrintInt()</code> 修改成 <code>GetInt()</code> 。使用 <code>co_return</code> 操作符可以从协程中返回数据，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> total = <span class="keyword">co_await</span> reader1;</span><br><span class="line"></span><br><span class="line">    IntReader reader2;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader2;</span><br><span class="line"></span><br><span class="line">    IntReader reader3;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>co_return total</code> 这个表达式等价于 <code>promise_type.return_value(total)</code> ，也就是说，返回的数据会通过 <code>return_value()</code> 函数传递给 <code>promise_type</code> 对象， <code>promise_type</code> 要实现这个函数才能接收到数据。除此之外，还要想办法让返回值 <code>Task</code> 能访问到这个数据。为了减少数据传递，我们可以在 <code>promise_type</code> 和 <code>Task</code> 之间共享同一份数据。修改之后的完整示例如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([<span class="keyword">this</span>, handle]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            std::srand(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="literal">nullptr</span>)));</span></span></span><br><span class="line"><span class="params"><span class="function">            value_ = std::rand();</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            handle.resume();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">promise_type</span>() : <span class="built_in">value_</span>(std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> Task&#123; value_ &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            *value_ = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; value_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">const</span> std::shared_ptr&lt;<span class="type">int</span>&gt;&amp; value) : <span class="built_in">value_</span>(value) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> total = <span class="keyword">co_await</span> reader1;</span><br><span class="line"></span><br><span class="line">    IntReader reader2;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader2;</span><br><span class="line"></span><br><span class="line">    IntReader reader3;</span><br><span class="line">    total += <span class="keyword">co_await</span> reader3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; line) &#123;</span><br><span class="line">        std::cout &lt;&lt; task.<span class="built_in">GetValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>promise_type</code> 和 <code>Task</code> 之间，使用了 <code>std::shared_ptr&lt;int&gt;</code> 来共享数据。在 <code>get_return_object()</code> 中创建 <code>Task</code> 的时候，把 <code>promise_type</code> 里的智能指针传递了过去，这样它们就能访问到同一个数据。在 <code>promise_type</code> 的 <code>return_value()</code> 中写数据，然后在 <code>Task</code> 的 <code>GetValue()</code> 中读数据。</p><p>异步是具有传染性的， <code>GetInt()</code> 内部调用了异步操作，所以它自身实际上也是一个异步操作。为了等待它执行完成，我们把 <code>task.GetValue()</code> 的调用放在了 while 循环中，每当用户输入一次之后就进行输出。由于这是一个简单的示例程序，没有各种高级的异步同步机制，所以通过等待用户输入方式来变相地等待协程执行完成。</p><p>在真实的使用场景中，协程的返回类型还需要提供各种同步机制才能给调用者使用，例如加上回调、通知等，就像普通的异步操作一样。由此可见，协程的优点体现在它内部的代码逻辑上，而不是对外的使用方式上。当然，我们也可以让协程的返回类型实现 Awaitable 规范，让它可以被另外一个协程更好地调用。这样一来，调用协程的也必须是协程，这样层层往上传递，直到遇到不能改成协程的函数为止，例如 <code>main()</code> 函数。从这个角度来说，协程也是具有传染性的。</p><p>最后，跟普通的 <code>return</code> 一样， <code>co_return</code> 也可以不带任何参数，这时候协程以不带数据的方式返回，相当于调用了 <code>promise_type.return_void()</code> ， <code>promise_type</code> 需要定义这个函数以支持不带数据的返回。如果我们在协程结束的时候没有调用任何 <code>co_return</code> ，那么编译器会隐式地加上一个不带参数的 <code>co_return</code> 调用。</p><h3 id="4-5-co-yield"><a href="#4-5-co-yield" class="headerlink" title="4.5. co_yield"></a>4.5. co_yield</h3><p>当协程调用了 <code>co_return</code> ，意味着协程结束了，就跟我们在普通函数中用 <code>return</code> 结束函数一样。这时候，与这个协程实例有关的内存都会被释放掉，它不能再执行了。如果需要在协程中多次返回数据而不结束协程的话，可以使用 <code>co_yield</code> 操作符。</p><p><code>co_yield</code> 的作用是，返回一个数据，并且让协程暂停，然后等下一次机会恢复执行。 <code>co_yield value</code> 这个表达式等价于 <code>co_await promise_type.yield_value(value)</code> ， <code>co_yield</code> 的参数会传递给 <code>promise_type</code> 的 <code>yield_value()</code> 函数，再把这个函数的返回值传给 <code>co_await</code> 。上文提到，传给 <code>co_await</code> 的参数要符合 Awaitable 规范，所以 <code>yield_value()</code> 的返回类型也要满足这个规范。在这里就可以使用预定义的 <code>std::supsend_never</code> 或 <code>std::suspend_always</code> ，通常会使用后者来让协程每次调用 <code>co_yield</code> 的时候都暂停。</p><p>下面我们修改一下示例，当用户输入一次之后，从协程取出一个值输出，然后让它生成下一个值；用户继续输入，又取出一个值输出，再生成下一个值，如此反复循环。完整的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntReader</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::thread <span class="title">thread</span><span class="params">([<span class="keyword">this</span>, handle]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">static</span> <span class="type">int</span> seed = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            value_ = ++seed;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            handle.resume();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> Task&#123; std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            value_ = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">coroutine_handle_</span>(handle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coroutine_handle_.<span class="built_in">promise</span>().<span class="built_in">GetValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        coroutine_handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; coroutine_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        IntReader reader;</span><br><span class="line">        <span class="type">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; line) &#123;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; task.<span class="built_in">GetValue</span>() &lt;&lt; std::endl;</span><br><span class="line">        task.<span class="built_in">Next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例修改的点比较多，我们拆解来看。首先，为了方便看出来程序的确是按照我们的预期来运行的，这里把 <code>IntReader::await_suspend()</code> 子线程内生成随机整数改成生成递增的整数。</p><p>然后，为了让使用者可以恢复协程执行， <code>Task</code> 增加了一个 <code>Next()</code> 函数，这个函数调用了作为成员变量的协程句柄来恢复执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    coroutine_handle_.<span class="built_in">resume</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着 <code>Task</code> 需要拿到协程的句柄，这是在 <code>promise_type</code> 的 <code>get_return_object()</code> 中通过以下方式传递过去的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> Task&#123; std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::coroutine_handle</code> 的 <code>from_promise()</code> 函数可以通过 <code>promise_type</code> 对象获取与之关联的协程句柄，反之，协程句柄上也有一个 <code>promise()</code> 函数可以获取对应的 <code>promise_type</code> 对象，他们是可以互相转换的。所以，在 <code>Task</code> 和 <code>promise_type</code> 之间就不需要使用 <code>std::shared_ptr&lt;int&gt;</code> 来共享数据了， <code>Task</code> 通过协程句柄就能访问到 <code>promise_type</code> 对象，像下面这样直接取数据就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> coroutine_handle_.<span class="built_in">promise</span>().<span class="built_in">GetValue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意一下协程句柄 <code>std::coroutine_handle</code> 的模板类型。在前面的例子中，协程句柄的类型是 <code>std::coroutine_handle&lt;&gt;</code> ，不带模板参数；而在这个例子中，协程句柄的类型是  <code>std::coroutine_handle&lt;promise_type&gt;</code> ，模板参数中填入了 <code>promise_type</code> 类型。它们的区别类似于指针 <code>void*</code> 和 <code>promise_type*</code> 的区别，前者是无类型的，后者是强类型的。两种类型的协程句柄本质上是相同的东西，它们可以有相同的值，指向同一个协程实例，而且也都可以恢复协程执行。但只有强类型的 <code>std::coroutine_handle&lt;promise_type&gt;</code> 才能调用 <code>from_promise()</code> 获取到 <code>promise_type</code> 对象。</p><p>接下来，协程 <code>GetInt()</code> 的实现修改成一个无限循环，在循环内通过 <code>IntReader</code> 获取到整数，再通过 <code>co_yield</code> 把整数返回出去：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        IntReader reader;</span><br><span class="line">        <span class="type">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于协程来说，无限循环是常见的实现方式，由于它具有暂停的特性，并不会像普通函数那样让线程在里面死循环。</p><p>最后，在 <code>promise_type</code> 中定义了 <code>yield_value()</code> 函数来接收 <code>co_yield</code> 返回的数据。我们希望返回数据之后立即暂停协程，所以返回类型定义成了 <code>std::supsend_always</code> 。</p><h3 id="4-6-协程的生命周期"><a href="#4-6-协程的生命周期" class="headerlink" title="4.6. 协程的生命周期"></a>4.6. 协程的生命周期</h3><p>正如上文所说的，在一开始调用协程的时候，C++会在堆上为协程的状态分配内存，这块内存必须在适当的时机来释放，否则就会造成内存泄漏。释放协程的内存有两种方式：自动释放和手动释放。</p><p>当协程结束的时候，如果我们不做任何干预，那么协程的内存就会被自动释放。调用了 <code>co_return</code> 语句之后，协程就会结束，下面两个协程是自动释放的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader;</span><br><span class="line">    <span class="type">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">PrintInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IntReader reader1;</span><br><span class="line">    <span class="type">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PrintInt()</code> 没有出现 <code>co_return</code> 语句，编译器会在末尾隐式地加上 <code>co_return</code> 。</p><p>自动释放的方式有时候并不是我们想要的，参考下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Task&#123; std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            value_ = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> value_&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">coroutine_handle_</span>(handle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coroutine_handle_.<span class="built_in">promise</span>().<span class="built_in">GetValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; coroutine_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">GetInt</span>();</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; line) &#123;</span><br><span class="line">        std::cout &lt;&lt; task.<span class="built_in">GetValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中， <code>GetInt()</code> 协程通过 <code>co_return</code> 返回了1024给 <code>promise_type</code> ；协程返回值 <code>Task</code> 通过协程句柄访问 <code>promise_type</code> ，从中取出这个值。随着用户的输入，把这个值输出来。运行程序，我们会发现输出的值并不是1024，而是一个随机值；也有可能会出现地址访问错误的异常。</p><p>造成这个现象的原因是，协程在返回1024之后就被自动释放了， <code>promise_type</code> 也跟着被一起释放了，此时在 <code>Task</code> 内部持有的协程句柄已经变成了野指针，指向一块已经被释放的内存。所以访问这个协程句柄的任何行为都会造成不确定的后果。</p><p>解决这个问题的方法是，修改 <code>promise_type</code> 中 <code>final_supsend()</code> 函数的返回类型，从 <code>std::suspend_never</code> 改成 <code>std::suspend_always</code> 。协程在结束的时候，会调用 <code>final_suspend()</code> 来决定是否暂停，如果这个函数返回了要暂停，那么协程不会自动释放，此时协程句柄还是有效的，可以安全访问它内部的数据。</p><p>不过，这时候释放协程就变成我们的责任了，我们必须在适当的时机调用协程句柄上的 <code>destroy()</code> 函数来手动释放这个协程。在这个例子中，可以在 <code>Task</code> 的析构函数中做这个事情：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Task</span>() &#123;</span><br><span class="line">    coroutine_handle_.<span class="built_in">destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要协程处于暂停状态，就可以调用协程句柄的 <code>destroy()</code> 函数来释放它，不一定要求协程结束。对于通过无限循环来实现的协程，手动释放是必需的。</p><p>与 <code>final_suspend()</code> 相对应的是 <code>initial_suspend()</code> ，在协程刚开始执行的时候，会调用这个函数来决定是否暂停。我们可以将这个函数的返回类型改成 <code>std::suspend_always</code> 来让协程一执行即暂停。这对于一些需要延迟执行的场景是有用的，例如，我们想先获取一批协程句柄，像数据那样对它们进行管理，在稍后的时机再挑选合适的协程来执行。</p><h3 id="4-7-异常处理"><a href="#4-7-异常处理" class="headerlink" title="4.7. 异常处理"></a>4.7. 异常处理</h3><p>最后，我们看一下协程的异常处理。编译器生成的执行协程的伪代码大概如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">co_await</span> promise_type.<span class="built_in">initial_suspend</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//协程函数体的代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...) &#123;</span><br><span class="line"></span><br><span class="line">    promise_type.<span class="built_in">unhandled_exception</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">co_await</span> promise_type.<span class="built_in">final_suspend</span>();</span><br></pre></td></tr></table></figure><p>协程主要的执行代码都被 try - catch 包裹，假如抛出了未处理的异常， <code>promise_type</code> 的 <code>unhandled_exception()</code> 函数会被调用，我们可以在这个函数里面做对应的异常处理。由于这个函数是在 <code>catch</code> 语句中调用的，我们可以在函数内调用 <code>std::current_exception()</code> 函数获取异常对象，也可以调用 <code>throw</code> 重新抛出异常。</p><p>调用了 <code>unhandled_exception()</code> 之后，协程就结束了，接下来会继续调用 <code>final_suspend()</code> ，与正常结束协程的流程一样。C++规定 <code>final_suspend()</code> 必须定义成 <code>noexcept</code> ，也就是说它不允许抛出任何异常。</p><h2 id="5-后记"><a href="#5-后记" class="headerlink" title="5. 后记"></a>5. 后记</h2><p>至此，关于C++协程的基础内容介绍完毕。从当前的使用方式来看，C++20的协程只提供了最基础的能力，为了用上它，我们需要写不少代码，将一个一个小块串联起来。所以，现在C++协程的形态是不友好的，晦涩难懂，难以学习。</p><p>要想在实际的开发中使用上C++协程，还有比较长的路。我们可以自己动手对它进行封装，或者寻求第三方库的解决方案，或者继续期待未来的C++标准带来更高层封装的协程组件。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;随着Visual Studio 2022的发布，C++20终于来到了我们的眼前，在这个标准的新特性之中，最吸引人之一的是协程，对于饱受异步调用之繁琐写法的人来说，协程似乎是解决异步问题的灵丹妙药。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何获取可变参数宏实参的数量</title>
    <link href="http://zplutor.github.io/2021/07/14/how-to-get-argument-count-of-variable-argument-macro/"/>
    <id>http://zplutor.github.io/2021/07/14/how-to-get-argument-count-of-variable-argument-macro/</id>
    <published>2021-07-13T18:02:18.000Z</published>
    <updated>2021-07-13T18:10:08.662Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读一些开源代码的时候，可能会看到类似下面这种神秘的宏：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARG_N(                                     \ </span></span><br><span class="line">_1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  _10,  \</span><br><span class="line">_11, _12, _13, _14, _15, _16, _17, _18, _19, _20,  \</span><br><span class="line">_21, _22, _23, _24, _25, _26, _27, _28, _29, _30,  \</span><br><span class="line">_31, _32, _33, _34, _35, _36, _37, _38, _39, _40,  \</span><br><span class="line">_41, _42, _43, _44, _45, _46, _47, _48, _49, _50,  \</span><br><span class="line">_51, _52, _53, _54, _55, _56, _57, _58, _59, _60,  \</span><br><span class="line">_61, _62, _63,   N, ...)                           \</span><br><span class="line">N</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSEQ_N                           \</span></span><br><span class="line"><span class="meta">63, 62, 61, 60,                          \</span></span><br><span class="line"><span class="meta">59, 58, 57, 56, 55, 54, 53, 52, 51, 50,  \</span></span><br><span class="line"><span class="meta">49, 48, 47, 46, 45, 44, 43, 42, 41, 40,  \</span></span><br><span class="line"><span class="meta">39, 38, 37, 36, 35, 34, 33, 32, 31, 30,  \</span></span><br><span class="line"><span class="meta">29, 28, 27, 26, 25, 24, 23, 22, 21, 20,  \</span></span><br><span class="line"><span class="meta">19, 18, 17, 16, 15, 14, 13, 12, 11, 10,  \</span></span><br><span class="line"><span class="meta"> 9,  8,  7,  6,  5,  4,  3,  2,  1,  0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARG_(...) ARG_N(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARG(...) NARG_(__VA_ARGS__, RSEQ_N)</span></span><br></pre></td></tr></table></figure><p>这些宏的作用是获取可变参数宏的实参数量。在调用 <code>NARG</code> 时，传入若干个参数，就会返回这些参数的数量，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="built_in">NARG</span>(a);        <span class="comment">//i = 1</span></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">NARG</span>(a, b);     <span class="comment">//j = 2</span></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">NARG</span>(a, b, c);  <span class="comment">//k = 3</span></span><br></pre></td></tr></table></figure><p>这些宏使用了精妙的技巧来实现这个功能。了解其实现原理的最好方法是将宏一步步展开，在这个过程中观察它究竟施展了什么样的“魔法”。为了方便理解，这里将 <code>ARG_N</code> 和 <code>RSEQ_N</code> 定义的数字数量精简成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARG_N(_1, _2, _3, N, ...) N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSEQ_N 3, 2, 1, 0</span></span><br></pre></td></tr></table></figure><p>以 <code>NARG(a, b, c)</code> 为例，这个宏调用会被替换成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NARG_</span>(a, b, c, RSEQ_N)</span><br></pre></td></tr></table></figure><p>再把 <code>RSEQ_N</code> 展开，变成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NARG_</span>(a, b, c, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>再被替换成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ARG_N</span>(a, b, c, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>对照参考 <code>ARG_N</code> 的定义，它总是会被替换成第4个参数，所以这个宏被替换成了3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARG_N(_1, _2, _3, N, ...    ) N</span></span><br><span class="line"><span class="comment">//      ARG_N( a,  b,  c, 3, 2, 1, 0) 3</span></span><br></pre></td></tr></table></figure><p>再以两个参数的调用 <code>NARG(a, b)</code> 为例，这个宏会被替换成2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARG_N(_1, _2, _3, N, ... ) N</span></span><br><span class="line"><span class="comment">//      ARG_N( a,  b,  3, 2, 1, 0) 2</span></span><br></pre></td></tr></table></figure><p>以此类推，可以总结出它的实现原理：将输入参数与一个倒序的数字序列拼接成新的参数序列，传递给 <code>ARG_N</code> 宏，这个宏输出固定位置的参数，这个位置上的数字刚好等于输入参数的个数。</p><p>这种方法有一定的局限性，比如它支持的最大参数数量是有限的，依赖 <code>ARG_N</code> 和 <code>RSEQ_N</code> 中定义的数量。在本文开头的例子中，它最多支持64个宏参数，假如要支持更多的参数，就需要在这两个宏里添加更多的数字。<code>ARG_N</code> 和 <code>RSEQ_N</code> 里的数字数量一定要精确匹配，否则这套机制就失效了。另外也顺带一提，<code>ARG_N</code> 里的 <code>_1</code> 、<code>_2</code>、<code>_3</code> 等标示符只是一个参数占位符，没有其它作用，即使写成别的名字也是可以的，写成数字是为了更方便与<code>RSEQ_N</code> 里的数字对齐。</p><p>另外一个局限是，它不能支持0个参数，即使在<code>RSEQ_N</code> 里定义了0这个数字。原因是宏展开时只是单纯的文本替换，例如 <code>NARG()</code> 这个宏调用，会被展开成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NARG_</span>(, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>即使没有输入参数，在它后面的逗号还是保留着的，所以实际上相当于有1个参数。在最后调用 <code>ARG_N</code> 的时候，会被替换成1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARG_N(_1, _2, _3, N, ... ) N</span></span><br><span class="line"><span class="comment">//      ARG_N(  ,  3,  2, 1, 0   ) 1</span></span><br></pre></td></tr></table></figure><p>最后，在使用MSVC编译器时，如果使用默认的编译选项，这套方法是不生效的，因为MSVC的宏参数展开规则不符合标准。简单地说，在MSVC中，当一个宏将它的可变参数传递给另外一个宏时，这些参数被作为一个整体来传递，而不是拆分成多个传递，所以对于另外一个宏来说，只接收到一个参数。例如， <code>NARG(a, b, c)</code> 这个宏调用，虽然从字面上它也会被展开成 <code>ARG_N(a, b, c, 3, 2, 1, 0)</code> ，但从语义上它却是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARG_N(                  _1, _2, _3, N, ... ) N</span></span><br><span class="line"><span class="comment">//      ARG_N(a, b, c, 3,  2, 1, 0                 ) </span></span><br></pre></td></tr></table></figure><p>传递给 <code>ARG_N</code> 的参数，都一起被视为第一个参数了。所以在MSVC下编译会出现<code>ARG_N</code> 参数不足的警告，并且得到空的结果。</p><p>在MSVC添加 <code>/Zc:preprocessor</code> 编译选项，可以解决这个问题。这个编译选项改变了编译器展开宏的规则，使其更符合标准。在Visual Studio的项目设置中也可以修改这个选项：</p><img src="/2021/07/14/how-to-get-argument-count-of-variable-argument-macro/1.png" class=""><p>除了修改编译器选项，还有另外一种取巧的方法，即在调用 <code>ARG_N</code> 之前，增加一个中间层调用，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPAND(x) x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARG_(...) EXPAND( ARG_N(__VA_ARGS__) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARG(...) NARG_(__VA_ARGS__, RSEQ_N)</span></span><br></pre></td></tr></table></figure><p>这里增加了一个新的 <code>EXPAND</code> 宏，这个宏从字面上没有实际用途，只是把参数原样保留。但是从语义上来说，这个宏改变了展开的行为。</p><p>仍然以 <code>NARG(a, b, c)</code> 为例，它的展开过程如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NARG_</span>(a, b, c, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)            <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">EXPAND</span>( <span class="built_in">ARG_N</span>(a, b, c, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>) )  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">ARG_N</span>(a, b, c, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)            <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>从第2步到第3步这个过程可以看出来，宏调用跟函数调用不一样，宏调用只是文本替换， <code>EXPAND</code> 只把 <code>ARG_N(a, b, c, 3, 2, 1, 0)</code> 原样保留，而不是先展开 <code>ARG_N</code> 再调用 <code>EXPAND</code>。这是关键的地方，在第2步的时候，虽然 <code>a, b, c, 3, 2, 1, 0</code> 这些参数还是一个整体，但由于这时候还没有去展开 <code>ARG_N</code> ，所以不会像之前那样全部都当作第一个参数，它们只作为文本被保留下来。到了第3步，这时候就是正常的宏展开，参数可以一一对应。</p><p>增加 <code>EXPAND</code> 中间层对其它编译器没有影响，所以如果要编写跨平台的代码，应该使用这个方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在阅读一些开源代码的时候，可能会看到类似下面这种神秘的宏：&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>为什么可以重命名一个正在运行的exe文件</title>
    <link href="http://zplutor.github.io/2021/02/04/why-can-a-running-exe-file-be-renamed/"/>
    <id>http://zplutor.github.io/2021/02/04/why-can-a-running-exe-file-be-renamed/</id>
    <published>2021-02-04T03:22:18.000Z</published>
    <updated>2021-02-04T03:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，当一个exe文件正在运行的时候，是不能被修改，也不能被删除的。然而，似乎有悖常理的是，这个文件却是可以被重命名的。这背后的原理是什么呢？</p><span id="more"></span><p>在运行一个exe文件之前，首先要打开它。打开文件的基础API是<code>CreateFile</code>函数，在它的参数中，与文件共享方式相关的参数是<code>dwShareMode</code>，它可以指定打开的文件是否允许被其它访问者读（<code>FILE_SHARE_READ</code>）、写（<code>FILE_SHARE_WRITE</code>）或删除（<code>FILE_SHARE_DELETE</code>）。于是自然有这样的猜想：系统在打开exe文件的时候使用了某种共享方式的组合，以致于出现这种行为。</p><p>可是，当使用不同组合的共享方式来调用<code>CreateFile</code>，尝试还原出这种行为时，却是怎么也行不通。API的文档明确指出，在指定了<code>FILE_SHARE_DELETE</code>的时候既可以删除文件，也可以重命名文件，但就是没有“不能删除，只能重命名”这种选项。</p><p>为了弄清楚这个问题，我们可以使用ProcessMonitor来观察系统在运行exe之前是如何打开文件的。首先写一个简单的程序，在程序中调用<code>CreateProcess</code>函数来启动另外一个进程，然后在ProcessMonitor中查看这个程序运行时产生的文件操作记录。这里额外写一个程序来启动进程的目的是为了减少干扰信息——直接在资源管理器中运行exe会产生很多文件操作记录，无法确定哪些才是真正运行所需的。</p><p>ProcessMonitor显示的结果如下，这是在ConsoleApplication.exe进程里启动了Application.exe进程的记录。</p><img src="/2021/02/04/why-can-a-running-exe-file-be-renamed/1.png" class=""><p>打开第一条“CreateFile”的记录，可以看到exe文件是以<code>FILE_SHARE_READ</code>和<code>FILE_SHARE_DELETE</code>方式打开的：</p><img src="/2021/02/04/why-can-a-running-exe-file-be-renamed/2.png" class=""><p>显然这并不能作出合理的解释，因为这种组合的共享方式已经尝试过是没有效果的，况且ProcessMonitor里的最后一条操作记录是“CloseFile”，文件已经被关闭了，打开文件的影响已经是不存在的。再看一下文件操作记录，在“CreateFile”之后有一次“CreateFileMapping”操作，也许这就是关键点。</p><p>让我们再稍微深入一下程序的启动流程。在打开了exe文件之后，系统需要读取文件的内容来运行，这是通过内存映射文件来实现的。系统在打开后的exe文件上创建了一个内存映射文件，把它映射到了进程的虚拟地址空间中，然后直接访问虚拟地址来读取文件的内容。对虚拟地址的访问触发了内存管理器的缺页机制，它发现内存页面中没有exe文件的内容，便从硬盘上对应的位置读取，加载到内存中。</p><p>由于内存映射文件的存在，exe文件的内容必须完整保留在硬盘上，以便系统在程序运行过程中随时读取，所以exe文件是不能删除的。而当程序运行起来之后，exe的文件名已经没有用处了，并且文件名不属于文件内容，它只是文件夹目录项中的一个属性，修改文件名实际上修改的是目录项，而不是文件内容，因此修改exe的文件名并不会影响程序运行。</p><p>我们可以写一个程序来验证上述论述：先打开一个文件，然后在这个文件上创建一个内存映射文件，再把先前打开的文件句柄关闭，保持程序不退出。此时这个文件的行为就跟正在运行的exe文件一样了，可以重命名但是不能删除。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们都知道，当一个exe文件正在运行的时候，是不能被修改，也不能被删除的。然而，似乎有悖常理的是，这个文件却是可以被重命名的。这背后的原理是什么呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>使用自定义字面量简化常量的定义</title>
    <link href="http://zplutor.github.io/2021/01/10/use-user-defined-literals-to-simplified-definition-of-constant/"/>
    <id>http://zplutor.github.io/2021/01/10/use-user-defined-literals-to-simplified-definition-of-constant/</id>
    <published>2021-01-10T07:49:30.000Z</published>
    <updated>2021-01-10T07:56:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在涉及文件大小的代码中，经常要写出判断大小的代码。例如，在上传文件之前，要判断文件的大小是否超出了可支持的范围：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file_size &gt; <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>) &#123; </span><br><span class="line">    <span class="comment">//超出可支持范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了好几个1024，阅读这段代码的人首先要心算一遍之后才能理解“哦，原来这里的文件大小上限是4GB”。对程序员来说这种计算都是小菜一碟，即便如此，这段代码的可读性也是不高的，因为它没有直截了当地表达出它的意图。</p><p>有几种方法可以优化这段代码，例如抽取出一个<code>GB()</code>函数。这里要介绍的是另一种表达更自然的方法，C++11引入的新特性：自定义字面量。</p><p>字面量是指在代码中写下的数字、字符串等值，例如：</p><ul><li>整数，如<code>1024</code>。</li><li>浮点数，如<code>3.14</code>。</li><li>字符，如<code>&#39;a&#39;</code>。</li><li>字符串，如<code>&quot;abc&quot;</code>。</li></ul><p>如果在字面量后面加上特定后缀，可以调用对应的转换函数，将这个字面量转成特定类型。例如，在<code>&lt;string&gt;</code>中定义了<code>s</code>后缀，可以将一个字符串字面量转换成<code>std::string</code>类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将std::literals名称空间引入当前作用域，才能使用C++内置的自定义字面量</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"></span><br><span class="line">std::string str = <span class="string">&quot;This is a std::string.&quot;</span>s;</span><br></pre></td></tr></table></figure><p>我们也可以定义自己的字面量后缀和转换函数，方法是定义一个字面量操作符函数。该函数的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReturnType <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _Suffix(Parameters);</span><br></pre></td></tr></table></figure><p><code>ReturnType</code>是这个转换函数的返回值。<code>_Suffix</code>是字面量的后缀，要注意的是，开发者自定义字面量的后缀必须以<code>_</code>字符开头，否则会编译失败，因为不带这个字符开头的后缀是预留给C++的。<code>Parameters</code>是转换函数的参数列表，可以从以下几种参数列表中选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数字面量</span></span><br><span class="line">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点数字面量</span></span><br><span class="line">(<span class="type">long</span> <span class="type">double</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">//字符字面量</span></span><br><span class="line">(<span class="type">char</span>) </span><br><span class="line">(<span class="type">wchar_t</span>) </span><br><span class="line">(<span class="type">char16_t</span>)</span><br><span class="line">(<span class="type">char32_t</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串字面量</span></span><br><span class="line">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">size_t</span>) </span><br><span class="line">(<span class="type">const</span> <span class="type">wchar_t</span>*, <span class="type">size_t</span>) </span><br><span class="line">(<span class="type">const</span> <span class="type">char16_t</span>*, <span class="type">size_t</span>)</span><br><span class="line">(<span class="type">const</span> <span class="type">char32_t</span>*, <span class="type">size_t</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始字面量</span></span><br><span class="line">(<span class="type">const</span> <span class="type">char</span>*)</span><br></pre></td></tr></table></figure><p>具体选择哪种参数列表，根据你的需求而定。如果你希望只支持整数，那么只需要定义一个参数列表是<code>(unsigned long long)</code>的操作符函数即可；如果你希望同时支持整数和浮点数，那么就要定义两个操作符函数，参数列表分别是<code>(unsigned long long)</code>和<code>(long double)</code>。</p><p>你只能从上面的参数列表中选择，不能使用别的参数列表，否则编译会失败。例如，即使你只需要一个<code>int</code>类型的整数字面量，也必须把参数定义成<code>unsigned long long</code>。编译器总是把字面量的值以可表示范围最大的类型传给你，具体怎么使用这个值由你自己决定。</p><p>由于C++中存在四种字符类型，所以字符字面量和字符串字面量都分别有四种参数类型。在字符串字面量的参数列表中，第二个<code>size_t</code>类型的参数表示字符串的长度。</p><p>如果字面量操作符函数的参数列表定义成<code>const char*</code>，那么它是一个原始字面量操作符函数。原始字面量操作符只能用在整数或浮点数字面量上，它的参数指向整数或浮点数的字符串。它提供了一种方法，让我们可以以自定义的规则来解析整数或浮点数字面量。</p><p>回到本文开头的问题，我们可以定义下面的字面量操作符函数来简化文件大小常量的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> std::<span class="type">int64_t</span> <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _GB(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;std::<span class="type">int64_t</span>&gt;(value * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换使用这个自定义字面量之后，代码含义一目了然，大大提高了可读性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file_size &gt; <span class="number">4</span>_GB) &#123; </span><br><span class="line">    <span class="comment">//超出可支持范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在涉及文件大小的代码中，经常要写出判断大小的代码。例如，在上传文件之前，要判断文件的大小是否超出了可支持的范围：&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>分析一个驱动程序导致程序无响应的案例</title>
    <link href="http://zplutor.github.io/2020/12/25/analyze-an-application-hang-caused-by-driver/"/>
    <id>http://zplutor.github.io/2020/12/25/analyze-an-application-hang-caused-by-driver/</id>
    <published>2020-12-24T16:46:27.000Z</published>
    <updated>2020-12-24T17:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有客户投诉我们的程序经常无响应，几乎无法使用。我查看了问题现场，发现有以下表现：</p><ol><li>无响应时程序的CPU使用率基本保持为0%。</li><li>如果一直放着不干预，一分钟左右程序是能恢复正常的。</li><li>从转储文件看，程序是在调用<code>ReadFile</code>读取文件内容时出现无响应的，部分的堆栈如下所示：</li></ol><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ntdll!KiFastSystemCallRet</span><br><span class="line">ntdll!NtReadFile+0xc</span><br><span class="line">KERNELBASE!ReadFile+0xaa</span><br><span class="line">kernel32!ReadFileImplementation+0xf0</span><br><span class="line">MyApp!winRead+0xc6</span><br><span class="line">MyApp!sqlite3OsRead+0x2c</span><br><span class="line">MyApp!sqlite3WalReadFrame+0x45</span><br><span class="line">MyApp!readDbPage+0x94</span><br><span class="line">MyApp!getPageNormal+0x1a4</span><br><span class="line">MyApp!sqlite3PagerGet+0x13</span><br><span class="line">MyApp!getAndInitPage+0x72</span><br><span class="line">MyApp!moveToChild+0x7f</span><br><span class="line">MyApp!sqlite3BtreeMovetoUnpacked+0x3c5</span><br><span class="line">MyApp!sqlite3VdbeExec+0x2b31</span><br><span class="line">MyApp!sqlite3Step+0xee</span><br><span class="line">MyApp!sqlite3_step+0x98</span><br></pre></td></tr></table></figure><p>根据这些现象，我猜测可能是某个实现不好的驱动程序拦截了<code>ReadFile</code>这个API导致的。为了进一步排查，需要更详尽的信息，于是我在客户的电脑上使用Windows Performance Recorder录制性能数据，从无响应开始，一直录制到恢复正常，然后使用Windows Performance Analyzer对这个性能数据进行分析。下面是分析过程。</p><p>在这里主要用到的是Windows Performance Analyzer的“CPU Usage (Precise)”图表，这个图表的数据与线程的状态切换息息相关。简单来说，在线程的生命周期中，会在以下几种状态之间切换：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/1.png" class=""><ul><li>等待，线程要执行的条件未被满足，正在等待这些条件。例如，线程在等待一个互斥锁被释放。</li><li>就绪，线程要执行的所有条件均已满足，随时可以调度给CPU执行。例如，一个线程释放了互斥锁，另外一个正在等待锁的线程会进入就绪状态。</li><li>执行，线程正在被CPU执行。</li></ul><p>Windows Performance Recorder记录了系统中所有线程每一次状态切换的信息，包括就绪之前等待的时长、哪个线程让另一个线程就绪、导致线程进入等待状态的堆栈等等，这些信息均通过CPU Usage (Precise)图表来呈现。</p><p>回到本文要分析的问题，“程序在一分钟左右能恢复正常”是一个很关键的信息，它表明了导致程序无响应的一个可能原因：主线程在等待某个条件，经过一分钟左右该条件得到满足，主线程得以继续执行，于是程序恢复正常。为了证实这个猜想，需要从CPU Usage (Precise)图表中找到证据。</p><p>在打开了CPU Usage (Precise)图表之后，先对这个表格的列做一些调整，如下所示：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/2.png" class=""><p>这里把表格黄色分割线左侧的列，依次设置成了“New Process” - “New Thread Id” - “New Thread Stack”，这几个带有“New”前缀的列表示切换到执行状态的线程的相关信息，例如New Process表示线程所在进程的名字，New Thread Id即该线程的ID，New Thread Stack表示切换到执行状态之后，线程开始执行时代码位置的堆栈，这通常也是线程进入等待状态时的堆栈。经过这样设置之后，表格的数据会依次按照进程-线程-堆栈来聚合，方便筛选和查看。</p><p>然后是表格蓝色分割线右侧的列设置成了“Waits”的最大值，顾名思义，Waits这个数据的含义是线程在切换到就绪状态之前等待的时长。注意这不是切换到执行状态之前的等待时长。从就绪状态切换到执行状态之间也有一段时间，这段时间不会计算在内，而且通常这段时间都很短，相比在等待状态的时长，可以忽略不计。</p><p>接下来，将表格按照Waits列倒序排列，并且根据进程名字和主线程ID进行筛选，即可找到等待时长最大的线程状态切换数据，从这个数据的堆栈，能看出来一些端倪，如下所示：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/3.png" class=""><p>从图中可以看到，主线程在这一次切换到执行状态之前等待了大约77秒，符合程序无响应的感官时长，而且图中展示的堆栈与转储文件中的堆栈是一致的，所以基本可以确定这里就是问题产生的根源。相比用户态的转储文件，Windows Performance Analyzer的一个优势是可以看到内核态的堆栈，可以看到调用<code>ReadFile</code>之后发生的事情。这里有一个可疑的驱动程序<code>cwNep.sys</code>，它没有符号信息，并且网上搜索的结果表明，它显然是一个第三方的驱动程序。这个驱动程序调用了<code>FltSendMessage</code>，该函数使主线程进入了等待状态。</p><p>查阅<code>FltSendMessage</code>的文档，可以知道这个API是内核态的驱动程序向用户态的应用程序发消息时使用的，并且它是一个阻塞式的同步调用，如果应用程序没有调用<code>FilterGetMessage</code>来接收消息，驱动程序就会一直等待，直到消息被接收或者超时。</p><p>至此，问题的原因已经很清楚了，<code>cwNep.sys</code>驱动程序拦截了<code>ReadFile</code>调用，并且向用户态的应用程序发消息，而该应用程序没有及时接收这个消息，导致调用线程进入长时间的等待状态。</p><p>既然已经找到了肇事的驱动程序，那么可以继续找一下是哪个应用程序没有及时接收消息。基于程序可以从无响应中恢复的现象，可以确定要找的应用程序最终是成功调用了<code>FilterGetMessage</code>。从文档可知，<code>FilterGetMessage</code>既可以同步调用也可以异步调用，暂且假设它是被同步调用的，那么调用这个函数的线程，在接收到驱动程序的消息之后，必然会从等待状态切换到就绪状态，继而切换到执行状态，并且它开始执行的堆栈也是在<code>FilterGetMessage</code>内部。所以，可以在New Thread Stack这一列中查找<code>FilterGetMessage</code>关键字，如下所示：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/4.png" class=""><p>在这个案例中，运气不错，很快找到了唯一一个调用了<code>FilterGetMessage</code>的线程，如下所示：</p><img src="/2020/12/25/analyze-an-application-hang-caused-by-driver/5.png" class=""><p>由此确定这个没有及时接收消息的应用程序是<code>wepsvc.exe</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有客户投诉我们的程序经常无响应，几乎无法使用。我查看了问题现场，发现有以下表现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无响应时程序的CPU使用率基本保持为0%。&lt;/li&gt;
&lt;li&gt;如果一直放着不干预，一分钟左右程序是能恢复正常的。&lt;/li&gt;
&lt;li&gt;从转储文件看，程序是在调用&lt;code&gt;ReadFile&lt;/code&gt;读取文件内容时出现无响应的，部分的堆栈如下所示：&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="性能" scheme="http://zplutor.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
    <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="Windows Performance Toolkit" scheme="http://zplutor.github.io/tags/Windows-Performance-Toolkit/"/>
    
  </entry>
  
  <entry>
    <title>如何判断一个类型是否可比较</title>
    <link href="http://zplutor.github.io/2020/11/21/how-to-check-if-a-type-is-comparable/"/>
    <id>http://zplutor.github.io/2020/11/21/how-to-check-if-a-type-is-comparable/</id>
    <published>2020-11-21T14:21:23.000Z</published>
    <updated>2020-11-21T14:32:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个用户定义类型，如果定义了<code>operator==</code>或者<code>operator&lt;</code>等比较函数，那么这个类型就是可比较的。在实现一些工具库的时候，可能需要知道某个类型是否可比较，例如，想要知道是否可以使用<code>==</code>操作符来比较两个类对象是否相等，那么可以使用下面的模板类来判断：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsEqualityComparable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">Test</span><span class="params">(K*)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;K&gt;() == std::declval&lt;K&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Test</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> Value = std::is_same_v&lt;<span class="type">bool</span>, <span class="keyword">decltype</span>(<span class="built_in">Test</span>&lt;T&gt;(<span class="literal">nullptr</span>))&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内置类型和标准库类型</span></span><br><span class="line">std::cout &lt;&lt; IsEqualityComparable&lt;<span class="type">int</span>&gt;::Value;    <span class="comment">// true</span></span><br><span class="line">std::cout &lt;&lt; IsEqualityComparable&lt;std::string&gt;::Value; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有比较操作符的自定义类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComaprableObject</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ComaprableObject&amp; o1, <span class="type">const</span> ComaprableObject&amp; o2) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; IsEqualityComparable&lt;ComaprableObject&gt;::Value <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没有比较操作符的自定义类型</span></span><br><span class="line"><span class="keyword">class</span> UncomparableObject &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; IsEqualityComparable&lt;ComaprableObject&gt;::Value <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这个模板类型基于C++的SFINAE特性，关于这个特性的解释，可以参考之前的文章<a href="http://zplutor.github.io/2019/04/10/how-to-check-whether-a-container-is-an-associative-container/">《如何判断一个容器是否关联容器》</a>，在这篇文章里，也基于SFINAE特性实现了一个判断某类型是否关联容器的模板类。</p><p><code>IsEqualityComparable</code>使用了<code>std::is_same_v</code>来推导结果，它检查<code>Test&lt;T&gt;(nullptr)</code>这个函数调用表达式的返回值类型是否<code>bool</code>，如果是，则<code>T</code>可以用<code>==</code>进行比较，如果不是则不可以比较。</p><p>为了让<code>Test&lt;T&gt;(nullptr)</code>这个表达式对不同类型有不同的返回值，这里定义了两个重载的<code>Test</code>模板方法，其中第一个的声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">Test</span><span class="params">(K*)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;K&gt;() == std::declval&lt;K&gt;())</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法的返回值类型通过<code>decltype</code>来推导，而推导的来源正是模板类型<code>K</code>的<code>==</code>表达式，如果<code>K</code>可以比较，那么这个方法是有效的，返回值类型是<code>bool</code>；如果<code>K</code>不可以比较，那么根据SFINAE，这个方法会被删除，就像从未存在过一样。注意<code>std::declval</code>的使用，这个函数可以在不调用构造函数的前提下生成一个<code>K</code>的引用，以便使用者直接访问<code>K</code>的接口。这意味着使用者不需要知道如何构造<code>K</code>的对象，因为<code>==</code>只能作用于对象上，在比较之前必须先有对象，为了创建对象，使用者要调用<code>K</code>的构造方法。由于每个类型的构造方法都不一样，这里就没办法做到广泛适用。而<code>std::declval</code>绕过了构造方法，避免了这个问题。</p><p>第二个重载的<code>Test</code>模板方法如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Test</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法是“没有选择时的最后选择“。如果第一个模板方法被删除了，那么<code>Test&lt;T&gt;(nullptr)</code>这个表达式就会匹配到这个模板方法，表达式的返回值类型是<code>int</code>；如果第一个模板方法有效，那么表达式会优先匹配第一个方法，因为参数为<code>...</code>的重载方法优先级是最低的，此时表达式的返回值类型是<code>bool</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于一个用户定义类型，如果定义了&lt;code&gt;operator==&lt;/code&gt;或者&lt;code&gt;operator&amp;lt;&lt;/code&gt;等比较函数，那么这个类型就是可比较的。在实现一些工具库的时候，可能需要知道某个类型是否可比较，例如，想要知道是否可以使用&lt;code&gt;==&lt;/code&gt;操作符来比较两个类对象是否相等，那么可以使用下面的模板类来判断：&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio并行编译失效的原因</title>
    <link href="http://zplutor.github.io/2019/12/29/why-multi-processor-compile-option-not-work/"/>
    <id>http://zplutor.github.io/2019/12/29/why-multi-processor-compile-option-not-work/</id>
    <published>2019-12-29T12:48:44.000Z</published>
    <updated>2019-12-29T12:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于大型C++项目来说，并行编译开关<code>/MP</code>是必不可少的编译器选项，它能显著提高项目的编译速度。但是，当我在自己所在的项目中开启了这个选项之后，发现没有什么效果，只有少数文件可以并行编译，大多数文件仍然是串行编译的，编译时CPU使用率只有30%~40%。这个问题困扰了我们项目组很久。</p><span id="more"></span><p>最近，我在Visual Studio的社区里发现了一个反馈，内容是说当显式指定了.obj文件的输出文件名时，<code>/MP</code>选项会失效。而Visual Studio的官方团队也解释说这确实是编译器的缺陷，因为编译器是以传递给编译器的参数来决定编译单元是否能并行编译的，只有编译参数一模一样的编译单元才能够并行。</p><p>于是我立即查看我们工程的设置，发现.obj文件的输出文件名确实被修改了，如下图所示：</p><img src="/2019/12/29/why-multi-processor-compile-option-not-work/1.png" class=""><p>这个值的意思是，按照源文件的相对路径来输出.obj文件。默认情况下，工程里所有源文件编译后的.obj文件都会输出到同一个目录中，一旦在不同目录下存在名字相同的源文件，它们输出的.obj文件就会相互覆盖，在大型工程里这个问题很容易遇到。所以，为了避免这个问题，我们在这个设置项加上了<code>%(RelativeDir)</code>。</p><p>这样一来，虽然解决了名字冲突的问题，却带来了并行编译失效的问题。由于<code>%(RelativeDir)</code>的值是随着源文件所在目录而改变的，所以不同目录下的源文件其编译参数都不一样，它们就无法并行编译了。只有同一个目录下的源文件才能并行编译。</p><p>去掉了这个设置之后，<code>/MP</code>选项终于恢复了该有的效率，在编译时CPU使用率一直在90%以上，整个工程的编译时间缩短了一半。当然，代价是必须逐个处理名字冲突的源文件，要么改名字，要么改.obj文件的输出路径。</p><p>在上述的反馈中，Visual Studio团队已经在着手修复这个问题，希望在不久的将来能恢复使用<code>%(RelativeDir)</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于大型C++项目来说，并行编译开关&lt;code&gt;/MP&lt;/code&gt;是必不可少的编译器选项，它能显著提高项目的编译速度。但是，当我在自己所在的项目中开启了这个选项之后，发现没有什么效果，只有少数文件可以并行编译，大多数文件仍然是串行编译的，编译时CPU使用率只有30%~40%。这个问题困扰了我们项目组很久。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="Visual Studio" scheme="http://zplutor.github.io/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>为什么隐藏Owned窗口时，Owner窗口会被后置</title>
    <link href="http://zplutor.github.io/2019/07/06/why-the-owner-window-would-be-put-at-back-when-its-owned-window-hides/"/>
    <id>http://zplutor.github.io/2019/07/06/why-the-owner-window-would-be-put-at-back-when-its-owned-window-hides/</id>
    <published>2019-07-06T08:44:21.000Z</published>
    <updated>2020-11-21T14:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发的时候遇到一个怪异的问题，问题背景：在程序中，有一个Owner窗口拥有多个Owned窗口，当关闭Owned窗口时，会调用<code>ShowWindow</code>来隐藏该窗口，而不是真正的关闭。当最后一个Owned窗口隐藏时，理论上应该要激活Owner窗口，然而实际上激活的是位于Owner窗口下面的另外一个窗口。</p><span id="more"></span><p>经过一番检查，最终发现问题的根源在于Owned窗口的样式：如果Owned窗口具有<code>WS_OVERLAPPED</code>样式，就会出现该问题；而把样式改成<code>WS_POPUP</code>之后，问题就会消失。</p><p>可以用以下的代码来试验：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(HINSTANCE instance, HINSTANCE, LPWSTR, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册Owner窗口类</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Owner窗口</span></span><br><span class="line">    HWND owner_window = <span class="built_in">CreateWindow</span>(</span><br><span class="line">        <span class="string">L&quot;OwnerWindowClass&quot;</span>, </span><br><span class="line">        <span class="string">L&quot;Owner&quot;</span>, </span><br><span class="line">        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_VISIBLE,</span><br><span class="line">        CW_USEDEFAULT, </span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        instance,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册Owned窗口类，使用OwnedWindowProcedure作为窗口过程函数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第一个Owned窗口</span></span><br><span class="line">    HWND owned_window1 = <span class="built_in">CreateWindow</span>(</span><br><span class="line">        <span class="string">L&quot;OwnedWindowClass&quot;</span>, </span><br><span class="line">        <span class="string">L&quot;Owned&quot;</span>,</span><br><span class="line">        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_VISIBLE,</span><br><span class="line">        <span class="number">0</span>, </span><br><span class="line">        <span class="number">0</span>, </span><br><span class="line">        <span class="number">500</span>,</span><br><span class="line">        <span class="number">500</span>,</span><br><span class="line">        owner_window,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        instance,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第二个Owned窗口</span></span><br><span class="line">    HWND owned_window2 = <span class="built_in">CreateWindow</span>(</span><br><span class="line">        <span class="string">L&quot;OwnedWindowClass&quot;</span>,</span><br><span class="line">        <span class="string">L&quot;Owned&quot;</span>,</span><br><span class="line">        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_VISIBLE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">500</span>,</span><br><span class="line">        <span class="number">500</span>,</span><br><span class="line">        owner_window,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        instance,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG message&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;message, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;message);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">OwnedWindowProcedure</span><span class="params">(HWND window_handle, UINT message, WPARAM wparam, LPARAM lparam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截关闭行为，改成隐藏</span></span><br><span class="line">    <span class="keyword">if</span> (message == WM_CLOSE) &#123;</span><br><span class="line">        <span class="built_in">ShowWindow</span>(window_handle, SW_HIDE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(window_handle, message, wparam, lparam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，会显示一个Owner窗口和两个Owned窗口。逐个关闭Owned窗口，在关闭最后一个窗口时，如果桌面上存在其它窗口，那么必然会激活其它窗口，而不是Owner窗口。把Owned窗口的样式改成<code>WS_POPUP</code>之后，就不会再出现这个现象了。</p><p>从这个问题可以看出，Overlapped窗口和Popup窗口并不仅仅是默认有无边框的区别，在一些细节行为上，这两种窗口会有不同的表现。一般来说，<code>WS_OVERLAPPED</code>样式用于顶层的Owner窗口，而Owned窗口应尽量使用<code>WS_POPUP</code>样式，这样可以避免出现一些意料之外的表现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在开发的时候遇到一个怪异的问题，问题背景：在程序中，有一个Owner窗口拥有多个Owned窗口，当关闭Owned窗口时，会调用&lt;code&gt;ShowWindow&lt;/code&gt;来隐藏该窗口，而不是真正的关闭。当最后一个Owned窗口隐藏时，理论上应该要激活Owner窗口，然而实际上激活的是位于Owner窗口下面的另外一个窗口。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>如何判断一个容器是否关联容器</title>
    <link href="http://zplutor.github.io/2019/04/10/how-to-check-whether-a-container-is-an-associative-container/"/>
    <id>http://zplutor.github.io/2019/04/10/how-to-check-whether-a-container-is-an-associative-container/</id>
    <published>2019-04-09T16:56:50.000Z</published>
    <updated>2019-04-09T17:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你正在编写一个C++工具库，那么有可能需要知道一个容器是否关联容器。例如，你要写一个<code>Contain()</code>工具函数，该函数用来判断元素是否在容器中。而且你希望对于不同的容器，总是使用性能最优的查找方式，也就是说，对于关联容器，使用<code>find()</code>成员函数；而对于非关联容器，则使用<code>std::find()</code>函数。</p><span id="more"></span><p>此时，你也许需要使用模板元编程。在STL中，所有关联容器都有一个特征：定义了<code>key_type</code>成员类型，根据这个特征即可判断某个类型是否关联容器。</p><p>进行这个判断的模板元类型如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsAssociativeContainer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="keyword">typename</span> T::key_type*)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">Test</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> Value = <span class="built_in">Test</span>&lt;C&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; IsAssociativeContainer&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;::Value;    <span class="comment">// false</span></span><br><span class="line">std::cout &lt;&lt; IsAssociativeContainer&lt;std::list&lt;<span class="type">int</span>&gt;&gt;::Value;      <span class="comment">// false</span></span><br><span class="line">std::cout &lt;&lt; IsAssociativeContainer&lt;std::set&lt;<span class="type">int</span>&gt;&gt;::Value;       <span class="comment">// true</span></span><br><span class="line">std::cout &lt;&lt; IsAssociativeContainer&lt;std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::Value;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>IsAssociativeContainer</code>的实现使用了C++模板的SFINAE技术，全称为“Substitution Failure Is Not An Error”，它的意思是：当编译器试图在多个重载的模板函数中查找最佳匹配时，如果某个函数的模板参数推导失败，那么这个函数会被丢弃，而不会出现编译错误。</p><p>首先，在<code>IsAssociativeContainer</code>内部，定义了两个重载的<code>Test()</code>模板函数，第一个重载带有<code>T::key_type*</code>参数，对应关联容器类型，该函数返回<code>true</code>；第二个重载接受可变参数，对应非关联容器类型，该函数返回<code>false</code>。</p><p>然后，在定义静态常量<code>Value</code>时，使用<code>Test&lt;C&gt;(nullptr)</code>对其赋值。这里正是C++魔法起作用的时刻：编译器要在两个<code>Test()</code>重载函数中找到最佳匹配，使用它的返回值作为<code>Value</code>的值。假如模板类型<code>C</code>不是关联容器，它没有<code>key_type</code>成员类型，那么编译器在推导第一个重载的时候会失败，这个重载函数随即被丢弃，就像它从来没有出现过那样，所以编译器只能选择第二个重载。假如<code>C</code>是关联容器，它具有<code>key_type</code>成员类型，那么两个重载函数都能推导成功，此时编译器会优先选择第一个重载，因为接受可变参数的重载函数优先级是最低的。这种只接受可变参数的模板函数经常与SFINAE一起使用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你正在编写一个C++工具库，那么有可能需要知道一个容器是否关联容器。例如，你要写一个&lt;code&gt;Contain()&lt;/code&gt;工具函数，该函数用来判断元素是否在容器中。而且你希望对于不同的容器，总是使用性能最优的查找方式，也就是说，对于关联容器，使用&lt;code&gt;find()&lt;/code&gt;成员函数；而对于非关联容器，则使用&lt;code&gt;std::find()&lt;/code&gt;函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何避免预创建的CEF浏览器抢夺焦点</title>
    <link href="http://zplutor.github.io/2018/12/16/how-to-stop-precreated-cef-browser-stealing-focus/"/>
    <id>http://zplutor.github.io/2018/12/16/how-to-stop-precreated-cef-browser-stealing-focus/</id>
    <published>2018-12-16T12:34:57.000Z</published>
    <updated>2018-12-16T12:36:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在越来越多程序使用CEF浏览器来展示界面内容，以Web页面模拟原生界面。这种程序的Web页面内容大部分都来源于本地，因此加载速度一般都会很快。但是，与加载内容形成明显对比的是，创建CEF浏览器很耗时，大约需要1~2秒，这对用户体验造成很大影响。</p><span id="more"></span><p>解决这个问题的方法一般是采用预创建技术，即在展示Web页面之前，在后台预先创建好CEF浏览器，等到需要展示Web页面时，直接拿出这个浏览器使用，省去了创建的时间。</p><p>不过，在实践中发现，使用了预创建之后，会带来另一个问题：在创建浏览器的那一刻，窗口焦点会被它抢夺走，前台的窗口会莫名其妙地突然失去焦点，用户体验也很糟糕。</p><p>在CEF提供的接口中，有一个<code>CefFocusHandler</code>接口，其中有一个<code>OnSetFocus</code>方法，在浏览器窗口即将获取焦点之前会调用该方法，如果这个方法返回true，则可以阻止浏览器窗口获取焦点。这是在CEF中唯一跟焦点有关的接口，因此首先会想到利用这个方法来解决抢夺焦点问题。然而实践证明这个方法没有任何作用，因为它只处理“浏览器窗口”自身的焦点，而不处理父窗口的焦点。</p><p>CEF浏览器一般是作为其它窗口的子窗口，因此在预创建浏览器时，也必须指定父窗口。通常会使用一个不可见的窗口来充当浏览器的父窗口。如果使用Spy++工具来观察窗口的消息流，会发现在<code>OnSetFocus</code>返回true的情况下，浏览器窗口的确不会再收到<code>WM_SETFOCUS</code>消息；但父窗口不受影响，总是会收到<code>WM_SETFOCUS</code>消息，从而抢夺了焦点。</p><p>目前尚不清楚为什么父窗口会收到<code>WM_SETFOCUS</code>消息，可能是CEF有意将焦点设置到父窗口，也可能是CEF调用的某个API的副作用。既然不能通过CEF提供的接口解决，那只能使用其它变通方法。</p><p>由于一个被禁用的窗口永远不能取得焦点，所以一个行之有效的方法是：把父窗口设置成禁用，即在创建父窗口的时候设置<code>WS_DISABLED</code>样式。经过验证，这样做可以正常创建CEF浏览器，并且不会引起其它副作用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在越来越多程序使用CEF浏览器来展示界面内容，以Web页面模拟原生界面。这种程序的Web页面内容大部分都来源于本地，因此加载速度一般都会很快。但是，与加载内容形成明显对比的是，创建CEF浏览器很耗时，大约需要1~2秒，这对用户体验造成很大影响。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>文件的共享模式和访问权限</title>
    <link href="http://zplutor.github.io/2018/08/26/file-share-mode-and-access-rights/"/>
    <id>http://zplutor.github.io/2018/08/26/file-share-mode-and-access-rights/</id>
    <published>2018-08-26T14:04:12.000Z</published>
    <updated>2018-08-26T14:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>有用户反馈了这样一个问题：当Word或者Excel打开了一个文件时，无法用我们的程序打开该文件，而用其它程序却能够正常打开。经检查，这是由于在打开文件时<code>CreateFile</code>函数失败了，错误码是32，“另一个程序正在使用此文件，进程无法访问”。 </p><span id="more"></span><p>我检查了一遍代码，“看上去”似乎一切正常。但是为什么其它程序可以正常打开，就只有我们的程序不行呢？为了对比两者在打开文件上的差异，我使用ProcessMonitor来观察分别用Notepad++和我们程序打开同一个文件的过程。</p><p>经过对比，可以发现两者在执行CreateFile操作时，共享模式（ShareMode）的值明显不一样，如下所示：</p><img src="/2018/08/26/file-share-mode-and-access-rights/1.png" class=""><p>左图是Notepad++的CreateFile操作，ShareMode包含了Read和Write，操作结果为SUCCESS；右图是我们程序的CreateFile操作，ShareMode只有Read，操作结果为SHARING_VIOLATION。显然，问题出在调用<code>CreateFile</code>函数时传入的<code>dwShareMode</code>参数上，我们对该参数只传入了<code>FILE_SHARE_READ</code>。尝试加上<code>FILE_SHARE_WRITE</code>之后，问题解决了。</p><p>我又仔细阅读了一遍文档，发现一直以来我对共享模式的理解都不够全面（通过与其他人的交流，可以肯定不止我一个人是这样）。</p><p>共享模式实际上是用来与文件的访问权限进行校验的。假设进程A要打开一个文件，而该文件已经被进程B打开了，那么系统会进行以下校验：</p><ul><li>进程A传入的共享模式与进程B对该文件的访问权限（即打开文件时传入的<code>dwDesiredAccess</code>参数）是否一致；</li><li>进程A传入的访问权限与进程B的共享模式是否一致。</li></ul><p>共享模式与访问权限的一致性判断方式：</p><ul><li>如果共享模式包含读取，那么访问权限也必须包含读取；</li><li>如果共享模式包含写入，那么访问权限也必须包含写入。</li></ul><p>也就是说，系统会对双方的共享模式和访问权限进行交叉校验，只有两个校验都通过了，进程A才能打开文件，否则就会出现共享冲突错误。</p><p>所以，现在已不难理解为什么之前我们的程序打不开被Word和Excel打开的文件。Word和Excel必然对文件有写入权限，而我们的程序在打开文件时，共享模式只设置了读取，这意味着“我希望其它人只能读取该文件”，显然这是不可能的。</p><p>注意，为了便于理解，上面用了进程做例子，但实际上共享模式和访问权限都属于文件句柄的一部分，权限校验是针对句柄的。在一个进程中多次打开同一个文件，也会在文件句柄之间进行这些校验。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有用户反馈了这样一个问题：当Word或者Excel打开了一个文件时，无法用我们的程序打开该文件，而用其它程序却能够正常打开。经检查，这是由于在打开文件时&lt;code&gt;CreateFile&lt;/code&gt;函数失败了，错误码是32，“另一个程序正在使用此文件，进程无法访问”。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>修复微信快捷键截屏后无法使用输入法</title>
    <link href="http://zplutor.github.io/2018/06/14/fix-fail-to-use-ime-after-using-screen-capture-shortcut-of-wechat/"/>
    <id>http://zplutor.github.io/2018/06/14/fix-fail-to-use-ime-after-using-screen-capture-shortcut-of-wechat/</id>
    <published>2018-06-14T05:34:05.000Z</published>
    <updated>2018-10-20T02:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>你有没有遇到过不能使用输入法的问题？输入法明明切换出来了，也处于中文模式下，但无论如何也只能输入英文，非常令人恼火。此时不妨回想一下，在出现问题之前是否曾经使用微信的快捷键来截屏？</p><span id="more"></span><p>在某些系统下，使用微信的默认快捷键（ALT + A，或者ALT键与其它字符键的组合）截屏后有较大的概率会出现上述问题。微信似乎也意识到这个问题，在最新版本中作了修正。然而这个修正貌似治标不治本，只是降低了问题出现的概率，甚至没有作用——有些人仍然在截屏后几乎总是无法输入中文。</p><p>作为用户，除了重启程序之外，还有更简单的方法来解决这个问题：按一下ALT键即可。造成这个问题的原因是当我们按下ALT键时，是当前程序接收到按下事件；而在激活了微信截屏后，我们松开ALT键时，却是微信接收到松开事件。因此对于当前程序来说，ALT键一直处于按下状态，没有松开，这时我们按下的任何键实际上都变成了与ALT键的组合，除了无法使用输入法之外，还会导致CTRL + C、CTRL + V等快捷键失效。只要再按一下ALT键，重置这个键的状态，即可让程序恢复正常。当然，有个无法解释的问题是，为什么出现问题的时候，输入字符时不会触发与ALT键的组合快捷键？也许这与操作系统的实现方式有关，目前无从得知。</p><p>作为开发者，这个问题是需要解决的。虽然这是微信的缺陷，但问题却表现在我们的程序上，不明就里的用户肯定会以为是我们程序的问题。鉴于微信庞大的用户量，这个问题的影响还是挺大的。好在解决方法也简单：既然用户自己按一下ALT键就能恢复，那么我们在程序中检测出这种情况，再模拟按一下ALT键就好了。</p><p>为了检测出这种情况，可以结合使用<code>GetKeyState</code>和<code>GetAsyncKeyState</code>函数。从MSDN文档描述可知，<code>GetKeyState</code>获取的按键状态是通过按键的消息事件来维护的，而<code>GetAsyncKeyState</code>获取的按键状态是键盘的实际状态。既然截屏时当前程序接收不到ALT键松开的事件，那么<code>GetKeyState</code>返回的状态自然也不对了。所以，如果发现<code>GetKeyState</code>返回了按下状态，而<code>GetAsyncKeyState</code>返回了非按下状态，那么就可以确定出现了问题。</p><p>在截屏完成后，窗口焦点会从微信切换到当前程序，当前程序的窗口会收到<code>WM_ACTIVATEAPP</code>消息，这是进行上述检测的一个理想的时机。</p><p>最后，使用<code>SendInput</code>函数即可模拟按键事件。要注意的是，必须在处理<code>WM_ACTIVATEAPP</code>消息的下一个消息循环来调用该函数。为了统一处理，可以把检测代码一起放到下一个消息循环。</p><p>以下是解决该问题的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> UINT WM_REVISE_ALT_KEY = WM_USER + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((message == WM_ACTIVATEAPP) &amp;&amp; (wparam == TRUE)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口被激活后，在下一个消息循环修正ALT键的状态</span></span><br><span class="line">        <span class="built_in">PostMessage</span>(hwnd, WM_REVISE_ALT_KEY, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (message == WM_REVISE_ALT_KEY) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ALT键处于按下状态        </span></span><br><span class="line">        SHORT key_state = <span class="built_in">GetKeyState</span>(VK_MENU);</span><br><span class="line">        <span class="keyword">if</span> ((key_state &gt;&gt; <span class="number">15</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ALT键实际上没有按下</span></span><br><span class="line">            SHORT async_key_state = <span class="built_in">GetAsyncKeyState</span>(VK_MENU);</span><br><span class="line">            <span class="keyword">if</span> ((async_key_state &gt;&gt; <span class="number">15</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//模拟按下ALT键</span></span><br><span class="line">                INPUT inputs[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span>&amp; key_down_input = inputs[<span class="number">0</span>];</span><br><span class="line">                key_down_input.type = INPUT_KEYBOARD;</span><br><span class="line">                key_down_input.ki.wVk = VK_MENU;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span>&amp; key_up_input = inputs[<span class="number">1</span>];</span><br><span class="line">                key_up_input.type = INPUT_KEYBOARD;</span><br><span class="line">                key_up_input.ki.wVk = VK_MENU;</span><br><span class="line">                key_up_input.ki.dwFlags = KEYEVENTF_KEYUP;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">SendInput</span>(<span class="number">2</span>, inputs, <span class="built_in">sizeof</span>(INPUT));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallWindowProcedure</span>(DefWindowProc, message, wparam, lparam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;你有没有遇到过不能使用输入法的问题？输入法明明切换出来了，也处于中文模式下，但无论如何也只能输入英文，非常令人恼火。此时不妨回想一下，在出现问题之前是否曾经使用微信的快捷键来截屏？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>使用boost.filesystem检查文件是否存在的正确方式</title>
    <link href="http://zplutor.github.io/2018/04/09/proper-way-to-check-file-existence-using-boost-filesystem/"/>
    <id>http://zplutor.github.io/2018/04/09/proper-way-to-check-file-existence-using-boost-filesystem/</id>
    <published>2018-04-08T16:41:37.000Z</published>
    <updated>2018-04-08T16:46:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我参与的项目中，使用了boost.filesystem进行文件操作。boost.filesystem在发生错误的时候会抛出异常，但是在大部分情况下这些异常是可以忽略的，例如，在检查文件是否存在的时候，发生错误可以等同于文件不存在。虽然boost.filesystem也提供了重载函数，通过输出参数返回错误来代替异常，但是在每个调用点都得定义一个输出参数，稍显麻烦。所以，为了简化客户代码，我们实现了一些包装函数，如下所示：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsFileExistent</span><span class="params">(<span class="type">const</span> boost::filesystem::path&amp; path)</span> </span>&#123;</span><br><span class="line">    boost::system:error_code error;</span><br><span class="line">    <span class="keyword">return</span> boost::filesystem::<span class="built_in">is_regular_file</span>(path, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数用来检查文件是否存在，使用了<code>boost::filesystem::is_regular_file</code>。当<code>path</code>指向一个“常规文件”的时候，认为该文件存在；否则其它任何情况都认为文件不存在。</p><p>这个函数一直都很正常，直到最近有用户反馈，当发送OneDrive同步文件夹中的文件时，会出现文件不存在的提示，而这个文件明明是存在的。经过排查，我发现当OneDrive开启了“按需文件”功能时，<code>boost::filesystem::is_regular_file</code>对于同步文件夹中的文件会返回false。这个功能的设置界面如下图所示：</p><img src="/2018/04/09/proper-way-to-check-file-existence-using-boost-filesystem/1.png" class=""><p>当开启了“按需文件”功能时，OneDrive中的文件信息会同步到本地文件系统中，但文件内容不会立即同步，只有真正用到文件内容时才会同步下来。这样一来可以节省本地的硬盘空间。并不是所有Windows系统都支持该功能，只有安装了2017年10月份发布的<a href="https://blogs.windows.com/windowsexperience/2017/09/01/create-and-play-this-holiday-with-the-windows-10-fall-creators-update-coming-oct-17/#S6S0hTTo5v4hZw8X.97">秋季更新</a>的Windows 10系统才可以。</p><p>显然，当OneDrive中的文件还没有将内容同步下来时，它并不算是一个“常规文件”，难怪<code>boost::filesystem::is_regular_file</code>会返回false。事实上，用<code>boost::filesystem::status</code>获取这些文件的类型时，会返回<code>symlink_file</code>，boost.filesystem将它们视为符号链接文件。</p><p>不论是常规文件还是符号链接文件，呈现给用户的都是能够正常使用的文件。所以，不能单纯地用<code>boost::filesystem::is_regular_file</code>来检查文件是否存在了，下面是包装函数的改进版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsFileExistent</span><span class="params">(<span class="type">const</span> boost::filesystem::path&amp; path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    boost::system:error_code error;</span><br><span class="line">    <span class="keyword">auto</span> file_status = boost::filesystem::<span class="built_in">status</span>(path, error);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! boost::filesystem::<span class="built_in">exists</span>(file_status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boost::filesystem::<span class="built_in">is_directory</span>(file_status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过<code>boost::filesystem::status</code>获取文件的信息，如果发生错误，则认为文件不存在。然后，使用<code>boost::filesystem::exists</code>判断文件是否存在，该函数不区分文件夹和文件，所以最后还要使用<code>boost::filesystem::is_directory</code>判断一下是否文件夹，只要不是文件夹，都认为文件是存在的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我参与的项目中，使用了boost.filesystem进行文件操作。boost.filesystem在发生错误的时候会抛出异常，但是在大部分情况下这些异常是可以忽略的，例如，在检查文件是否存在的时候，发生错误可以等同于文件不存在。虽然boost.filesystem也提供了重载函数，通过输出参数返回错误来代替异常，但是在每个调用点都得定义一个输出参数，稍显麻烦。所以，为了简化客户代码，我们实现了一些包装函数，如下所示：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="boost" scheme="http://zplutor.github.io/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>如何调试程序静默退出</title>
    <link href="http://zplutor.github.io/2017/11/12/how-to-debug-program-silent-exit/"/>
    <id>http://zplutor.github.io/2017/11/12/how-to-debug-program-silent-exit/</id>
    <published>2017-11-12T05:11:42.000Z</published>
    <updated>2017-11-12T05:20:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>程序的静默退出，俗称闪退，是一个令人郁闷的问题。闪退发生的时候，没有任何提示，也没有留下任何现场信息（除了闪退之前一些没什么用的日志），导致很难去定位和解决。</p><span id="more"></span><p>总的来说，闪退一般是在以下几种情况下出现的：</p><ul><li><p>程序发生异常。有些特殊的异常会使异常捕获机制失效，因此我们准备好的错误报告，甚至是Windows的错误报告都不能正常执行。有时在Windows事件查看器中能看到对应的程序异常记录，但是这个记录的信息量太少，不足以定位异常。</p></li><li><p>程序被其它程序终止。听起来这有点匪夷所思，我的程序没有干任何坏事，为什么会无缘无故被终止？事实上这种情况确实发生过，举个例子：360安全卫士的某个版本会毫无预兆地终止企业微信。如果你恰好碰到了这样的问题，可以尝试把360安全卫士升级到最新版本。</p></li><li><p>程序自行终止。有些（设计不合理的）程序会在某些不能继续执行的情况下调用<code>TerminateProcess</code>来终止自己。通常在终止之前程序要进行提示或者留下一点日志，以方便调试。然而有的程序的确会给自己带来麻烦，终止之前不留下一丝痕迹。</p></li></ul><p>幸运的是，Windows已经针对闪退问题提供了专门的调试功能。这个功能需要使用GFlags工具来开启，GFlags包含在Windows SDK的Debugging Tools中，可以通过安装这个套件来获取。运行GFlags后，切换到Silent Process Exit标签（GFlags可以开启很多调试功能，闪退调试只是其中一个），参考下图来进行设置：</p><img src="/2017/11/12/how-to-debug-program-silent-exit/1.png" class=""><p>Silent Process Exit可以针对指定程序进行设置，也可以全局设置，一般只需要针对我们自己的程序设置即可。在Application Specific Settings的Image一栏，填入程序的可执行文件名称，然后按下TAB键，即可打开这个程序的设置。</p><p>在Reporting Mode一栏，首先勾选Enable Silent Process Exit Monitoring 选项，然后根据需要勾选其它四个选项。</p><ul><li><p>Enable dump collection，勾选了该选项后，程序退出的时候生成dump文件。该选项可以保留退出时的现场环境，一般都要勾选。同时需要填写Dump Folder Location和Dump Type两栏。</p></li><li><p>Launch monitor process，勾选了该选项后，程序退出的时候会启动指定的进程来调试。如果已经勾选了生成dump，那么不太必要再启动调试器了。同时需要填写Monitor Process一栏。</p></li><li><p>Enable notification，勾选了该选项后，程序退出的时候会在系统任务栏区域弹出提示。实践发现这个选项有时不生效，程序闪退时没有提示。</p></li><li><p>Ignore Self Exists，勾选了该选项后，程序自行的退出会被忽略。如果不勾选，程序每次正常退出时系统都会根据前面三个选项进行处理，勾选这个选项可以避免不必要的骚扰。可是实践发现这个选项有时也会不生效，有些程序正常退出也会触发前面选项的处理。</p></li></ul><p>这里以记事本程序<code>notepad.exe</code>为例子，按确定按钮保存设置。打开记事本，在任务管理器中结束它，此时系统任务栏会弹出提示：</p><img src="/2017/11/12/how-to-debug-program-silent-exit/2.png" class=""><p>在事件查看器中可以看到对应的记录。同时在<code>C:\</code>下生成了对应的dump文件：</p><img src="/2017/11/12/how-to-debug-program-silent-exit/3.png" class=""><p>Windows提供的这个调试功能非常方便，但是GFlags的使用方式仍有一定门槛，不是每个用户都能快速按照我们的指引来设置。为了节约沟通成本，最好能有一种自动化的方式来帮用户打开这个功能。事实上，GFlags是通过修改注册表来实现功能的，所以只要把对应的注册表项导出，再让用户导入即可。</p><p>以上面记事本的设置为例，对应的注册表项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe]</span><br><span class="line">&quot;GlobalFlag&quot;=dword:00000200</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe]</span><br><span class="line">&quot;LocalDumpFolder&quot;=&quot;C:\\&quot;</span><br><span class="line">&quot;DumpType&quot;=dword:00000121</span><br><span class="line">&quot;ReportingMode&quot;=dword:00000006</span><br><span class="line">&quot;IgnoreSelfExits&quot;=dword:00000001</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序的静默退出，俗称闪退，是一个令人郁闷的问题。闪退发生的时候，没有任何提示，也没有留下任何现场信息（除了闪退之前一些没什么用的日志），导致很难去定位和解决。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="异常" scheme="http://zplutor.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>在Visual Studio和XCode之间兼容性最好的文本编码</title>
    <link href="http://zplutor.github.io/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/"/>
    <id>http://zplutor.github.io/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/</id>
    <published>2017-04-02T06:42:04.000Z</published>
    <updated>2017-04-06T15:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨平台开发的文本编码问题"><a href="#跨平台开发的文本编码问题" class="headerlink" title="跨平台开发的文本编码问题"></a>跨平台开发的文本编码问题</h2><p>有一个跨平台的模块需要同时在Visual Studio 2013和XCode 8下开发，在开发过程中发现以下问题：</p><span id="more"></span><ul><li><p>在Visual Studio创建的代码文件，里面的中文注释在XCode下会显示成乱码：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/1.png" class=""></li><li><p>在XCode创建的代码文件，如果里面包含中文注释，在Visual Studio中编译时可能会产生C4819警告：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/2.png" class=""></li></ul><p>产生这些问题的原因是两款IDE对文本编码的支持方式不一致。为了解决它们，需要弄清楚Visual Studio和XCode的异同。</p><h2 id="Visual-Studio对文本编码的支持"><a href="#Visual-Studio对文本编码的支持" class="headerlink" title="Visual Studio对文本编码的支持"></a>Visual Studio对文本编码的支持</h2><p>Visual Studio的默认编码是ANSI，也就是Windows当前语言的编码。对于简体中文来说就是GB2312。默认编码无法设置。</p><p>打开了一个文件之后，在Visual Studio的“文件” - “高级保存选项”菜单中可以修改当前文件的编码：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/3.png" class=""><p>在弹出的对话框中可以选择各种编码：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/4.png" class=""><p>Visual Studio只能手动一个一个地转换文本编码，不能做到自动转换或者批量转换。</p><p>虽然在上面的列表中可以找到UTF-8 without BOM编码，并且Visual Studio也确实能够正确显示这种编码的文件内容，但实测发现编译器并不能很好地支持这种编码。例如，当文件中含有奇数个中文字符时，编译的时候会出现上文说的C4819警告；而当含有偶数个中文字符时，则一切正常。</p><h2 id="XCode对文本编码的支持"><a href="#XCode对文本编码的支持" class="headerlink" title="XCode对文本编码的支持"></a>XCode对文本编码的支持</h2><p>XCode的默认编码是UTF-8 without BOM，可以在Preferences中修改默认编码：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/5.png" class=""><p>在该选项中可以选择各种文本编码：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/6.png" class=""><p>然而实测发现这个选项没有什么用。修改之后，新建的文件仍然是UTF-8编码，打开的文件也不会使用指定编码。</p><p>XCode并没有区分UTF-8 with BOM和UTF-8 without BOM，默认是UTF-8 without BOM，但它还是能够打开和编辑UTF-8 with BOM编码的文件。</p><p>打开了一个文件后，在Utilities面板中可以查看和设置当前文件使用的编码：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/7.png" class=""><p>XCode的编码检测也不准确。例如，GB2312编码的文件会被检测为Western (Mac OS Roman)，导致中文显示成乱码。</p><p>通过下拉列表修改了文本编码后，XCode会弹出以下的对话框，询问是要转换编码还是重新解析文件：</p><img src="/2017/04/02/the-most-compatible-text-encoding-between-visual-studio-and-xcode/8.png" class=""><p>Convert选项会把当前文件转换成选择的编码；Reinterpret选项会以选择的编码重新解析当前文件。如果内容显示正常，只想改变编码的话，应该使用Convert；如果内容出现乱码，应该使用Reinterpret重新解析。</p><h2 id="选择兼容性最好的文本编码"><a href="#选择兼容性最好的文本编码" class="headerlink" title="选择兼容性最好的文本编码"></a>选择兼容性最好的文本编码</h2><p>综合两款IDE对文本编码的支持情况，可以知道能够同时被Visual Studio和XCode支持的文本编码是：</p><ul><li>UTF-8 with BOM</li><li>UTF-16 BE</li><li>UTF-16 LE</li><li>GB2312（以及其它区域语言）</li></ul><p>对于代码文件，UTF-16比较浪费空间，所以首先排除掉。至于GB2312等区域语言，由于XCode无法正确检测出这种编码的文件，每次打开的时候都要手工转换一下，所以也不是理想的选择。</p><p>最后只剩下UTF-8 with BOM。Visual Studio和XCode都能够直接打开和编辑这种编码的文件，无需进行任何转换。遗憾的是，两款IDE都不能直接创建这种编码的文件，只能在创建之后再手工转换一下（XCode需要借助工具来转换）。虽然存在这个不足，不过UTF-8 with BOM是当前情况下兼容性最好的选择。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;跨平台开发的文本编码问题&quot;&gt;&lt;a href=&quot;#跨平台开发的文本编码问题&quot; class=&quot;headerlink&quot; title=&quot;跨平台开发的文本编码问题&quot;&gt;&lt;/a&gt;跨平台开发的文本编码问题&lt;/h2&gt;&lt;p&gt;有一个跨平台的模块需要同时在Visual Studio 2013和XCode 8下开发，在开发过程中发现以下问题：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="字符编码" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
    <category term="macOS" scheme="http://zplutor.github.io/tags/macOS/"/>
    
    <category term="Visual Studio" scheme="http://zplutor.github.io/tags/Visual-Studio/"/>
    
    <category term="XCode" scheme="http://zplutor.github.io/tags/XCode/"/>
    
  </entry>
  
  <entry>
    <title>STL中的二分查找</title>
    <link href="http://zplutor.github.io/2017/03/14/binary-search-in-stl/"/>
    <id>http://zplutor.github.io/2017/03/14/binary-search-in-stl/</id>
    <published>2017-03-14T15:41:16.000Z</published>
    <updated>2017-03-14T16:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是重要且常用的算法，在STL中自然少不了它的身影。本文介绍一下在STL中与二分查找有关的函数。</p><span id="more"></span><p>要注意，这些函数都要求集合是有序的，在使用之前应使用<code>std::sort</code>等函数对集合进行排序。</p><h2 id="检查元素是否存在"><a href="#检查元素是否存在" class="headerlink" title="检查元素是否存在"></a>检查元素是否存在</h2><h3 id="std-binary-search"><a href="#std-binary-search" class="headerlink" title="std::binary_search"></a>std::binary_search</h3><p><code>std::binary_search</code>用来检查指定的元素是否存在集合中，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure><p>第一个原型使用<code>&lt;</code>操作符来比较元素，第二个原型使用指定的比较器来比较元素。比较器的比较规则应该与排序时使用的比较规则一致。</p><p>使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认比较器来查找元素</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">bool</span> exist;</span><br><span class="line">exist = std::<span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>); <span class="comment">// exist = true</span></span><br><span class="line">exist = std::<span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">4</span>); <span class="comment">// exist = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义比较器来查找元素</span></span><br><span class="line"><span class="keyword">auto</span> comparer = [](<span class="type">int</span> i1, <span class="type">int</span> i2) &#123;</span><br><span class="line">    <span class="keyword">return</span> i1 &gt; i2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), comparer); <span class="comment">// 9, 7, 5, 3, 1</span></span><br><span class="line">exist = std::<span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">5</span>, comparer); <span class="comment">//exist = true</span></span><br><span class="line">exist = std::<span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">6</span>, comparer); <span class="comment">//exist = false</span></span><br></pre></td></tr></table></figure><p><code>std::binary_search</code>至多需要进行<code>log2(last - first) + O(1)</code>次比较。</p><p><code>std::binary_search</code>的使用场景比较单一，它只能知道某个元素是否存在集合中。如果要获取元素的位置，需要使用下面的函数。</p><h2 id="获取元素位置"><a href="#获取元素位置" class="headerlink" title="获取元素位置"></a>获取元素位置</h2><h3 id="std-lower-bound"><a href="#std-lower-bound" class="headerlink" title="std::lower_bound"></a>std::lower_bound</h3><p><code>std::lower_bound</code>用来获取集合中第一个不小于指定值的元素位置，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure><p>第一个原型使用<code>&lt;</code>操作符来比较元素，第二个原型使用指定的比较器来比较元素。比较器的比较规则应该与排序时使用的比较规则一致。</p><p>使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator iterator;</span><br><span class="line">iterator = std::<span class="built_in">lower_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line"><span class="comment">// *iterator = 3</span></span><br><span class="line"></span><br><span class="line">iterator = std::<span class="built_in">lower_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">4</span>); </span><br><span class="line"><span class="comment">// *iterator = 5</span></span><br><span class="line"></span><br><span class="line">iterator = std::<span class="built_in">lower_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">11</span>); </span><br><span class="line"><span class="comment">// iterator = numbers.end()</span></span><br></pre></td></tr></table></figure><p>要注意，<code>std::lower_bound</code>返回的迭代器指向的是第一个不小于（即等于或大于）指定值的元素，所以在它返回之后还要再检查一次，以确认真的找到了该元素。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取集合</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = ...; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查找元素位置</span></span><br><span class="line"><span class="keyword">auto</span> iterator = std::<span class="built_in">lower_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line"><span class="keyword">if</span> (iterator != numbers.<span class="built_in">end</span>() &amp;&amp; *iterator == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">//集合中存在该元素，iterator指向它。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//集合中不存在该元素，iterator指向第一个大于它的元素，或集合末尾。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计的好处是，如果要执行的是“如果元素不存在则插入”的操作，那么可以直接往<code>iterator</code>指向的位置插入新元素，而不必担心破坏集合的有序性。</p><p><code>std::lower_bound</code>至多需要进行<code>log2(last - first) + O(1)</code>次比较。</p><h3 id="std-upper-bound"><a href="#std-upper-bound" class="headerlink" title="std::upper_bound"></a>std::upper_bound</h3><p>与<code>std::lower_bound</code>类似，<code>std::upper_bound</code>用来获取集合中第一个大于指定值的元素位置，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure><p>第一个原型使用<code>&lt;</code>操作符来比较元素，第二个原型使用指定的比较器来比较元素。比较器的比较规则应该与排序时使用的比较规则一致。</p><p>使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator iterator;</span><br><span class="line">iterator = std::<span class="built_in">upper_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line"><span class="comment">// *iterator = 5</span></span><br><span class="line"></span><br><span class="line">iterator = std::<span class="built_in">upper_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">4</span>); </span><br><span class="line"><span class="comment">// *iterator = 5</span></span><br><span class="line"></span><br><span class="line">iterator = std::<span class="built_in">upper_bound</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">11</span>); </span><br><span class="line"><span class="comment">// iterator = numbers.end()</span></span><br></pre></td></tr></table></figure><p>由于<code>std::upper_bound</code>返回的迭代器指向的是第一个大于指定值的元素，相对来说它的使用场景较<code>std::lower_bound</code>要少。</p><p><code>std::upper_bound</code>至多需要进行<code>log2(last - first) + O(1)</code>次比较。</p><h3 id="std-equal-range"><a href="#std-equal-range" class="headerlink" title="std::equal_range"></a>std::equal_range</h3><p><code>std::equal_range</code>用来获取集合中所有与指定值相等的元素范围，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">std::pair&lt;ForwardIt,ForwardIt&gt; <span class="title">equal_range</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function">std::pair&lt;ForwardIt,ForwardIt&gt; <span class="title">equal_range</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure><p>第一个原型使用<code>&lt;</code>操作符来比较元素，第二个原型使用指定的比较器来比较元素。比较器的比较规则应该与排序时使用的比较规则一致。</p><p><code>std::equal_range</code>返回一对迭代器，第一个迭代器指向第一个不小于指定值的元素（等同于<code>std::lower_bound</code>的返回值），第二个迭代器指向第一个大于指定值的元素（等同于<code>std::upper_bound</code>的返回值）。如果两个迭代器相等，说明不存在这样的元素。</p><p>使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">std::pair&lt;std::vector&lt;<span class="type">int</span>&gt;::iterator, std::vector&lt;<span class="type">int</span>&gt;::iterator&gt; iterator_pair;</span><br><span class="line">iterator_pair = std::<span class="built_in">equal_range</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line"><span class="comment">// *iterator_pair.first = 3, *iterator_pair.second = 5(1)  括号中的数字表示是第几个，下同</span></span><br><span class="line"></span><br><span class="line">iterator_pair = std::<span class="built_in">equal_range</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">5</span>); </span><br><span class="line"><span class="comment">// *iterator_pair.first = 5(1), *iterator_pair.second = 7</span></span><br><span class="line"></span><br><span class="line">iterator_pair = std::<span class="built_in">equal_range</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">8</span>); </span><br><span class="line"><span class="comment">// *iterator_pair.first = *iterator_pair.second = 9</span></span><br><span class="line"></span><br><span class="line">iterator_pair = std::<span class="built_in">equal_range</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">9</span>); </span><br><span class="line"><span class="comment">// *iterator_pair.first = 9, iterator_pair.second = numbers.end()</span></span><br><span class="line"></span><br><span class="line">iterator_pair = std::<span class="built_in">equal_range</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">11</span>); </span><br><span class="line"><span class="comment">// iterator_pair.first = iterator_pair.second = numbers.end()</span></span><br></pre></td></tr></table></figure><p><code>std::equal_range</code>至多需要进行<code>2 * log2(last - first) + O(1)</code>次比较，在性能上不如<code>std::lower_bound</code>和<code>std::upper_bound</code>，所以如果不需要获取相等元素区间的话，按需调用<code>std::lower_bound</code>或<code>std::upper_bound</code>是更好的选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找是重要且常用的算法，在STL中自然少不了它的身影。本文介绍一下在STL中与二分查找有关的函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>libcurl动态超时的陷阱</title>
    <link href="http://zplutor.github.io/2016/11/20/a-trap-of-dynamic-timeout-in-libcurl/"/>
    <id>http://zplutor.github.io/2016/11/20/a-trap-of-dynamic-timeout-in-libcurl/</id>
    <published>2016-11-20T14:35:41.000Z</published>
    <updated>2016-11-20T14:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在《<a href="http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/">如何设置libcurl的动态超时值</a>》中提到，动态超时值（通过<code>CURLOPT_LOW_SPEED_LIMIT</code>和<code>CURLOPT_LOW_SPEED_TIME</code>设置）比固定超时值（通过<code>CURLOPT_TIMEOUT</code>设置）更符合实际需要，所以我一般只设置动态超时值，而不设置固定超时值。然而，在实际使用中发现，有时网络请求会一直没有结束，也就是说设置的动态超时值在某些情况下会失效。在阅读了libcurl的源代码之后，我发现原来动态超时值存在一个陷阱。</p><span id="more"></span><p>简单地说，libcurl只在下载响应数据阶段才会检测动态超时，如果网络请求一直没有进入这个阶段，那么动态超时值就没有作用了。下面我们从libcurl的内部机制分析一下这个陷阱。</p><p>在libcurl内部，网络请求由Session对象表示，而Session对象由Multi对象管理。Multi对象是一个管理器，它自身维护一个定时器，每隔一段时间触发一次Session对象执行。也就是说，Session本身不会主动执行，而是由Multi来驱动执行， 如下图所示：</p><img src="/2016/11/20/a-trap-of-dynamic-timeout-in-libcurl/1.png" class=""><p>Session的实现是一个状态机，从请求开始到结束，大致要经过以下状态（这是一份精简过的状态，实际状态比这个复杂）：</p><ul><li>Init，初始化状态。</li><li>Connect，正在连接状态。</li><li>Do，正在发送请求数据状态。</li><li>WaitPerform，等待响应状态。</li><li>Perform，正在接收响应数据状态。</li><li>Completed，完成状态。</li></ul><p>一般情况下，只有当Session处于Perform状态时，libcurl才会检测动态超时。所以，一旦等不到服务器的响应，Session就会一直停留在WaitPerform状态，动态超时值也就没有任何作用了。</p><p>至于固定超时值，它的检测时机是在每次心跳触发Session对象执行的时候，与Session的状态机制没有任何关系，因此固定超时值总是有效的。</p><p>可见，licurl的超时机制并不够好——动态超时值不可靠，固定超时值又不能满足需求。那么在实践中应该如何做呢？有两种方法可供选择。首先，如果条件允许的话，可以摒弃libcurl的超时机制，自己来实现。这样的好处是可以自主控制超时，具有最大的灵活性。当然，这种方法复杂度较高，大部分情况下条件也不允许。</p><p>其次，可以通过不断设置固定超时值来模拟动态超时。例如，每收到libcurl的一次进度回调，就重新设置一个更大的固定超时值。虽然官方文档并没有明说，但从libcurl的源代码来看，这种做法是可行的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在《&lt;a href=&quot;http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/&quot;&gt;如何设置libcurl的动态超时值&lt;/a&gt;》中提到，动态超时值（通过&lt;code&gt;CURLOPT_LOW_SPEED_LIMIT&lt;/code&gt;和&lt;code&gt;CURLOPT_LOW_SPEED_TIME&lt;/code&gt;设置）比固定超时值（通过&lt;code&gt;CURLOPT_TIMEOUT&lt;/code&gt;设置）更符合实际需要，所以我一般只设置动态超时值，而不设置固定超时值。然而，在实际使用中发现，有时网络请求会一直没有结束，也就是说设置的动态超时值在某些情况下会失效。在阅读了libcurl的源代码之后，我发现原来动态超时值存在一个陷阱。&lt;/p&gt;</summary>
    
    
    
    
    <category term="libcurl" scheme="http://zplutor.github.io/tags/libcurl/"/>
    
    <category term="超时" scheme="http://zplutor.github.io/tags/%E8%B6%85%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>如何让指定的程序崩溃</title>
    <link href="http://zplutor.github.io/2016/09/08/how-to-make-a-specified-application-crash/"/>
    <id>http://zplutor.github.io/2016/09/08/how-to-make-a-specified-application-crash/</id>
    <published>2016-09-08T12:24:38.000Z</published>
    <updated>2016-09-08T12:42:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了验证程序崩溃信息的收集和上报机制，需要让程序崩溃。为了达到这个目的，一般的做法是临时在程序中加入引发异常的代码。这种做法只在开发人员自己编译的版本中有效，在正式版本中无法进行验证。另外一种方法是加入一个隐藏开关，但这样会在正式版本中带上调试代码，也不理想。最好的方法是在不修改任何代码的前提下，也能够让程序崩溃。</p><span id="more"></span><p>这看起来似乎不可能，但实际上是可行的，而且做法简单得让人惊讶。Windows API有一个<code>CreateRemoteThread</code>函数，这个函数可以在指定的进程中创建一个线程，并且能够让这个线程执行任意代码——DLL注入就是通过这种方式实现的。显然，只要用这个函数创建一个会产生异常的线程就可以了。先来看一下这个函数的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  HANDLE                 hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  SIZE_T                 dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPVOID                 lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  DWORD                  dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ LPDWORD                lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>值得关注的是<code>hProcess</code>和<code>lpStartAddress</code>参数，其它参数的含义可以参考MSDN文档，这里不再赘述。先来看<code>lpStartAddress</code>参数，这个参数指定线程的入口点地址，这个地址必须是在目标进程的地址空间中。在本文的特殊需求下，我们并不需要传一个实际可执行的地址，只需要传入<code>0</code>即可。这样的话，该线程会尝试从0地址执行，这毫无疑问会引发访问违规异常，导致程序崩溃——这就达到了我们的目的。</p><p>再来看<code>hProcess</code>参数，这个参数表示目标进程的句柄，这个句柄必须具有以下访问权限：</p><ul><li>PROCESS_CREATE_THREAD</li><li>PROCESS_QUERY_INFORMATION</li><li>PROCESS_VM_OPERATION</li><li>PROCESS_VM_WRITE</li><li>PROCESS_VM_READ</li></ul><p>有了这些基础知识，我们就可以写一个简单的命令行程序来让指定的进程崩溃了。完整的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        std::wcout &lt;&lt; <span class="string">L&quot;A PID is needed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        std::wcout &lt;&lt; <span class="string">L&quot;Invalid PID.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE process_handle = <span class="built_in">OpenProcess</span>(</span><br><span class="line">        PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,</span><br><span class="line">        FALSE,</span><br><span class="line">        pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process_handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::wcout &lt;&lt; <span class="string">L&quot;Open process failed. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE thread_handle = <span class="built_in">CreateRemoteThread</span>(process_handle, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (thread_handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::wcout &lt;&lt; <span class="string">L&quot;Create remote thread failed. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;Crashed. :)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设这个命令行程序的名称是<code>crasher.exe</code>，目标进程的PID是<code>10032</code>，那么只要像下面这样调用就能让这个进程崩溃：</p><pre><code>crasher.exe 10032</code></pre><p>如果你的目标进程是一个普通程序，那么本文到这里就结束了。但如果你的目标进程是一个服务程序，情况就有所不同了。CreateRemoteThread有一个限制，它不能跨会话来创建线程。例如，服务程序都在0号会话下运行，而制造崩溃的程序是在当前用户登录的会话下运行（必定不是0号会话），所以CreateRemoteThread的调用会失败。为了解决这个问题，需要让制造崩溃的程序转移到0号会话下运行。可以借助Sysinternals出品的<code>PsExec</code>工具来实现这个目的，只要执行下面的命令行即可：</p><pre><code>PsExec.exe -accepteula -s crasher.exe 10032</code></pre><p><code>-accepteula</code>参数表示接受Sysinternals的最终用户许可协议。Sysinternals的工具在首次使用的时候都会弹出最终用户许可协议对话框，使用这个参数可以防止对话框弹出。<code>-s</code>表示在系统会话，也就是0号会话中执行后面的命令。最终效果就是在0号会话中执行了<code>crasher.exe 10032</code>这个命令。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了验证程序崩溃信息的收集和上报机制，需要让程序崩溃。为了达到这个目的，一般的做法是临时在程序中加入引发异常的代码。这种做法只在开发人员自己编译的版本中有效，在正式版本中无法进行验证。另外一种方法是加入一个隐藏开关，但这样会在正式版本中带上调试代码，也不理想。最好的方法是在不修改任何代码的前提下，也能够让程序崩溃。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="异常" scheme="http://zplutor.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>使用ProcDump捕获程序崩溃信息</title>
    <link href="http://zplutor.github.io/2016/08/15/catch-application-crashing-information-with-procdump/"/>
    <id>http://zplutor.github.io/2016/08/15/catch-application-crashing-information-with-procdump/</id>
    <published>2016-08-15T14:04:57.000Z</published>
    <updated>2016-08-15T14:09:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>当程序崩溃的时候，捕获崩溃信息并进行上报对提升产品质量有很大帮助，它能发现很多在开发和测试阶段发现不了的问题。Windows的WER（Windows Error Reporting）组件在系统级别上提供了捕获崩溃信息的能力，它能够在程序崩溃时生成一个内存转储文件（即dump文件），该文件包含了引发崩溃的异常信息。然而，这个功能仅在Windows Vista SP1及更高的版本中存在，而且它是可配置的，用户可以阻止WER生成dump文件。这意味着我们不能依赖系统来捕获崩溃信息，而是要通过别的途径。</p><span id="more"></span><p>其中一个可选的方案是使用Sysinternals出品的ProcDump。ProcDump是一个命令行工具，它其中的一个功能就是用来捕获程序的崩溃信息。该方案的流程如下：</p><ul><li>在程序开始执行的时候，启动ProcDump，并且把自己的进程ID传递给它，让它一直监视该进程。</li><li>ProcDump一直在后台运行，直到程序正常退出，或者发生崩溃。在后一种情况下，ProcDump会在指定的目录生成dump文件。</li><li>程序下一次启动时，发现存在dump文件，进行上报。</li></ul><p>可见，这种方案非常简单，只要用正确的参数启动ProcDump即可。假设我们的程序安装在<code>C:\MyApp</code>，进程ID是<code>10032</code>，则启动ProcDump的命令行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\MyApp\bin\procdump.exe&quot; -accepteula -e 10032 &quot;C:\MyApp\dump&quot;</span><br></pre></td></tr></table></figure><p>启动ProcDump时最好指定<code>procdump.exe</code>的绝对路径，避免进程工作目录改变带来的问题。第一个参数<code>-accepteula</code>表示接受Sysinternals的最终用户许可协议。Sysinternals的工具在首次使用的时候都会弹出最终用户许可协议对话框，使用这个参数可以防止对话框弹出。第二个参数<code>-e</code>表示在进程发生未处理异常（也就是崩溃）时生成dump文件。第四个参数是进程ID，表示让ProcDump监视哪个进程。最后一个参数指定dump文件存放的文件夹路径，要注意的是，这个文件夹必须要预先创建，否则ProcDump会认为这是一个文件路径，并向这个路径写数据，导致异常行为。</p><p>最后，程序需要在启动的时候拼接好上述命令行，并调用<code>CreateProcess</code>来启动该命令行。要记得在调用时给<code>dwCreationFlags</code>参数传入<code>CREATE_NO_WINDOW</code>，防止出现控制台窗口。</p><p>这个方案实现简单，学习成本低，即使不了解异常相关的机理也可以快速实现崩溃信息收集。但它有一个弊端：ProcDump是以调试器的的身份附加到指定进程上的，进程中发生的调试事件（例如线程的创建和销毁）会导致进程间通信开销，这会稍微影响程序的性能。如果这些性能开销不可接受，则要考虑其它的方案。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当程序崩溃的时候，捕获崩溃信息并进行上报对提升产品质量有很大帮助，它能发现很多在开发和测试阶段发现不了的问题。Windows的WER（Windows Error Reporting）组件在系统级别上提供了捕获崩溃信息的能力，它能够在程序崩溃时生成一个内存转储文件（即dump文件），该文件包含了引发崩溃的异常信息。然而，这个功能仅在Windows Vista SP1及更高的版本中存在，而且它是可配置的，用户可以阻止WER生成dump文件。这意味着我们不能依赖系统来捕获崩溃信息，而是要通过别的途径。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="procdump" scheme="http://zplutor.github.io/tags/procdump/"/>
    
  </entry>
  
  <entry>
    <title>使用std::wstring_convert进行字符编码转换</title>
    <link href="http://zplutor.github.io/2016/07/03/convert-character-encoding-using-std-wstring-convert/"/>
    <id>http://zplutor.github.io/2016/07/03/convert-character-encoding-using-std-wstring-convert/</id>
    <published>2016-07-03T06:00:49.000Z</published>
    <updated>2018-04-08T16:57:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11新增的std::wstring_convert可以很方便地在std::string和std::wstring之间进行转换。例如，把一个std::wstring转换成以UTF-8编码的std::string：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::wstring_convert&lt;std::codecvt_utf8&lt;<span class="type">wchar_t</span>&gt;&gt; converter;</span><br><span class="line">std::string string = converter.<span class="built_in">to_bytes</span>(<span class="string">L&quot;这是一个宽字符串&quot;</span>);</span><br></pre></td></tr></table></figure><p>反过来，把一个以UTF-8编码的std::string转换成std::wstring：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::wstring_convert&lt;std::codecvt_utf8&lt;<span class="type">wchar_t</span>&gt;&gt; converter;</span><br><span class="line">std::wstring wide_string = converter.<span class="built_in">from_bytes</span>(<span class="string">&quot;\xe5\xad\x97\xe7\xac\xa6\xe4\xb8\xb2”);  //字符串的内容为“字符串”</span></span><br></pre></td></tr></table></figure><p>std::wstring_convert使用模板参数中指定的codecvt进行实际的转换工作，也就是说，std::string使用哪种字符编码由这个codecvt来决定。上面的例子用的是std::codecvt_utf8，即UTF-8编码。理论上，指定不同的codecvt，即可支持各种字符编码。但是，如何得到合适codecvt则是不小的问题。</p><p>来看一下std::wstring_convert其中一个构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wstring_convert</span>(codecvt* pcvt = <span class="keyword">new</span> codecvt);</span><br></pre></td></tr></table></figure><p>在构造std::wstring_convert对象的时候需要传入一个codecvt对象的指针，如果没有传入，则默认使用<code>new codecvt</code>来创建。std::wstring_convert自行维护codecvt对象的生命周期，它的析构函数会调用delete操作符来删除该对象。这就限制了只能使用通过new操作符来创建的codecvt，而不能使用从std::locale中获取的codecvt。</p><p>在C++标准提供的codecvt中，能够直接用于std::wstring_convert的只有三个：std::codecvt_utf8，std::codecvt_utf16以及std::codecvt_utf8_utf16。可见，标准只支持UTF族的字符编码。为了获取其它字符编码的codecvt，需要使用std::codecvt_byname，这个类可以通过字符编码的名称来创建一个codecvt。这看起来挺不错，但遗憾的是，字符编码的名称并没有统一的标准，各个平台的支持情况都不一样。例如，在Windows下可以使用“chs”来创建简体中文编码的codecvt，在Mac OS X下则要使用“zh_cn.gb2312”；甚至在Mac OS X下，即使成功创建了这个codecvt，它也不能正常地转换。</p><p>下面以Windows为例，说明如何将std::codecvt_byname用于std::wstring_convert。由于历史原因，std::codecvt_byname的析构函数是protected的，std::wstring_convert不能对它调用delete，所以首先要自行定义一个类来继承std::codecvt_byname：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">chs_codecvt</span> : <span class="keyword">public</span> std::codecvt_byname&lt;<span class="type">wchar_t</span>, <span class="type">char</span>, std::<span class="type">mbstate_t</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">chs_codecvt</span>() : <span class="built_in">codecvt_byname</span>(<span class="string">&quot;chs&quot;</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chs_codecvt的默认析构函数是public的，从而让std::wstring_convert可以删除它。为方便起见，在chs_codecvt的构造函数中，直接把“chs”传给了std::codecvt_byname。</p><p>接下来的用法跟本文开头的例子基本一致：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::wstring_convert&lt;chs_codecvt&gt; converter;</span><br><span class="line">std::string string = converter.<span class="built_in">to_bytes</span>(<span class="string">L&quot;你好&quot;</span>);</span><br><span class="line">std::wstring wide_string = converter.<span class="built_in">from_bytes</span>(<span class="string">&quot;\xc4\xe3\xba\xc3”);  //字符串的内容为“你好”</span></span><br></pre></td></tr></table></figure><p>综上所述，只有UTF编码的转换是完全符合C++标准并且真正能够跨平台的，使用这些国际化的字符编码能够减少很多不必要的麻烦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11新增的std::wstring_convert可以很方便地在std::string和std::wstring之间进行转换。例如，把一个std::wstring转换成以UTF-8编码的std::string：&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
    <category term="字符串" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="字符编码" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>调用boost::filesystem::unique_path可能会失败</title>
    <link href="http://zplutor.github.io/2016/05/15/calling-boost-filesystem-unique-path-may-fail/"/>
    <id>http://zplutor.github.io/2016/05/15/calling-boost-filesystem-unique-path-may-fail/</id>
    <published>2016-05-15T12:48:57.000Z</published>
    <updated>2018-04-08T16:53:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>假如你的程序需要在指定目录下生成一个唯一的临时文件，而且恰好引入了boost库，那么你可能会选择使用boost::filesystem::unique_path来生成文件名，因为该函数似乎正是为了此目的而生的。但是要小心，该函数在某些环境下可能会失败，抛出“拒绝访问”的异常。</p><span id="more"></span><p>这里失败的原因并不是由于访问文件系统导致的，而是由于访问了Windows中与密码学相关的API。查看unique_path的源码，可以发现它内部调用了CryptAcquireContext和CryptGenRandom来生成随机数据，然后基于这些随机数据来生成文件名。由于未知的原因，在某些Windows系统上需要管理员权限才能成功调用CryptAcquireContext（正常情况下并不需要管理员权限），从而导致了unique_path失败。</p><p>所以，为了避免不必要的麻烦，直接使用GUID或者其它唯一性强的标识作为临时文件名即可。只有在涉及安全问题的情况下才应该考虑使用unique_path——此时就需要弄清楚为什么需要管理员权限才能调用CryptAcquireContext了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;假如你的程序需要在指定目录下生成一个唯一的临时文件，而且恰好引入了boost库，那么你可能会选择使用boost::filesystem::unique_path来生成文件名，因为该函数似乎正是为了此目的而生的。但是要小心，该函数在某些环境下可能会失败，抛出“拒绝访问”的异常。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="boost" scheme="http://zplutor.github.io/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>STL中常用的集合操作函数</title>
    <link href="http://zplutor.github.io/2016/05/07/commonly-used-set-operation-functions-in-stl/"/>
    <id>http://zplutor.github.io/2016/05/07/commonly-used-set-operation-functions-in-stl/</id>
    <published>2016-05-07T13:24:41.000Z</published>
    <updated>2016-05-07T13:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在实际的编程工作中，经常需要对两个集合进行各种操作，例如取交集、取并集等。在C++中，完全不需要自己来实现这些操作，因为STL已经为我们准备好了这些常用的集合操作函数。</p><span id="more"></span><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>STL的集合操作都基于排序区间，所以在调用这些函数之前要对集合排序。最常用的排序函数是<code>std::sort</code>，它的用法很简单，只要传入一对迭代器即可，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector&#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span> &#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(vector.<span class="built_in">begin</span>(), vector.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//vector的元素序列是 &#123; 2, 3, 5, 8, 9 &#125;</span></span><br></pre></td></tr></table></figure><p>std:sort默认使用<code>&lt;</code>操作符来比较元素，当然也可以使用自定义的比较函数来改变排序规则。例如，下面的例子使用<code>&gt;</code>操作符比较元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector&#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span> &#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(vector.<span class="built_in">begin</span>(), vector.<span class="built_in">end</span>(), [](<span class="type">int</span> v1, <span class="type">int</span> v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//vector的元素序列是 &#123; 9, 8, 5, 3, 2 &#125;</span></span><br></pre></td></tr></table></figure><p>与std::sort一样，下文介绍的所有集合操作函数默认都使用&lt;操作符来比较元素，而且都可以在最后一个参数指定自定义的比较函数，这一点不再提及。但要注意的是，排序和集合操作使用的比较函数必须要一致，否则会有问题。另外，由于集合操作函数的输入都基于排序区间，所以这些函数的输出结果也是有序的，这点也不再提及。</p><p>STL保证std::sort的时间复杂度是<code>O(N·log(N))</code>，其中N为区间长度。</p><h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><p>对两个集合取交集可以使用<code>std::set_intersection</code>，该函数需要两对迭代器，以及一个输出迭代器，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector1&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector2&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">std::<span class="built_in">set_intersection</span>(</span><br><span class="line">    vector1.<span class="built_in">begin</span>(), vector1.<span class="built_in">end</span>(),  <span class="comment">//第一个区间</span></span><br><span class="line">    vector2.<span class="built_in">begin</span>(), vector2.<span class="built_in">end</span>(),  <span class="comment">//第二个区间</span></span><br><span class="line">    std::<span class="built_in">back_inserter</span>(result)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//result的元素序列是 &#123; 4, 6, 9 &#125;</span></span><br></pre></td></tr></table></figure><p>两个输入区间内的元素不会被修改，操作结果通过输出迭代器复制到另一个集合中。STL集合操作函数的用法都高度一致，下文其它函数的用法也是这样，仅仅是语义上不同。</p><p>STL保证std::set_intersection至多进行<code>2·(N1+N2-1)</code>次比较，其中N1是第一个区间的长度，N2是第二个区间的长度（N1和N2的定义下同）。</p><h2 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h2><p>对两个集合取并集可以使用<code>std::set_union</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector1&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector2&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">std::<span class="built_in">set_union</span>(</span><br><span class="line">    vector1.<span class="built_in">begin</span>(), vector1.<span class="built_in">end</span>(),  <span class="comment">//第一个区间</span></span><br><span class="line">    vector2.<span class="built_in">begin</span>(), vector2.<span class="built_in">end</span>(),  <span class="comment">//第二个区间</span></span><br><span class="line">    std::<span class="built_in">back_inserter</span>(result)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//result的元素序列是 &#123; 1, 2, 3, 4, 6, 8, 9 &#125;</span></span><br></pre></td></tr></table></figure><p>STL保证std::set_union至多进行<code>2·(N1+N2-1)</code>次比较。</p><h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><p>对两个集合取差集可以使用<code>std::set_difference</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector1&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector2&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">std::<span class="built_in">set_difference</span>(</span><br><span class="line">    vector1.<span class="built_in">begin</span>(), vector1.<span class="built_in">end</span>(),  <span class="comment">//第一个区间</span></span><br><span class="line">    vector2.<span class="built_in">begin</span>(), vector2.<span class="built_in">end</span>(),  <span class="comment">//第二个区间</span></span><br><span class="line">    std::<span class="built_in">back_inserter</span>(result)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//result的元素序列是 &#123; 1, 3 &#125;</span></span><br></pre></td></tr></table></figure><p>std::set_difference从第一个区间去除第二个区间的元素。</p><p>STL保证std::set_difference至多进行<code>2·(N1+N2-1)</code>次比较。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>合并两个集合可以使用<code>std::merge</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector1&#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vector2&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">std::<span class="built_in">merge</span>(</span><br><span class="line">    vector1.<span class="built_in">begin</span>(), vector1.<span class="built_in">end</span>(),  <span class="comment">//第一个区间</span></span><br><span class="line">    vector2.<span class="built_in">begin</span>(), vector2.<span class="built_in">end</span>(),  <span class="comment">//第二个区间</span></span><br><span class="line">    std::<span class="built_in">back_inserter</span>(result)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//result的元素序列是 &#123; 1, 2, 3, 4, 4, 6, 6, 8, 9, 9 &#125;</span></span><br></pre></td></tr></table></figure><p>与std::set_union不同，std::merge不会去除重复的元素。</p><p>STL保证std::merge至多进行<code>N1+N2-1</code>次比较。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在实际的编程工作中，经常需要对两个集合进行各种操作，例如取交集、取并集等。在C++中，完全不需要自己来实现这些操作，因为STL已经为我们准备好了这些常用的集合操作函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>防止boost::asio::deadline_timer在修改系统时间后失效</title>
    <link href="http://zplutor.github.io/2016/04/16/prevent-boost-asio-deadline-timer-from-being-invalid-after-changing-system-time/"/>
    <id>http://zplutor.github.io/2016/04/16/prevent-boost-asio-deadline-timer-from-being-invalid-after-changing-system-time/</id>
    <published>2016-04-16T12:28:45.000Z</published>
    <updated>2018-04-08T16:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>boost::asio::deadline_timer使用的计量时间是系统时间，因此修改系统时间会影响deadline_timer的行为。例如，调用了expires_from_now设置1分钟超时后，立刻把系统时间改成一天前，那么要过一天时间才会超时。这个特性可能会影响程序功能的正常使用，因此我们通常想要的是一个不会受系统时间影响的定时器。</p><span id="more"></span><p>事实上，boost::asio::steady_timer就是一个这样的定时器，它基于std::chrono::steady_clock实现。std::chrono::steady_clock是一个稳定的时钟，不随系统时间变化而变化。既然如此，直接用steady_timer代替deadline_timer不就可以了吗？理论上来说是可以的，但实际上，在Visual C++ 2013环境下，这是行不通的，因为Visual C++ 2013标准库中的std::chronno::steady_clock并不符合标准，它仍然会受系统时间影响！</p><p>有三种方法可以解决这个问题。第一是升级到Visual C++ 2015，这个版本的std::chronno::steady_clock总算符合标准了；第二是修改boost的编译选项，定义BOOST_ASIO_DISABLE_STD_CHRONO宏，这样可以禁止boost使用std::chrono，转而使用boost::chrono；第三是本文要介绍的方法，即定制deadline_timer，让它变成稳定的定时器。</p><p>deadline_timer实际上是basic_deadline_timer的特化版本，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_deadline_timer&lt;boost::posix_time::ptime&gt; deadline_timer;</span><br></pre></td></tr></table></figure><p>basic_deadline_timer是一个模板类，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> Time,</span><br><span class="line">    <span class="keyword">typename</span> TimeTraits = boost::asio::time_traits&lt;Time&gt;,</span><br><span class="line">    <span class="keyword">typename</span> TimerService = deadline_timer_service&lt;Time, TimeTraits&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> basic_deadline_timer : <span class="keyword">public</span> basic_io_object&lt; TimerService &gt;</span><br></pre></td></tr></table></figure><p>从以上定义的模板参数可以看出，basic_deadline_timer提供了灵活的可定制性。这里我们关注的重点是前面两个模板参数，其中第一个参数Time指定时间值的类型，第二个参数TimeTraits指定时间值的特性类，特性类用来对时间值进行各种操作。TimeTraits使用boost::asio::time_traits<Time>作为默认值，而boost::asio::time_traits只有一个针对boost::posix_time::ptime（即deadline_timer使用的时间值类型）的特化版本，从这个特化版本的定义可以看到TimeTraits需要提供哪些接口，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Time traits specialised for posix_time.</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">time_traits</span>&lt;boost::posix_time::ptime&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// The time type.</span></span><br><span class="line">  <span class="keyword">typedef</span> boost::posix_time::ptime time_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The duration type.</span></span><br><span class="line">  <span class="keyword">typedef</span> boost::posix_time::time_duration duration_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the current time.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> time_type <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)</span></span><br><span class="line">    <span class="keyword">return</span> boost::posix_time::microsec_clock::<span class="built_in">universal_time</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)</span></span></span><br><span class="line">    <span class="keyword">return</span> boost::posix_time::second_clock::<span class="built_in">universal_time</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Add a duration to a time.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> time_type <span class="title">add</span><span class="params">(<span class="type">const</span> time_type&amp; t, <span class="type">const</span> duration_type&amp; d)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Subtract one time from another.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> duration_type <span class="title">subtract</span><span class="params">(<span class="type">const</span> time_type&amp; t1, <span class="type">const</span> time_type&amp; t2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 - t2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Test whether one time is less than another.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">less_than</span><span class="params">(<span class="type">const</span> time_type&amp; t1, <span class="type">const</span> time_type&amp; t2)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 &lt; t2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Convert to POSIX duration type.</span></span><br><span class="line">  <span class="type">static</span> boost::<span class="function">posix_time::time_duration <span class="title">to_posix_duration</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> duration_type&amp; d)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，TimeTraits需要提供<code>time_type</code>和<code>duration_type</code>两种类型来分别表示一个时间点和一段时间；需要提供<code>now</code>方法来获取当前时间；需要提供<code>add</code>、<code>subtract</code>和<code>less_than</code>方法来计算和比较时间；最后还需要<code>to_posix_duration</code>方法把<code>duration_type</code>类型转换成<code>boost::posix_time::time_duration</code>类型。</p><p>显然，对于定制的basic_deadline_timer，时间值类型Time可以是任意类型，并且它的含义并没有硬性规定，例如，它可以是以毫秒或纳秒为单位的时间，也可以是CPU时钟的周期数，只要提供了正确的TimeTraits特性类把这个定制的时间值转换成boost认识的时间值即可。</p><p>接下来要选择一种与系统时间无关的时间值类型来定制basic_deadline_timer。在Windows平台下，很容易想到可以使用QueryPerformanceCounter和QueryPerformanceFrequency，这两个API提供了高精度的时间度量，与系统时间无关。QueryPerformanceCounter用来查询当前CPU时钟的周期数，是64位整数，这个是理想的时间值类型。要把CPU时钟周期数转换成具体的时间还需要调用QueryPerformanceFrequency查询CPU时钟的频率，即1秒内的CPU时钟周期数，然后通过简单的计算即可得到。</p><p>下面的是使用QueryPerformanceCounter和QueryPerformanceFrequency定制的TimeTraits：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeTraits</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::<span class="type">int64_t</span> time_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">duration_type</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">duration_type</span>() : <span class="built_in">value</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">        <span class="built_in">duration_type</span>(std::<span class="type">int64_t</span> value) : <span class="built_in">value</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        std::<span class="type">int64_t</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LARGE_INTEGER frequence_large_integer = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">QueryPerformanceFrequency</span>(&amp;frequence_large_integer);</span><br><span class="line">        frequence = frequence_large_integer.QuadPart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> duration_type <span class="title">GetMinutes</span><span class="params">(std::<span class="type">int64_t</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">duration_type</span>(minutes * <span class="number">60</span> * frequence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> duration_type <span class="title">GetSeconds</span><span class="params">(std::<span class="type">int64_t</span> seconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">duration_type</span>(seconds * frequence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> duration_type <span class="title">GetMilliseconds</span><span class="params">(std::<span class="type">int64_t</span> milliseconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">duration_type</span>(milliseconds * (frequence / <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> time_type <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LARGE_INTEGER counter = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">QueryPerformanceCounter</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">return</span> counter.QuadPart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> time_type <span class="title">add</span><span class="params">(time_type time, duration_type duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time + duration.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> duration_type <span class="title">subtract</span><span class="params">(time_type time1, time_type time2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">duration_type</span>(time1 - time2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">less_than</span><span class="params">(time_type time1, time_type time2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time1 &lt; time2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> boost::<span class="function">posix_time::time_duration <span class="title">to_posix_duration</span><span class="params">(duration_type duration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        std::<span class="type">int64_t</span> microseconds = (duration.value * <span class="number">1000</span> * <span class="number">1000</span>) / frequence;</span><br><span class="line">        <span class="keyword">return</span> boost::posix_time::<span class="built_in">microseconds</span>(microseconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TimeTraits</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::<span class="type">int64_t</span> frequence;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CPU时钟的频率是固定的，只需要调用QueryPerformanceFrequency查询一次即可，因此这里增加了<code>Initialize</code>方法来初始化CPU时钟频率，要在程序启动后的某个时机来调用该方法进行初始化。要注意的是<code>duration_type</code>不能跟<code>time_type</code>相同，这是TimeTraits的硬性规定，boost内部的代码依赖了这个规定，违反它会导致编译失败。所以要针对<code>duration_type</code>额外定义一个看似冗余的类型。</p><p>另一个值得注意的地方是，上面的定义增加了<code>GetMinutes</code>、<code>GetSeconds</code>和<code>GetMilliseconds</code>方法，这几个方法用来将具体的时间转换成我们定制的时间值，即CPU时钟周期数。这是因为在调用定时器的expires_from_now等方法设置超时值的时候，必须使用TimeTraits的duration_type，提供这几个方法可以方便使用。</p><p>最后，将这个定制的TimeTraits作为basic_deadline_timer的模板参数即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> boost::asio::basic_deadline_timer&lt;std::<span class="type">int64_t</span>, TimeTraits&gt; Timer;</span><br></pre></td></tr></table></figure><p>使用方法基本上与dealine_timer一样，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在某个时机初始化TimeTraits</span></span><br><span class="line">TimeTraits::<span class="built_in">Initialize</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个地方定义io_service</span></span><br><span class="line">boost::asio::io_service io_service;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用定制的Timer</span></span><br><span class="line"><span class="function">Timer <span class="title">timer</span><span class="params">(io_service)</span></span>;</span><br><span class="line">timer.<span class="built_in">expires_from_now</span>(TimeTraits::<span class="built_in">GetSecnods</span>(<span class="number">10</span>));</span><br><span class="line">timer.<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;boost::asio::deadline_timer使用的计量时间是系统时间，因此修改系统时间会影响deadline_timer的行为。例如，调用了expires_from_now设置1分钟超时后，立刻把系统时间改成一天前，那么要过一天时间才会超时。这个特性可能会影响程序功能的正常使用，因此我们通常想要的是一个不会受系统时间影响的定时器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="boost" scheme="http://zplutor.github.io/tags/boost/"/>
    
    <category term="定时器" scheme="http://zplutor.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>C4250警告产生的原因及解决方法</title>
    <link href="http://zplutor.github.io/2016/02/24/reason-and-solution-for-c4250-warning/"/>
    <id>http://zplutor.github.io/2016/02/24/reason-and-solution-for-c4250-warning/</id>
    <published>2016-02-24T06:20:46.000Z</published>
    <updated>2016-04-16T12:06:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用MSVC编译以下代码会产生C4250警告：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A::Print&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;C::Print&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>警告信息为<code>warning C4250: “D”: 通过域控制继承“C::C::Print”</code>。这样的警告信息并没有什么价值，我们需要自己来分析一下。</p><p>上述代码塑造出了菱形继承关系，如下所示：</p><img src="/2016/02/24/reason-and-solution-for-c4250-warning/1.png" class=""><p>根基类A定义了一个虚方法Print，因此在子类B和C中存在继承而来的Print，其中C重写了该方法。D多重继承于B和C，因此它会同时继承B和C的Print。这时问题来了，当对D的实例调用Print时，它应该调用B::Print还是C::Print呢？这里编译器做出了选择，它调用的是在基类中被重写的版本，也就是C::Print。然而，这很有可能不是我们想要的结果，所以编译器发出警告，提醒我们这里可能存在问题。</p><p>假如B也重写了Print，会怎么样呢？在这种情况下编译会失败，因为两个基类都重写了Print，编译器无法做出选择。</p><p>解决的方法很简单，只要在D中也重写Print即可，这样可以明确地告诉编译器，我们要调用的就是D::Print，从而消除了编译器的疑虑。在实现D::Print的时候，可能需要调用基类版本，这时要根据具体情况来决定调用哪个版本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用MSVC编译以下代码会产生C4250警告：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="继承" scheme="http://zplutor.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>boost::thread_specific_ptr在Windows下可能导致内存泄露</title>
    <link href="http://zplutor.github.io/2016/02/23/boost-thread-specific-ptr-may-cause-memory-leak-under-Windows/"/>
    <id>http://zplutor.github.io/2016/02/23/boost-thread-specific-ptr-may-cause-memory-leak-under-Windows/</id>
    <published>2016-02-23T15:31:52.000Z</published>
    <updated>2018-04-08T16:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>boost::thread_specific_ptr用于定义线程局部变量，根据这个类的定义，当一个线程结束的时候，与之相关的变量都会被释放。然而，这个规则并不是在所有情况下都适用。在boost::thread_specific_ptr的文档中有这么一句话：</p><span id="more"></span><blockquote><p>Note: on some platforms, cleanup of thread-specific data is not performed for threads created with the platform’s native API. On those platforms such cleanup is only done for threads that are started with boost::thread unless boost::on_thread_exit() is called manually from that thread.</p></blockquote><p>这里的“some platforms”指的就是Windows（不明白为什么boost不在文档中明确说明，这样可以让Windows程序员少碰壁）。在这个平台下，只有通过boost::thread启动的线程才会在结束的时候释放boost::thread_specific_ptr中的变量，通过其它方式启动的线程则要主动调用boost::on_thread_exit函数才能释放这些变量。所以，如果非boost::thread线程访问了boost::thread_specific_ptr，又没有调用boost::on_thread_exit，就会造成内存泄露。</p><p>避免这个问题的方法就是尽量使用boost::thread启动线程，这是最省事的方法。然而并不是所有情况都能使用boost::thread，这时就要按照文档说的主动去调用boost::on_thread_exit了。这是一个非公开的方法，它的声明位于<code>boost\thread\detail\tss_hooks.hpp</code>。</p><p>最坏的情况是，线程是由第三方库启动的，并且无法修改这个库的源码，或者修改的代价很高。在这种情况下，只能避免让这些线程去访问boost::thread_specific_ptr。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;boost::thread_specific_ptr用于定义线程局部变量，根据这个类的定义，当一个线程结束的时候，与之相关的变量都会被释放。然而，这个规则并不是在所有情况下都适用。在boost::thread_specific_ptr的文档中有这么一句话：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="boost" scheme="http://zplutor.github.io/tags/boost/"/>
    
    <category term="线程" scheme="http://zplutor.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="内存泄露" scheme="http://zplutor.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>创建空std::string的最佳方式</title>
    <link href="http://zplutor.github.io/2016/02/18/best-way-to-create-empty-std-string/"/>
    <id>http://zplutor.github.io/2016/02/18/best-way-to-create-empty-std-string/</id>
    <published>2016-02-18T15:14:10.000Z</published>
    <updated>2018-04-08T16:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>创建一个空的std::string对象有多种方式，常见的有以下两种：</p><span id="more"></span><p>第一种是直接使用std::string的默认构造函数，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建变量</span></span><br><span class="line">std::string string;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从函数返回</span></span><br><span class="line"><span class="function">std::string <span class="title">GetEmptyString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是由空的C字符串字面量转换，不论是显式的还是隐式的转换，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建变量</span></span><br><span class="line"><span class="function">std::string <span class="title">string1</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">std::string string2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从函数返回</span></span><br><span class="line"><span class="function">std::string <span class="title">GetEmptyString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方式的结果都是一样的，但是过程却有一点不同。第一种方式直截了当地创建一个空std::string对象，没有多余的操作；而第二种方式则多了一个转换过程——它要通过strlen之类的函数计算出字符串的长度。即便是空字符串，这个转换过程也会造成一些开销。所以，从理论上来说，第二种方式的性能会比较差。具体差了多少呢？可以使用以下代码进行测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Count = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    std::ostringstream os;</span><br><span class="line"></span><br><span class="line">    std::<span class="type">clock_t</span> begin_time = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; Count; ++count) &#123;</span><br><span class="line">        std::string str;</span><br><span class="line">        os &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="type">clock_t</span> end_time = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">double</span>(end_time - begin_time) / CLOCKS_PER_SEC &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    begin_time = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; Count; ++count) &#123;</span><br><span class="line">        <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">        os &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end_time = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">double</span>(end_time - begin_time) / CLOCKS_PER_SEC &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; os.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别用两种方式创建std::string对象一亿次，输出两者的耗时。每次创建字符串之后，都会把它输出到一个std::ostringstream对象中，这是为了避免在release模式下编译器把无实际作用的for循环优化掉。以下是在XCode中运行的输出结果：</p><pre><code>1.477661.97115</code></pre><p>可见，第二种方式确实会比第一种方式慢，不过差距十分微小：在创建一亿个std::string对象的级别下才慢了0.5秒，几乎可以忽略不计。尽管如此，对于追求效率的程序员来说，显然第一种方式更胜一筹。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;创建一个空的std::string对象有多种方式，常见的有以下两种：&lt;/p&gt;</summary>
    
    
    
    
    <category term="性能" scheme="http://zplutor.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
    <category term="字符串" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>使用内核对象实现单例程序</title>
    <link href="http://zplutor.github.io/2016/02/04/implement-singleton-application-with-kernal-object/"/>
    <id>http://zplutor.github.io/2016/02/04/implement-singleton-application-with-kernal-object/</id>
    <published>2016-02-04T13:51:05.000Z</published>
    <updated>2016-04-16T12:12:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于有些程序来说，运行多个实例没有意义，甚至会出现异常，所以有必要把程序实现成单例。有多种方法可以做到这一点，比较好的方法是使用内核对象。</p><span id="more"></span><p>内核对象是指存在于系统内核中的对象，而不仅仅存在于程序内部，这样多个程序实例之间就可以共享这些对象了。使用内核对象的思路很简单：程序启动之后检查一下是否存在特定的内核对象，如果不存在，说明这是第一个实例，可以正常运行；如果已存在，说明已经有实例在运行了，当前的实例要退出。内核对象在这里只是作为一个标识，标识是否有实例正在运行，至于它是哪一种内核对象则不重要。习惯上会使用Mutex内核对象，主要是因为它的名称与这里的用途相吻合，而且它的用法也很简单。</p><p>内核对象有具名和匿名之分。具名的内核对象与一个字符串关联，通过这个字符串可以找到对应的内核对象；匿名的内核对象则不具备这个特点。显然这里应该使用具名内核对象。</p><p>可以在程序的入口点来检查内核对象。下面是检查Mutex内核对象的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HANDLE mutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="string">L&quot;SingletonApplication&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( (mutex == <span class="literal">NULL</span>) || (<span class="built_in">GetLastError</span>() == ERROR_ALREADY_EXISTS) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常启动程序</span></span><br></pre></td></tr></table></figure><p>CreateMutex同时提供了创建和打开Mutex内核对象的功能。第三个参数指明了内核对象的名称，如果名为<code>SingletonApplication</code>的Mutex内核对象不存在，那么CreateMutex会创建一个新的对象，并返回它的句柄；如果已经存在这个内核对象，那么CreateMutex会打开它，并返回它的句柄，同时GetLastError会返回<code>ERROR_ALREADY_EXISTS</code>。在实际的应用中，应该把<code>SingletonApplication</code>替换成尽量不会与其它程序冲突的名称。</p><p>CreateMutex的第一个和第二个参数在这里的使用场景中并不重要，分别传入NULL和FALSE即可。CreateMutex如果失败会返回NULL，这种情况几乎不会发生，但基于完整性考虑这里还是要判断一下返回值是否为NULL。</p><p>在程序的实例退出之前，理论上来说是需要调用CloseHandle把内核对象关闭的。但实即使不这么做也不会有问题，因为进程结束的时候操作系统会把这个进程所有的资源回收，该内核对象自然会被关闭。</p><p>最后要注意的是，使用内核对象来实现单例程序是有风险的。因为内核对象全局可见，其它程序也能访问。例如WinObj工具可以查看系统中所有内核对象以及它们的名称。恶意程序完全可以抢先创建内核对象来阻止特定程序运行。所以如果安全性很重要的话，就要考虑更加安全的方式来实现单例程序了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于有些程序来说，运行多个实例没有意义，甚至会出现异常，所以有必要把程序实现成单例。有多种方法可以做到这一点，比较好的方法是使用内核对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="单例" scheme="http://zplutor.github.io/tags/%E5%8D%95%E4%BE%8B/"/>
    
    <category term="内核对象" scheme="http://zplutor.github.io/tags/%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>为什么std::tolower不能用于std::transform</title>
    <link href="http://zplutor.github.io/2016/01/02/why-can-t-std-tolower-be-used-with-std-transform/"/>
    <id>http://zplutor.github.io/2016/01/02/why-can-t-std-tolower-be-used-with-std-transform/</id>
    <published>2016-01-02T04:13:36.000Z</published>
    <updated>2018-04-08T16:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中，std::tolower和std::toupper函数（在本文中都用std::tolower指代两者）用于对一个字符进行大小写转换，将其与std::transform函数结合则可以对整个字符串进行大小写转换，如下所示：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string string = <span class="string">&quot;ABCDEF&quot;</span>;</span><br><span class="line">std::<span class="built_in">transform</span>(</span><br><span class="line">    string.<span class="built_in">begin</span>(), </span><br><span class="line">    string.<span class="built_in">end</span>(), </span><br><span class="line">    string.<span class="built_in">begin</span>(), </span><br><span class="line">    std::tolower</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>以上代码在Visual C++下能编译成功，但是在XCode下却编译失败，错误信息为<code>No matching function for call to &#39;transform&#39;</code>。这是因为std::tolower函数存在两个重载，第一个定义于头文件cctype，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tolower</span><span class="params">(<span class="type">int</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><p>第二个定义于头文件locale，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> charT&gt;</span></span><br><span class="line"><span class="function">charT <span class="title">tolower</span><span class="params">(charT ch, <span class="type">const</span> locale&amp; loc)</span></span>;</span><br></pre></td></tr></table></figure><p>cctype和locale都是很基础的模块，会被其它头文件引用，因此这两个重载通常都会同时出现。XCode的编译器由于不知道该选择哪个重载而报错。</p><p>然而，从理论上来说，编译器是可以知道如何选择的。std::transform在XCode中的源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIterator</span>, <span class="keyword">class</span> <span class="title class_">_OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">_UnaryOperation</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">_OutputIterator</span></span><br><span class="line"><span class="function"><span class="title">transform</span><span class="params">(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; __first != __last; ++__first, (<span class="type">void</span>) ++__result)</span><br><span class="line">        *__result = __op(*__first);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第七行，可以看到调用<code>__op</code>的时候只传了一个参数，因此无论如何只能选择std::tolower的第一个重载，编译器完全有能力做出这个推导。如果把上述std::transform的源码转移到Visual C++并且以同样的方式来调用，可以编译成功，可见这个推导是可行的。那为什么XCode的编译器没有这么做呢？一个可能的原因是效率问题，类型推导越精确会耗费越多编译时间。从这一点或许可以解释为什么Visual C++的编译速度这么慢。</p><p>那么，应该如何解决这个问题呢？有两种方法，第一种方法是把std::tolower换成::tolower，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span>(</span><br><span class="line">    string.<span class="built_in">begin</span>(), </span><br><span class="line">    string.<span class="built_in">end</span>(), </span><br><span class="line">    string.<span class="built_in">begin</span>(), </span><br><span class="line">    ::tolower</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>默认情况下，在全局名称空间中，tolower只有一种声明形式，因此没有问题。但前提是没有使用<code>using namespace</code>语句把std名称空间的内容导入全局名称空间——然而这种用法很常见，因此使用::tolower并不一定有效。</p><p>第二种方法是显式指定使用std::tolower的第一个重载，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span>(</span><br><span class="line">    string.<span class="built_in">begin</span>(), </span><br><span class="line">    string.<span class="built_in">end</span>(), </span><br><span class="line">    string.<span class="built_in">begin</span>(), </span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="built_in">int</span>(*)(<span class="type">int</span>)&gt;(std::tolower)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这种做法带来了编码负担，因为每次使用的时候都要回忆一下std::tolower的声明形式，并且要输入更多字符。所以最好用一个函数把它封装起来，一劳永逸。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在C++中，std::tolower和std::toupper函数（在本文中都用std::tolower指代两者）用于对一个字符进行大小写转换，将其与std::transform函数结合则可以对整个字符串进行大小写转换，如下所示：&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
    <category term="字符串" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>实现一个可编辑的Windowless RichEdit</title>
    <link href="http://zplutor.github.io/2015/12/06/implement-an-editable-windowless-richedit/"/>
    <id>http://zplutor.github.io/2015/12/06/implement-an-editable-windowless-richedit/</id>
    <published>2015-12-06T13:16:04.000Z</published>
    <updated>2023-04-15T14:07:26.496Z</updated>
    
    <content type="html"><![CDATA[<p>本文在《创建一个最简单的Windowless RichEdit》一文的基础上，介绍如何让Windowless RichEdit支持编辑功能。</p><span id="more"></span><h2 id="激活并设置焦点"><a href="#激活并设置焦点" class="headerlink" title="激活并设置焦点"></a>激活并设置焦点</h2><p>Windowless RichEdit需要同时处于两种状态下才能够编辑：一是活动状态，二是有输入焦点状态。</p><p>默认情况下Windowless RichEdit是处于不活动状态的，使用ITextServices的OnTxInPlaceActivate方法即可切换到活动状态。该方法接受一个类型为<code>const RECT*</code>的参数，表示Windowless RichEdit的客户区域，一般情况下传入nullptr即可，因为Windowless RichEdit总是会调用ITextHost的TxGetClientRect方法取得这个区域。也就是说我们还要实现TxGetClientRect：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetClientRect</span><span class="params">(LPRECT prc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">GetClientRect</span>(hwnd_, prc);</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，默认情况下Windowless RichEdit处于无输入焦点状态，需要使用ITextServices的TxSendMessage方法向它发送一个WM_SETFOCUS消息来切换到有输入焦点状态。所有能通过消息完成的操作都使用TxSendMessage方法，这样可以使Windowless RichEdit与Windows的消息处理更好地融合，也避免在ITextServices接口中暴露过多方法。</p><p>这两种状态可以在父窗口的WM_SETFOCUS消息中同时设置，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETFOCUS: &#123;</span><br><span class="line"></span><br><span class="line">    g_text_service-&gt;<span class="built_in">OnTxInPlaceActivate</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    LRESULT result = <span class="number">0</span>;</span><br><span class="line">    g_text_service-&gt;<span class="built_in">TxSendMessage</span>(message, wParam, lParam, &amp;result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应地，使用ITextServices的OnTxInPlaceDeactivate方法可以切换回不活动状态；使用TxSendMessage发送WM_KILLFOCUS消息可以切换回无焦点状态。可以在父窗口的WM_KILLFOCUS消息中同时设置，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KILLFOCUS: &#123;</span><br><span class="line"></span><br><span class="line">    g_text_service-&gt;<span class="built_in">OnTxInPlaceDeactivate</span>();</span><br><span class="line">    </span><br><span class="line">    LRESULT result = <span class="number">0</span>;</span><br><span class="line">    g_text_service-&gt;<span class="built_in">TxSendMessage</span>(message, wParam, lParam, &amp;result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示输入光标"><a href="#显示输入光标" class="headerlink" title="显示输入光标"></a>显示输入光标</h2><p>Windowless RichEdit不负责显示输入光标，它会调用ITextHost的一系列方法进行回调，由实现者来负责显示。下列方法是与输入光标相关的：</p><ul><li>TxGetDC</li><li>TxReleaseDC</li><li>TxCreateCaret</li><li>TxShowCaret</li><li>TxSetCaretPos</li></ul><p>一般情况下，实现这几个方法很简单，只要调用相应的API即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HDC <span class="title">TxGetDC</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetDC</span>(hwnd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INT <span class="title">TxReleaseDC</span><span class="params">(HDC hdc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReleaseDC</span>(hwnd_, hdc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TxCreateCaret</span><span class="params">(HBITMAP hbmp, INT xWidth, INT yHeight)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateCaret</span>(hwnd_, hbmp, xWidth, yHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TxShowCaret</span><span class="params">(BOOL fShow)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fShow) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ShowCaret</span>(hwnd_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">HideCaret</span>(hwnd_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">TxSetCaretPos</span><span class="params">(INT x, INT y)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SetCaretPos</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TxGetDC和TxReleaseDC看起来似乎与后面三个方法无关，但却是必须实现的。如果TxGetDC返回了无效的HDC，那么后面三个方法就不会被调用。</p><h2 id="输入字符"><a href="#输入字符" class="headerlink" title="输入字符"></a>输入字符</h2><p>往Windowless RichEdit中输入字符很简单，只要让它处理下列键盘消息即可：</p><ul><li>WM_KEYDOWN</li><li>WM_KEYUP</li><li>WM_CHAR</li></ul><p>这同样是使用TxSendMessage方法完成，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line"><span class="keyword">case</span> WM_KEYUP:</span><br><span class="line"><span class="keyword">case</span> WM_CHAR: &#123;</span><br><span class="line"></span><br><span class="line">    LRESULT result = <span class="number">0</span>;</span><br><span class="line">    g_text_service-&gt;<span class="built_in">TxSendMessage</span>(message, wParam, lParam, &amp;result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，Windowless RichEdit还需要重绘以显示输入的字符，它会调用ITextHost的TxInvalidateRect方法。该方法的实现也非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TxInvalidateRect</span><span class="params">(LPCRECT prc, BOOL fMode)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">InvalidateRect</span>(hwnd_, prc, fMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鼠标相关"><a href="#鼠标相关" class="headerlink" title="鼠标相关"></a>鼠标相关</h2><p>鼠标在进行文字编辑时也有重要的作用。例如，当鼠标移动到可编辑的文本框上时，指针会变成<code>I</code>形状，此时点击鼠标可以修改输入光标的位置；拖拽鼠标可以选择一段文字。下面是实现这些功能的方法。</p><p>鼠标指针的改变需要调用ITextServices的OnTxSetCursor来触发，理想的调用点是在处理WM_SETCURSOR消息的时候，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_SETCURSOR: &#123;</span><br><span class="line"></span><br><span class="line">    HDC hdc = <span class="built_in">GetDC</span>(hwnd);</span><br><span class="line">    </span><br><span class="line">    POINT position = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetCursorPos</span>(&amp;position);</span><br><span class="line">    <span class="built_in">ScreenToClient</span>(hwnd, &amp;position);</span><br><span class="line">    </span><br><span class="line">    RECT rect = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetClientRect</span>(hwnd, &amp;rect);</span><br><span class="line">    </span><br><span class="line">    g_text_service-&gt;<span class="built_in">OnTxSetCursor</span>(</span><br><span class="line">    DVASPECT_CONTENT, </span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">nullptr</span>, </span><br><span class="line">    <span class="literal">nullptr</span>, </span><br><span class="line">    hdc, </span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    &amp;rect, </span><br><span class="line">    position.x, </span><br><span class="line">    position.y</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ReleaseDC</span>(hwnd, hdc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意不能直接用TxSendMessage发送WM_SETCURSOR消息，这样做并不能得到想要的效果。</p><p>然后Windowless RichEdit会调用ITextHost的TxSetCursor来设置鼠标指针，只要在该方法中调用SetCursor即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TxSetCursor</span><span class="params">(HCURSOR hcur, BOOL fText)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SetCursor</span>(hcur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，要让Windowless RichEdit处理下列鼠标消息：</p><ul><li>WM_MOUSEMOVE</li><li>WM_LBUTTONDOWN</li><li>WM_LBUTTONUP</li></ul><p>同样是使用TxSendMessage完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONUP: &#123;</span><br><span class="line"></span><br><span class="line">    LRESULT result = <span class="number">0</span>;</span><br><span class="line">    g_text_service-&gt;<span class="built_in">TxSendMessage</span>(message, wParam, lParam, &amp;result);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Windowless RichEdit会在需要的时候调用ITextHost的TxSetCapture来捕获或释放鼠标。该方法的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TxSetCapture</span><span class="params">(BOOL fCapture)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fCapture) &#123;</span><br><span class="line">        <span class="built_in">SetCapture</span>(hwnd_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ReleaseCapture</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>在本文的最后，附上完整的示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atlbase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Richedit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TextServ.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextHost</span> : <span class="keyword">public</span> ITextHost &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TextHost</span>(HWND hwnd) : <span class="built_in">hwnd_</span>(hwnd) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT __stdcall <span class="title">QueryInterface</span><span class="params">(REFIID riid, <span class="type">void</span>** ppvObject)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ppvObject == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> E_POINTER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((riid == IID_IUnknown) || (riid == IID_ITextHost)) &#123;</span><br><span class="line">            *ppvObject = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> S_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppvObject = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> E_NOINTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ULONG __stdcall <span class="title">AddRef</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ULONG __stdcall <span class="title">Release</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HDC <span class="title">TxGetDC</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetDC</span>(hwnd_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">INT <span class="title">TxReleaseDC</span><span class="params">(HDC hdc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ReleaseDC</span>(hwnd_, hdc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowScrollBar</span><span class="params">(INT fnBar, BOOL fShow)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxEnableScrollBar</span><span class="params">(INT fuSBFlags, INT fuArrowflags)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollRange</span><span class="params">(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollPos</span><span class="params">(INT fnBar, INT nPos, BOOL fRedraw)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxInvalidateRect</span><span class="params">(LPCRECT prc, BOOL fMode)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">InvalidateRect</span>(hwnd_, prc, fMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxViewChange</span><span class="params">(BOOL fUpdate)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxCreateCaret</span><span class="params">(HBITMAP hbmp, INT xWidth, INT yHeight)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CreateCaret</span>(hwnd_, hbmp, xWidth, yHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowCaret</span><span class="params">(BOOL fShow)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fShow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ShowCaret</span>(hwnd_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">HideCaret</span>(hwnd_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetCaretPos</span><span class="params">(INT x, INT y)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SetCaretPos</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetTimer</span><span class="params">(UINT idTimer, UINT uTimeout)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxKillTimer</span><span class="params">(UINT idTimer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxScrollWindowEx</span><span class="params">(INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxSetCapture</span><span class="params">(BOOL fCapture)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fCapture) &#123;</span><br><span class="line">            <span class="built_in">SetCapture</span>(hwnd_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ReleaseCapture</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxSetFocus</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxSetCursor</span><span class="params">(HCURSOR hcur, BOOL fText)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">SetCursor</span>(hcur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxScreenToClient</span><span class="params">(LPPOINT lppt)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxClientToScreen</span><span class="params">(LPPOINT lppt)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxActivate</span><span class="params">(LONG * plOldState)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxDeactivate</span><span class="params">(LONG lNewState)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetClientRect</span><span class="params">(LPRECT prc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">GetClientRect</span>(hwnd_, prc);</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetViewInset</span><span class="params">(LPRECT prc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetCharFormat</span><span class="params">(<span class="type">const</span> CHARFORMATW **ppCF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (char_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            char_format_ = std::<span class="built_in">make_unique</span>&lt;CHARFORMATW&gt;();</span><br><span class="line">            char_format_-&gt;cbSize = <span class="built_in">sizeof</span>(CHARFORMATW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppCF = char_format_.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetParaFormat</span><span class="params">(<span class="type">const</span> PARAFORMAT **ppPF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (para_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            para_format_ = std::<span class="built_in">make_unique</span>&lt;PARAFORMAT&gt;();</span><br><span class="line">            para_format_-&gt;cbSize = <span class="keyword">sizeof</span> PARAFORMAT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppPF = para_format_.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">COLORREF <span class="title">TxGetSysColor</span><span class="params">(<span class="type">int</span> nIndex)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetSysColor</span>(nIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetBackStyle</span><span class="params">(TXTBACKSTYLE *pstyle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetMaxLength</span><span class="params">(DWORD *plength)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetScrollBars</span><span class="params">(DWORD *pdwScrollBar)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPasswordChar</span><span class="params">(_Out_ TCHAR *pch)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetAcceleratorPos</span><span class="params">(LONG *pcp)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetExtent</span><span class="params">(LPSIZEL lpExtent)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxCharFormatChange</span><span class="params">(<span class="type">const</span> CHARFORMATW * pCF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxParaFormatChange</span><span class="params">(<span class="type">const</span> PARAFORMAT * pPF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPropertyBits</span><span class="params">(DWORD dwMask, DWORD *pdwBits)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        *pdwBits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxNotify</span><span class="params">(DWORD iNotify, <span class="type">void</span> *pv)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HIMC <span class="title">TxImmGetContext</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxImmReleaseContext</span><span class="params">(HIMC himc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetSelectionBarWidth</span><span class="params">(LONG *lSelBarWidth)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        *lSelBarWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HWND hwnd_;</span><br><span class="line">    std::unique_ptr&lt;CHARFORMATW&gt; char_format_;</span><br><span class="line">    std::unique_ptr&lt;PARAFORMAT&gt; para_format_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="type">const</span> IID IID_ITextServices = &#123;</span><br><span class="line">    <span class="number">0x8d33f740</span>,</span><br><span class="line">    <span class="number">0xcf58</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9d</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="type">const</span> IID IID_ITextHost = &#123;</span><br><span class="line">    <span class="number">0xc5bdd8d0</span>,</span><br><span class="line">    <span class="number">0xd26e</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9e</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;TextHost&gt; g_text_host;</span><br><span class="line">CComPtr&lt;ITextServices&gt; g_text_service;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="type">char</span>*, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WNDCLASSEX default_class = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    default_class.cbSize = <span class="built_in">sizeof</span>(default_class);</span><br><span class="line">    default_class.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    default_class.lpfnWndProc = WindowProcedure;</span><br><span class="line">    default_class.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    default_class.cbWndExtra = <span class="built_in">sizeof</span>(LONG_PTR);</span><br><span class="line">    default_class.hInstance = <span class="literal">NULL</span>;</span><br><span class="line">    default_class.hIcon = <span class="literal">NULL</span>;</span><br><span class="line">    default_class.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">    default_class.hbrBackground = <span class="built_in">reinterpret_cast</span>&lt;HBRUSH&gt;(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">    default_class.lpszMenuName = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.lpszClassName = <span class="string">L&quot;WindowlessRichEdit&quot;</span>;</span><br><span class="line">    default_class.hIconSm = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClassEx</span>(&amp;default_class);</span><br><span class="line"></span><br><span class="line">    HWND window_handle = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="string">L&quot;WindowlessRichEdit&quot;</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        WS_OVERLAPPEDWINDOW | WS_VISIBLE,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE: &#123;</span><br><span class="line"></span><br><span class="line">        g_text_host = std::<span class="built_in">make_shared</span>&lt;TextHost&gt;(hwnd);</span><br><span class="line"></span><br><span class="line">        HMODULE module_handle = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;riched20.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(_stdcall*CreateTextServicesFunction)</span><span class="params">(IUnknown*, ITextHost*, IUnknown**)</span></span>;</span><br><span class="line">        CreateTextServicesFunction create_function = <span class="built_in">reinterpret_cast</span>&lt;CreateTextServicesFunction&gt;(<span class="built_in">GetProcAddress</span>(module_handle, <span class="string">&quot;CreateTextServices&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> IID* iid_text_service = <span class="built_in">reinterpret_cast</span>&lt;IID*&gt;(<span class="built_in">GetProcAddress</span>(module_handle, <span class="string">&quot;IID_ITextServices&quot;</span>));</span><br><span class="line"></span><br><span class="line">        CComPtr&lt;IUnknown&gt; unknown;</span><br><span class="line">        <span class="built_in">create_function</span>(<span class="literal">nullptr</span>, g_text_host.<span class="built_in">get</span>(), &amp;unknown);</span><br><span class="line">        unknown-&gt;<span class="built_in">QueryInterface</span>(*iid_text_service, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;g_text_service));</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;<span class="built_in">TxSetText</span>(<span class="string">L&quot;Windowless RichEdit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_PAINT: &#123;</span><br><span class="line"></span><br><span class="line">        PAINTSTRUCT paint_struct;</span><br><span class="line">        HDC hdc = <span class="built_in">BeginPaint</span>(hwnd, &amp;paint_struct);</span><br><span class="line"></span><br><span class="line">        RECT rect;</span><br><span class="line">        <span class="built_in">GetClientRect</span>(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;<span class="built_in">TxDraw</span>(</span><br><span class="line">            DVASPECT_CONTENT,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            hdc,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;LPCRECTL&gt;(&amp;rect),</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">EndPaint</span>(hwnd, &amp;paint_struct);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_SETFOCUS: &#123;</span><br><span class="line">    </span><br><span class="line">        g_text_service-&gt;<span class="built_in">OnTxInPlaceActivate</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line">        LRESULT result = <span class="number">0</span>;</span><br><span class="line">        g_text_service-&gt;<span class="built_in">TxSendMessage</span>(message, wParam, lParam, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_KILLFOCUS: &#123;</span><br><span class="line">    </span><br><span class="line">        g_text_service-&gt;<span class="built_in">OnTxInPlaceDeactivate</span>();</span><br><span class="line">        </span><br><span class="line">        LRESULT result = <span class="number">0</span>;</span><br><span class="line">        g_text_service-&gt;<span class="built_in">TxSendMessage</span>(message, wParam, lParam, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">    <span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">    <span class="keyword">case</span> WM_CHAR:&#123;</span><br><span class="line">    </span><br><span class="line">        LRESULT result = <span class="number">0</span>;</span><br><span class="line">        g_text_service-&gt;<span class="built_in">TxSendMessage</span>(message, wParam, lParam, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_SETCURSOR: &#123;</span><br><span class="line">    </span><br><span class="line">        HDC hdc = <span class="built_in">GetDC</span>(hwnd);</span><br><span class="line">        </span><br><span class="line">        POINT position = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">GetCursorPos</span>(&amp;position);</span><br><span class="line">        <span class="built_in">ScreenToClient</span>(hwnd, &amp;position);</span><br><span class="line">        </span><br><span class="line">        RECT rect = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">GetClientRect</span>(hwnd, &amp;rect);</span><br><span class="line">        </span><br><span class="line">        g_text_service-&gt;<span class="built_in">OnTxSetCursor</span>(</span><br><span class="line">            DVASPECT_CONTENT, </span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="literal">nullptr</span>, </span><br><span class="line">            <span class="literal">nullptr</span>, </span><br><span class="line">            hdc, </span><br><span class="line">            <span class="literal">nullptr</span>, </span><br><span class="line">            &amp;rect, </span><br><span class="line">            position.x, </span><br><span class="line">            position.y</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">ReleaseDC</span>(hwnd, hdc);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONUP: &#123;</span><br><span class="line">    </span><br><span class="line">        LRESULT result = <span class="number">0</span>;</span><br><span class="line">        g_text_service-&gt;<span class="built_in">TxSendMessage</span>(message, wParam, lParam, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CallWindowProc</span>(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文在《创建一个最简单的Windowless RichEdit》一文的基础上，介绍如何让Windowless RichEdit支持编辑功能。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
    <category term="RichEdit" scheme="http://zplutor.github.io/tags/RichEdit/"/>
    
  </entry>
  
  <entry>
    <title>KeyWindow 0.1.2</title>
    <link href="http://zplutor.github.io/2015/11/28/keywindow-0-1-2/"/>
    <id>http://zplutor.github.io/2015/11/28/keywindow-0-1-2/</id>
    <published>2015-11-28T05:20:30.000Z</published>
    <updated>2017-04-02T06:47:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>KeyWindow是一个通过快捷键快速调整窗口布局的工具。</p><span id="more"></span><p>OS X的窗口管理是个麻烦的事情。当需要同时使用多个窗口的时候，我们希望能够在同一个屏幕上平铺这些窗口。例如，把浏览器窗口充满屏幕左半边，把文本编辑器窗口充满屏幕右半边。为了达到这个目的，必须拖动这些窗口并且调整它们的大小，效率很低下。虽然OS X 10.11新增了SplitView功能，但它仍然需要拖动窗口，不够快捷。</p><p>那么，最快捷的方式是什么呢？当然是通过键盘快捷键。OS X不支持通过快捷键改变窗口的布局，但是KeyWindow带来了这个功能。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在KeyWindow中配置窗口的布局以及对应的快捷键。</p><img src="/2015/11/28/keywindow-0-1-2/1.jpg" class=""><p>通过快捷键调整窗口布局。</p><img src="/2015/11/28/keywindow-0-1-2/2.jpg" class=""><h2 id="程序信息"><a href="#程序信息" class="headerlink" title="程序信息"></a>程序信息</h2><ul><li>系统要求：OS X 10.10及以上。</li><li>支持语言：简体中文；英文。</li><li>下载地址：<a href="https://github.com/Zplutor/KeyWindow/releases/download/v0.1.2/KeyWindow.0.1.2.dmg">https://github.com/Zplutor/KeyWindow/releases/download/v0.1.2/KeyWindow.0.1.2.dmg</a></li><li>项目地址：<a href="https://github.com/Zplutor/KeyWindow">https://github.com/Zplutor/KeyWindow</a></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>KeyWindow是一个开源项目，如果你也喜欢这个小工具，欢迎来为它添砖加瓦。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;KeyWindow是一个通过快捷键快速调整窗口布局的工具。&lt;/p&gt;</summary>
    
    
    
    
    <category term="KeyWindow" scheme="http://zplutor.github.io/tags/KeyWindow/"/>
    
    <category term="macOS" scheme="http://zplutor.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>RAND_poll函数在Windows下存在的问题</title>
    <link href="http://zplutor.github.io/2015/11/25/RAND-poll-function-s-issues-on-Windows/"/>
    <id>http://zplutor.github.io/2015/11/25/RAND-poll-function-s-issues-on-Windows/</id>
    <published>2015-11-24T16:26:09.000Z</published>
    <updated>2015-11-24T16:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>RAND_poll函数是OpenSSL中用于初始化伪随机数生成器的函数，当首次调用诸如RAND_bytes等需要生成随机数的函数时，会先调用该函数进行初始化。在实际使用中发现，RAND_poll函数在Windows下存在一些问题，需要小心提放，否则可能会对程序造成不良影响。</p><span id="more"></span><h2 id="慢"><a href="#慢" class="headerlink" title="慢"></a>慢</h2><p>RAND_poll的第一个问题是慢。早在2009年就有人反映这个问题，说这个函数居然要耗费超过一分钟的时间。要明白为什么RAND_poll这么慢，就要了解它的实现原理。为了保证伪随机数的不可预见性，需要用尽可能多的随机信息去初始化生成器，因此RAND_poll尝试收集程序运行时的各种环境信息。其中包括当前进程的内存信息，这是通过枚举每一个堆中已分配的前80个内存块来得到的。即使对于单个堆的数量有限制，总的枚举的次数仍然可能很多，况且用于枚举的API本身性能并不好，导致整体上耗费了大量时间。</p><p>这个问题在2009年之后的OpenSSL版本中得到了缓解。之所以说“缓解”，是因为RAND_poll的算法并没有改变，它仍然要枚举每个堆的内存块，只不过在枚举的过程中加上了时间检测，如果发现已经超过一秒就不再继续枚举了。因此，该函数最多耗时一秒多一点，这个时间对于某些场景来说仍然是比较慢的。</p><p>关于这个问题的讨论，可以参考 <a href="https://rt.openssl.org/Ticket/Display.html?id=2100&amp;user=guest&amp;pass=guest">https://rt.openssl.org/Ticket/Display.html?id=2100&amp;user=guest&amp;pass=guest</a> 。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>RAND_poll的第二个问题是它有一定几率导致死锁。原因还是在于枚举堆内存块——用于枚举的API会把进程所有的堆逐个加锁，在这个过程中，假如有其它线程也在操作堆，那么很有可能导致死锁。</p><p>按道理来说，死锁这么严重的问题应该尽早解决，然而奇怪的是，这个问题一直留存至今。综合网上的各种讨论来看，原因或许是这样的：OpenSSL认为这是Windows的问题，一个公开的系统API绝不应该导致程序死锁；而微软则声称这个API仅用于调试目的，不应该在正常的场合下使用。双方都认为这是对方的责任，因此谁都不愿意去修改。</p><p>关于这个问题的分析，可以参考 <a href="http://0cch.com/debugging/2015/09/08/foxmail-hung.html">http://0cch.com/debugging/2015/09/08/foxmail-hung.html</a> 。</p><h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><p>综上所述，RAND_poll的两个问题对程序的性能和稳定性都有影响。那么应该如何避免呢？很简单，只需要在程序入口点调用一下RAND_bytes，让它初始化伪随机数生成器即可。之所以在这个时间点来初始化，一是因为这时候堆的数量以及分配的内存块还很少，不会耗费太多时间去枚举；二是因为这时候只有一个主线程，不会有其它线程来同时操作堆，也就不会出现死锁。测试结果显示，在这个时间点调用RAND_poll只用了不到100毫秒的时间。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RAND_poll函数是OpenSSL中用于初始化伪随机数生成器的函数，当首次调用诸如RAND_bytes等需要生成随机数的函数时，会先调用该函数进行初始化。在实际使用中发现，RAND_poll函数在Windows下存在一些问题，需要小心提放，否则可能会对程序造成不良影响。&lt;/p&gt;</summary>
    
    
    
    
    <category term="RAND_poll" scheme="http://zplutor.github.io/tags/RAND-poll/"/>
    
    <category term="RAND_bytes" scheme="http://zplutor.github.io/tags/RAND-bytes/"/>
    
    <category term="OpenSSL" scheme="http://zplutor.github.io/tags/OpenSSL/"/>
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="性能" scheme="http://zplutor.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
    <category term="死锁" scheme="http://zplutor.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>创建一个最简单的Windowless RichEdit</title>
    <link href="http://zplutor.github.io/2015/11/22/create-a-simplest-windowless-richedit/"/>
    <id>http://zplutor.github.io/2015/11/22/create-a-simplest-windowless-richedit/</id>
    <published>2015-11-22T13:39:58.000Z</published>
    <updated>2023-04-15T14:08:05.765Z</updated>
    
    <content type="html"><![CDATA[<p>RichEdit是Windows上很常用的富文本控件，它有一个无窗口化的版本，即Windowless RichEdit，关于它的介绍，可以参考官方文档：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx</a> 。Windowless RichEdit与普通RichEdit在行为表现上毫无二致，但是在使用方法上却有较大的差异；而且Windowless RichEdit的官方文档少之又少，说明不够全面，甚至连一个完整的示例也没有；更甚者，在不同的Windows平台和开发环境下，Windowless RichEdit的用法都有差异。这让初次接触Windowless RichEdit的人举步维艰，处处碰壁，正应了“万事开头难”这句话。因此，本文聚焦于“开头”，介绍一下创建一个最简单的Windowless RichEdit需要做哪些事情。</p><span id="more"></span><h2 id="Windowless-RichEdit的接口"><a href="#Windowless-RichEdit的接口" class="headerlink" title="Windowless RichEdit的接口"></a>Windowless RichEdit的接口</h2><p>Windowless RichEdit是一个COM组件，使用者需要用到两个接口，分别是ITexService和ITextHost。ITextService表示Windowless RichEdit控件本身，提供了一系列访问该控件的方法。ITextHost是一个回调接口，需要由使用者实现，并传递给ITextService，当ITextService有需要的时候会调用该接口的方法。</p><h2 id="实现ITextHost"><a href="#实现ITextHost" class="headerlink" title="实现ITextHost"></a>实现ITextHost</h2><p>在创建ITextService的时候需要传递一个ITextHost对象给它，所以首先要做的是实现ITextHost。ITextHost定义于TextServ.h，它包含了一系列回调方法，其中下面几个是必须要实现的：</p><ul><li>TxGetPropertyBits</li><li>TxGetCharFormat</li><li>TxGetParaFormat</li><li>TxGetSysColor</li><li>TxGetSelectionBarWidth</li></ul><p>TxGetPropertyBits用于获取Windowless RichEdit的各种属性，例如是否支持多行，是否支持富文本等。最简单的实现方式是使用默认属性，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetPropertyBits</span><span class="params">(DWORD dwMask, DWORD* pdwBits)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    *pdwBits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该方法的返回值不是S_OK，在创建ITextService的时候会失败。</p><p>TxGetCharFormat和TxGetParaFormat分别用于获取默认的字符格式和段落格式。字符格式包括字体、大小、颜色、加粗、倾斜等属性；段落格式包括对齐方式等属性。最简单的实现方式是使用默认的格式，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetCharFormat</span><span class="params">(<span class="type">const</span> CHARFORMATW** ppCF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (char_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        char_format_ = std::<span class="built_in">make_unique</span>&lt;CHARFORMATW&gt;();</span><br><span class="line">        char_format_-&gt;cbSize = <span class="built_in">sizeof</span>(CHARFORMATW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ppCF = char_format_.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetParaFormat</span><span class="params">(<span class="type">const</span> PARAFORMAT** ppPF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (para_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        para_format_ = std::<span class="built_in">make_unique</span>&lt;PARAFORMAT&gt;();    </span><br><span class="line">        para_format_-&gt;cbSize = <span class="keyword">sizeof</span> PARAFORMAT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ppPF = para_format_.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法都要取得结构体的指针，这要求实现者自己来维护这些结构体的生命周期。这里使用std::unique_ptr智能指针来维护这两个结构体，并且把它们作为成员变量。这两个结构体除了cbSize之外，其它字段都可以置为0，表示使用默认设置。</p><p>如果这两个方法的返回值不是S_OK，在创建ITextService的时候会失败。</p><p>TxGetSysColor用于获取各种默认颜色值，例如背景颜色、字符颜色等。如果没有特殊需求，只要调用GetSysColor即可，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">TxGetSysColor</span><span class="params">(<span class="type">int</span> nIndex)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetSysColor</span>(nIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TxGetSelectionBarWidth用于获取selection bar的宽度。所谓selection bar就是位于控件左侧的竖直长条形区域，这块区域不可见，当鼠标移动到上面时，鼠标指针会水平翻转，此时点击左键就可以快速选择一整行的内容。之所以要实现这个方法，是因为Windowless RichEdit没有初始化表示selection bar宽度的变量，导致这个宽度在大部分情况下远远超出了Windowless RichEdit的可视区域，造成文字绘制不出来的假象。所以初始化这个变量的任务要由实现者来完成了，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetSelectionBarWidth</span><span class="params">(LONG *lSelBarWidth)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    *lSelBarWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建ITextService"><a href="#创建ITextService" class="headerlink" title="创建ITextService"></a>创建ITextService</h2><p>实现了ITextHost之后，即可使用函数CreateTextServices来创建ITextService，该函数也位于TextServ.h，其声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CreateTextServices</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_  IUnknown  *punkOuter,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_  ITextHost *pITextHost,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ IUnknown  **ppUnk</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数punkOuter用于对象聚合，一般情况下传nullptr即可；第二个参数plTextHost即ITextHost对象；第三个参数ppUnk是获取返回结果的输出参数，注意该参数的实际类型是IUnknown，而不是ITextService，所以之后还要再调用一次QueryInterface来取得ITextService。</p><p>官方文档指出使用CreateTextServices时需要导入riched20.lib这个库，但是在Visual Studio 2013环境下是找不到这个文件的，所以只能动态加载riched20.dll并且找出CreateTextServices的地址。更旧的Visual Studio版本可能没有这个问题。</p><p>同样的，查询ITextService时用到的IID_ITextService常量也要用这种方式来得到。不过，据说在riched20.dll中导出的IID_ITextService常量是错误的，使用它查询不到ITextService。但在Windows 7下试验过是可以的，可能在这个版本的Windows中已经修复了这个问题。如果从DLL中拿出来的IID_ITextService确实有问题，那么可以自己来定义这个常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTERN_C <span class="type">const</span> IID IID_ITextServices = &#123;</span><br><span class="line">    <span class="number">0x8d33f740</span>,</span><br><span class="line">    <span class="number">0xcf58</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9d</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过动态加载DLL来创建ITextService的过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">g_text_host = std::<span class="built_in">make_shared</span>&lt;TextHost&gt;();</span><br><span class="line"></span><br><span class="line">HMODULE module_handle = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;riched20.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(_stdcall*CreateTextServicesFunction)</span><span class="params">(IUnknown*, ITextHost*, IUnknown**)</span></span>;</span><br><span class="line">CreateTextServicesFunction create_function = <span class="built_in">reinterpret_cast</span>&lt;CreateTextServicesFunction&gt;(<span class="built_in">GetProcAddress</span>(module_handle, <span class="string">&quot;CreateTextServices&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> IID* iid_text_service = <span class="built_in">reinterpret_cast</span>&lt;IID*&gt;(<span class="built_in">GetProcAddress</span>(module_handle, <span class="string">&quot;IID_ITextServices&quot;</span>));</span><br><span class="line"></span><br><span class="line">CComPtr&lt;IUnknown&gt; unknown;</span><br><span class="line"><span class="built_in">create_function</span>(<span class="literal">nullptr</span>, g_text_host.<span class="built_in">get</span>(), &amp;unknown);</span><br><span class="line">unknown-&gt;<span class="built_in">QueryInterface</span>(*iid_text_service, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;g_text_service));</span><br></pre></td></tr></table></figure><p>上述代码通过LoadLibrary加载riched20.dll，然后通过GetProcAddress得到CreateTextServices和IID_ITextService的地址。注意，当还在使用ITextService的时候，不能调用FreeLibrary卸载riched20.dll，否则会出错。</p><h2 id="绘制Windowless-RichEdit"><a href="#绘制Windowless-RichEdit" class="headerlink" title="绘制Windowless RichEdit"></a>绘制Windowless RichEdit</h2><p>最后要做的就是把Windowless RichEdit显示出来，只要调用ITextService的TxDraw方法即可完成。该方法的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxDraw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD          dwDrawAspect,</span></span></span><br><span class="line"><span class="params"><span class="function">    LONG           lindex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>           *pvAspect,</span></span></span><br><span class="line"><span class="params"><span class="function">    DVTARGETDEVICE *ptd,</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC            hdcDraw,</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC            hicTargetDev,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCRECTL       lprcBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCRECTL       lprcWBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPRECT         lprcUpdate,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL CALLBACK  *pfnContinue,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD          dwContinue,</span></span></span><br><span class="line"><span class="params"><span class="function">    LONG           lViewId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法的参数繁多，但大部分情况下只需要关注其中的<code>dwDrawAspect</code>、<code>hdcDraw</code>和<code>lprcBounds</code>即可。dwDrawAspect指定要绘制控件的哪一部分，传入DVASPECT_CONTENT即可，表示绘制控件内容；hdcDraw即用来绘制的DeviceContext句柄；lprcBounds指定要绘制的区域。其它参数只要指定无效值即可，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RECT rect;</span><br><span class="line"><span class="built_in">GetClientRect</span>(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">g_text_service-&gt;<span class="built_in">TxDraw</span>(</span><br><span class="line">    DVASPECT_CONTENT,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    hdc,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="built_in">reinterpret_cast</span>&lt;LPCRECTL&gt;(&amp;rect),</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lprcBounds的使用的类型是RECTL，与平常使用的RECT不一样，但是它们的定义是一模一样的，因此可以使用强制类型转换。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>在本文的最后，附上完整的示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atlbase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Richedit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TextServ.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextHost</span> : <span class="keyword">public</span> ITextHost &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">HRESULT __stdcall <span class="title">QueryInterface</span><span class="params">(REFIID riid, <span class="type">void</span>** ppvObject)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ppvObject == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> E_POINTER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((riid == IID_IUnknown) || (riid == IID_ITextHost)) &#123;</span><br><span class="line">            *ppvObject = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> S_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppvObject = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> E_NOINTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ULONG __stdcall <span class="title">AddRef</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ULONG __stdcall <span class="title">Release</span><span class="params">(<span class="type">void</span>)</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HDC <span class="title">TxGetDC</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">INT <span class="title">TxReleaseDC</span><span class="params">(HDC hdc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowScrollBar</span><span class="params">(INT fnBar, BOOL fShow)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxEnableScrollBar</span><span class="params">(INT fuSBFlags, INT fuArrowflags)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollRange</span><span class="params">(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollPos</span><span class="params">(INT fnBar, INT nPos, BOOL fRedraw)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxInvalidateRect</span><span class="params">(LPCRECT prc, BOOL fMode)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxViewChange</span><span class="params">(BOOL fUpdate)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxCreateCaret</span><span class="params">(HBITMAP hbmp, INT xWidth, INT yHeight)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowCaret</span><span class="params">(BOOL fShow)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetCaretPos</span><span class="params">(INT x, INT y)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetTimer</span><span class="params">(UINT idTimer, UINT uTimeout)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxKillTimer</span><span class="params">(UINT idTimer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxScrollWindowEx</span><span class="params">(INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxSetCapture</span><span class="params">(BOOL fCapture)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxSetFocus</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxSetCursor</span><span class="params">(HCURSOR hcur, BOOL fText)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxScreenToClient</span><span class="params">(LPPOINT lppt)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxClientToScreen</span><span class="params">(LPPOINT lppt)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxActivate</span><span class="params">(LONG * plOldState)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxDeactivate</span><span class="params">(LONG lNewState)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetClientRect</span><span class="params">(LPRECT prc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetViewInset</span><span class="params">(LPRECT prc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetCharFormat</span><span class="params">(<span class="type">const</span> CHARFORMATW **ppCF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (char_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            char_format_ = std::<span class="built_in">make_unique</span>&lt;CHARFORMATW&gt;();</span><br><span class="line">            char_format_-&gt;cbSize = <span class="built_in">sizeof</span>(CHARFORMATW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppCF = char_format_.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetParaFormat</span><span class="params">(<span class="type">const</span> PARAFORMAT **ppPF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (para_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            para_format_ = std::<span class="built_in">make_unique</span>&lt;PARAFORMAT&gt;();    </span><br><span class="line">            para_format_-&gt;cbSize = <span class="keyword">sizeof</span> PARAFORMAT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppPF = para_format_.<span class="built_in">get</span>();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">COLORREF <span class="title">TxGetSysColor</span><span class="params">(<span class="type">int</span> nIndex)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetSysColor</span>(nIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetBackStyle</span><span class="params">(TXTBACKSTYLE *pstyle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetMaxLength</span><span class="params">(DWORD *plength)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetScrollBars</span><span class="params">(DWORD *pdwScrollBar)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPasswordChar</span><span class="params">(_Out_ TCHAR *pch)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetAcceleratorPos</span><span class="params">(LONG *pcp)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetExtent</span><span class="params">(LPSIZEL lpExtent)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxCharFormatChange</span><span class="params">(<span class="type">const</span> CHARFORMATW * pCF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxParaFormatChange</span><span class="params">(<span class="type">const</span> PARAFORMAT * pPF)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPropertyBits</span><span class="params">(DWORD dwMask, DWORD *pdwBits)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        *pdwBits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxNotify</span><span class="params">(DWORD iNotify, <span class="type">void</span> *pv)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HIMC <span class="title">TxImmGetContext</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TxImmReleaseContext</span><span class="params">(HIMC himc)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetSelectionBarWidth</span><span class="params">(LONG *lSelBarWidth)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        *lSelBarWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;CHARFORMATW&gt; char_format_;</span><br><span class="line">    std::unique_ptr&lt;PARAFORMAT&gt; para_format_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="type">const</span> IID IID_ITextServices = &#123;</span><br><span class="line">    <span class="number">0x8d33f740</span>,</span><br><span class="line">    <span class="number">0xcf58</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9d</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="type">const</span> IID IID_ITextHost = &#123;</span><br><span class="line">    <span class="number">0xc5bdd8d0</span>,</span><br><span class="line">    <span class="number">0xd26e</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9e</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;TextHost&gt; g_text_host;</span><br><span class="line">CComPtr&lt;ITextServices&gt; g_text_service;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="type">char</span>*, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WNDCLASSEX default_class = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    default_class.cbSize = <span class="built_in">sizeof</span>(default_class);</span><br><span class="line">    default_class.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    default_class.lpfnWndProc = WindowProcedure;</span><br><span class="line">    default_class.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    default_class.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    default_class.hInstance = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.hIcon = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">nullptr</span>, IDI_APPLICATION);</span><br><span class="line">    default_class.hbrBackground = <span class="built_in">reinterpret_cast</span>&lt;HBRUSH&gt;(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">    default_class.lpszMenuName = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.lpszClassName = <span class="string">L&quot;WindowlessRichEdit&quot;</span>;</span><br><span class="line">    default_class.hIconSm = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClassEx</span>(&amp;default_class);</span><br><span class="line"></span><br><span class="line">    HWND window_handle = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="string">L&quot;WindowlessRichEdit&quot;</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        WS_OVERLAPPEDWINDOW | WS_VISIBLE,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE: &#123;</span><br><span class="line"></span><br><span class="line">        g_text_host = std::<span class="built_in">make_shared</span>&lt;TextHost&gt;();</span><br><span class="line"></span><br><span class="line">        HMODULE module_handle = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;riched20.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(_stdcall*CreateTextServicesFunction)</span><span class="params">(IUnknown*, ITextHost*, IUnknown**)</span></span>;</span><br><span class="line">        CreateTextServicesFunction create_function = <span class="built_in">reinterpret_cast</span>&lt;CreateTextServicesFunction&gt;(<span class="built_in">GetProcAddress</span>(module_handle, <span class="string">&quot;CreateTextServices&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> IID* iid_text_service = <span class="built_in">reinterpret_cast</span>&lt;IID*&gt;(<span class="built_in">GetProcAddress</span>(module_handle, <span class="string">&quot;IID_ITextServices&quot;</span>));</span><br><span class="line"></span><br><span class="line">        CComPtr&lt;IUnknown&gt; unknown;</span><br><span class="line">        <span class="built_in">create_function</span>(<span class="literal">nullptr</span>, g_text_host.<span class="built_in">get</span>(), &amp;unknown);</span><br><span class="line">        unknown-&gt;<span class="built_in">QueryInterface</span>(*iid_text_service, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;g_text_service));</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;<span class="built_in">TxSetText</span>(<span class="string">L&quot;Windowless RichEdit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_PAINT: &#123;</span><br><span class="line"></span><br><span class="line">        PAINTSTRUCT paint_struct;</span><br><span class="line">        HDC hdc = <span class="built_in">BeginPaint</span>(hwnd, &amp;paint_struct);</span><br><span class="line"></span><br><span class="line">        RECT rect;</span><br><span class="line">        <span class="built_in">GetClientRect</span>(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;<span class="built_in">TxDraw</span>(</span><br><span class="line">            DVASPECT_CONTENT,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            hdc,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;LPCRECTL&gt;(&amp;rect),</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">EndPaint</span>(hwnd, &amp;paint_struct);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CallWindowProc</span>(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;RichEdit是Windows上很常用的富文本控件，它有一个无窗口化的版本，即Windowless RichEdit，关于它的介绍，可以参考官方文档：&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx&lt;/a&gt; 。Windowless RichEdit与普通RichEdit在行为表现上毫无二致，但是在使用方法上却有较大的差异；而且Windowless RichEdit的官方文档少之又少，说明不够全面，甚至连一个完整的示例也没有；更甚者，在不同的Windows平台和开发环境下，Windowless RichEdit的用法都有差异。这让初次接触Windowless RichEdit的人举步维艰，处处碰壁，正应了“万事开头难”这句话。因此，本文聚焦于“开头”，介绍一下创建一个最简单的Windowless RichEdit需要做哪些事情。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
    <category term="RichEdit" scheme="http://zplutor.github.io/tags/RichEdit/"/>
    
  </entry>
  
  <entry>
    <title>WM_TIMER消息是否会在消息队列中堆积</title>
    <link href="http://zplutor.github.io/2015/11/09/whether-WM-TIMER-message-would-accumulate-in-message-queue/"/>
    <id>http://zplutor.github.io/2015/11/09/whether-WM-TIMER-message-would-accumulate-in-message-queue/</id>
    <published>2015-11-09T15:29:31.000Z</published>
    <updated>2016-04-16T12:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Windows界面开发中，启动定时器的最常用方法是使用SetTimer这个API。通过这个API启动的定时器会持续不断地往窗口消息队列中投递WM_TIMER消息，直到调用了KillTimer来停止。一个有趣的问题是，假如定时器的消息程序处理不过来，即处理WM_TIMER的时间比定时器的间隔时间长，会发生什么事情呢？消息队列中是否会堆积越来越多的WM_TIMER消息？官方文档中并没有指出这个问题，只能通过实践来找出答案。</p><span id="more"></span><p>定时器有多种使用场景，下面针对每种场景分别进行试验。</p><h2 id="一个窗口一个定时器"><a href="#一个窗口一个定时器" class="headerlink" title="一个窗口一个定时器"></a>一个窗口一个定时器</h2><p>首先是最简单的使用场景，在一个窗口中启动一个定时器。使用下面的代码生成一个Windows应用程序（为了便于阅读，省略了注册窗口类和创建窗口的代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line">DWORD g_begin_tick_count = <span class="number">0</span>;</span><br><span class="line">DWORD g_counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kTimerId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="type">char</span>*, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClassEx</span>(...);</span><br><span class="line">    HWND window_handle = <span class="built_in">CreateWindowEx</span>(...);</span><br><span class="line"></span><br><span class="line">    g_begin_tick_count = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    <span class="built_in">SetTimer</span>(window_handle, kTimerId, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line"></span><br><span class="line">        std::wstringstream stream;</span><br><span class="line">        stream &lt;&lt; <span class="string">L&quot;Process WM_TIMER. &quot;</span> </span><br><span class="line">            &lt;&lt; <span class="string">L&quot;TimerId: &quot;</span> &lt;&lt; wParam &lt;&lt; <span class="string">&quot;. &quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">L&quot;Counter: &quot;</span> &lt;&lt; ++g_counter &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">L&quot;Time: &quot;</span> &lt;&lt; <span class="built_in">GetTickCount</span>() - g_begin_tick_count &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::wstring string = stream.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(string.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_counter &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CallWindowProc</span>(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个间隔时间为1秒的定时器，在处理WM_TIMER的时候，输出定时器ID，消息个数以及当前时间。<code>g_counter</code>全局变量记录处理过的WM_TIMER消息的数量；时间的计算使用GetTickCount函数，单位是毫秒。在处理前面4个WM_TIMER的时候，使用Sleep函数使程序挂起5秒，模拟处理时间过长的情景。</p><p>程序总的挂起时间是<code>4*5=20</code>秒，在这段时间内，定时器理应触发20次，即投递20个WM_TIMER消息，但是程序只能处理其中的3个（第一个不算）。假如WM_TIMER消息会堆积，那么从第5个开始，由于不再挂起程序，这些堆积的消息可以一口气处理完。观察程序是否会在短时间内连续输出，即可验证这个假设。</p><p>启动程序，静置一段时间之后，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 3, Time: 11029.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 6, Time: 21294.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 7, Time: 22308.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 8, Time: 23322.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 9, Time: 24336.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 10, Time: 25350.</span><br></pre></td></tr></table></figure><p>可以看到，在处理了第5个WM_TIMER消息之后，紧接着就处理了第6个，接下来每隔1秒处理一个，并没有一口气处理了一批。也就是说，WM_TIMER消息并不会堆积。</p><h2 id="一个窗口多个定时器"><a href="#一个窗口多个定时器" class="headerlink" title="一个窗口多个定时器"></a>一个窗口多个定时器</h2><p>如果一个窗口中多有个定时器，其中某个定时器处理不过来，对其它的定时器有什么影响呢？继续进行试验，把上面的代码稍作修改，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line">DWORD g_begin_tick_count = <span class="number">0</span>;</span><br><span class="line">DWORD g_counter1 = <span class="number">0</span>;</span><br><span class="line">DWORD g_counter2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kTimerId1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kTimerId2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="type">char</span>*, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClassEx</span>(...);</span><br><span class="line">    HWND window_handle = <span class="built_in">CreateWindowEx</span>(...);</span><br><span class="line"></span><br><span class="line">    g_begin_tick_count = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    <span class="built_in">SetTimer</span>(window_handle, kTimerId1, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">SetTimer</span>(window_handle, kTimerId2, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line"></span><br><span class="line">        std::wstringstream stream;</span><br><span class="line">        stream &lt;&lt; <span class="string">L&quot;Process WM_TIMER. &quot;</span> </span><br><span class="line">            &lt;&lt; <span class="string">L&quot;TimerId: &quot;</span> &lt;&lt; wParam &lt;&lt; <span class="string">&quot;. &quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">L&quot;Counter: &quot;</span> &lt;&lt; (wParam == kTimerId1 ? ++g_counter1 : ++g_counter2) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">L&quot;Time: &quot;</span> &lt;&lt; <span class="built_in">GetTickCount</span>() - g_begin_tick_count &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::wstring string = stream.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(string.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wParam == kTimerId1) &amp;&amp; (g_counter1 &lt; <span class="number">5</span>)) &#123;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CallWindowProc</span>(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了两个间隔都是1秒的定时器，分别用<code>g_counter1</code>和<code>g_counter2</code>两个全局变量来记录它们处理过的WM_TIMER消息的数量。同样地，在处理第一个定时器的前4个WM_TIMER消息时，调用Sleep函数挂起程序5秒。第二个定时器的WM_TIMER消息不做特殊处理。</p><p>启动程序，静置一段时间之后，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 2. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 3, Time: 11030.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 3, Time: 11030.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 6, Time: 21295.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 6, Time: 21295.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 7, Time: 22309.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 7, Time: 22309.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 8, Time: 23323.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 8, Time: 23323.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 9, Time: 24337.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 9, Time: 24337.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 10, Time: 25351.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 10, Time: 25351.</span><br></pre></td></tr></table></figure><p>两个定时器的行为基本一致，而且跟上一个场景一样，在连续处理了第5个和第6个WM_TIMER消息之后，还是每隔1秒处理一个。可见，第一个定时器处理不过来，会影响到第二个定时器，但是它们的WM_TIMER消息都不会堆积。</p><h2 id="多个窗口多个定时器"><a href="#多个窗口多个定时器" class="headerlink" title="多个窗口多个定时器"></a>多个窗口多个定时器</h2><p>最后再看看在不同窗口中启动多个定时器的场景。修改上一个场景的代码，在另一个窗口中创建第二个定时器，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="type">char</span>*, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterClassEx</span>(...);</span><br><span class="line">    HWND window_handle1 = <span class="built_in">CreateWindowEx</span>(...);</span><br><span class="line">    HWND window_handle2 = <span class="built_in">CreateWindowEx</span>(...);</span><br><span class="line"></span><br><span class="line">    g_begin_tick_count = <span class="built_in">GetTickCount</span>();</span><br><span class="line">    <span class="built_in">SetTimer</span>(window_handle1, kTimerId1, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">SetTimer</span>(window_handle2, kTimerId2, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">        <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的代码保持不变。</p><p>启动程序，静置一段时间之后，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 2. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 2, Time: 6022.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 3, Time: 11030.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 3, Time: 11030.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 4, Time: 16037.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 5, Time: 21045.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 6, Time: 21295.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 6, Time: 21295.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 7, Time: 22309.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 7, Time: 22309.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 8, Time: 23323.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 8, Time: 23323.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 9, Time: 24337.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 9, Time: 24337.</span><br><span class="line">Process WM_TIMER. TimerId: 2. Counter: 10, Time: 25351.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 10, Time: 25351.</span><br></pre></td></tr></table></figure><p>结果跟第二个场景一模一样，可见即使是不同窗口中的定时器，WM_TIMER消息也不会堆积。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上三个场景的试验，可以得出这个结论：同一个定时器的WM_TIMER消息在消息队列中至多存在一个，不会堆积。</p><p>要注意的是，即使WM_TIMER消息不会堆积，在使用定时器时仍然要小心避免处理时间比间隔时间长的情况。由试验结果可以看到，一旦出现这种情况，消息队列中总会存在一个WM_TIMER消息等待处理，程序会忙于处理这些WM_TIMER消息，一刻都不停歇，就像陷入了一个循环，这对程序有严重的影响。</p><p>由于各种因素的影响，对于同样的处理逻辑，每次执行所用的时间很可能都不一样。所以，如果担心处理时间过长，可以通过更安全的方式来使用定时器，即模拟一次性定时器：在开始处理WM_TIMER消息的时候，调用KillTimer停止定时器；处理完成之后，再调用SetTimer重新开启定时器。例如，把第一个场景中处理WM_TIMER的代码改成以下的安全方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">KillTimer</span>(hwnd, kTimerId);</span><br><span class="line"></span><br><span class="line">        std::wstringstream stream;</span><br><span class="line">        stream &lt;&lt; <span class="string">L&quot;Process WM_TIMER. &quot;</span> </span><br><span class="line">            &lt;&lt; <span class="string">L&quot;TimerId: &quot;</span> &lt;&lt; wParam &lt;&lt; <span class="string">&quot;. &quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">L&quot;Counter: &quot;</span> &lt;&lt; ++g_counter &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">L&quot;Time: &quot;</span> &lt;&lt; <span class="built_in">GetTickCount</span>() - g_begin_tick_count &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::wstring string = stream.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(string.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_counter &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SetTimer</span>(hwnd, kTimerId, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CallWindowProc</span>(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，静置一段时间之后，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 2, Time: 7036.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 3, Time: 13058.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 4, Time: 19079.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 5, Time: 25101.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 6, Time: 26115.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 7, Time: 27129.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 8, Time: 28143.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 9, Time: 29157.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 10, Time: 30171.</span><br><span class="line">Process WM_TIMER. TimerId: 1. Counter: 11, Time: 31185.</span><br></pre></td></tr></table></figure><p>通过这种方式，不管处理时间有多长，在处理完一个WM_TIMER消息之后，总会真正等待1秒才处理下一个，避免了程序长时间处于繁忙状态的情况。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Windows界面开发中，启动定时器的最常用方法是使用SetTimer这个API。通过这个API启动的定时器会持续不断地往窗口消息队列中投递WM_TIMER消息，直到调用了KillTimer来停止。一个有趣的问题是，假如定时器的消息程序处理不过来，即处理WM_TIMER的时间比定时器的间隔时间长，会发生什么事情呢？消息队列中是否会堆积越来越多的WM_TIMER消息？官方文档中并没有指出这个问题，只能通过实践来找出答案。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="定时器" scheme="http://zplutor.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
    <category term="WM_TIMER" scheme="http://zplutor.github.io/tags/WM-TIMER/"/>
    
    <category term="消息队列" scheme="http://zplutor.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如何让std::shared_ptr持有IUnknown对象</title>
    <link href="http://zplutor.github.io/2015/10/31/how-to-maintain-iunknown-object-in-shared-ptr/"/>
    <id>http://zplutor.github.io/2015/10/31/how-to-maintain-iunknown-object-in-shared-ptr/</id>
    <published>2015-10-31T03:26:46.000Z</published>
    <updated>2018-04-08T16:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11新增的智能指针std::shared_ptr使用引用计数来管理对象的生命周期，而COM提供的IUnknown接口也使用引用计数来管理自身的生命周期。理论上来说，在同一个环境中不应该同时使用两套引用计数方案，不然会造成混乱，带来很多麻烦。然而实际上，需要同时使用这两种方案的情况并不少见，有时的确需要用std::shared_ptr来持有COM对象。虽然这种做法看上去丑陋，并且是可以用别的方法来避免的，但本文不讨论这些方面，只聚焦于问题的本身。</p><span id="more"></span><p>得益于std::shared_ptr提供的灵活性，持有COM对象是十分简单的。在默认情况下，当std::shared_ptr的引用计数达到0时，它会调用delete操作符来销毁持有的对象。然而在构造std::shared_ptr的时候，可以传入一个自定义的删除器，来改变它默认的删除行为。删除器可以是函数、仿函数或者lambda表达式等可调用的函数对象。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> deletor = [](<span class="type">int</span>* p) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;deleting &quot;</span> &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">i1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(), deletor)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; i2 = i1;</span><br><span class="line">    i1.<span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码用一个lambda表达式作为变量<code>i1</code>的删除器，该删除器在销毁int之前会打印出一行消息。删除器会随着std::shared_ptr一同拷贝或赋值，所以不必担心删除器会丢失。在上面的代码中，变量<code>i2</code>接管了删除器，在程序退出之前依然会打印出那条消息。</p><p>显然，对于COM对象来说，只要在删除器里调用Release方法来替换delete操作符即可。下面是将IUnknown对象转成std::shared_ptr的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;IUnknown&gt; <span class="title">ConvertToSharedPtr</span><span class="params">(IUnknown* unknown)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    unknown-&gt;<span class="built_in">AddRef</span>();</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;IUnknown&gt;(unknown, [](IUnknown* p) &#123; p-&gt;<span class="built_in">Release</span>(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在将COM对象传递给std::shared_ptr之前务必要调用AddRef方法增加它的引用计数。这样一来，在同一个对象上存在着两个引用计数：IUnknown的引用计数是主要的，只有当这个引用计数达到0时，对象才会被销毁；std::shared_ptr的引用计数是次要的，当这个引用计数达到0时，只会把IUnknown的引用计数减一。两者和谐共存，不会相互影响。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11新增的智能指针std::shared_ptr使用引用计数来管理对象的生命周期，而COM提供的IUnknown接口也使用引用计数来管理自身的生命周期。理论上来说，在同一个环境中不应该同时使用两套引用计数方案，不然会造成混乱，带来很多麻烦。然而实际上，需要同时使用这两种方案的情况并不少见，有时的确需要用std::shared_ptr来持有COM对象。虽然这种做法看上去丑陋，并且是可以用别的方法来避免的，但本文不讨论这些方面，只聚焦于问题的本身。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
    <category term="IUnknown" scheme="http://zplutor.github.io/tags/IUnknown/"/>
    
    <category term="智能指针" scheme="http://zplutor.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
    <category term="引用计数" scheme="http://zplutor.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
    <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
  </entry>
  
  <entry>
    <title>如何调试在std::thread子线程中抛出的C++异常</title>
    <link href="http://zplutor.github.io/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/"/>
    <id>http://zplutor.github.io/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/</id>
    <published>2015-10-11T12:06:41.000Z</published>
    <updated>2018-04-08T16:56:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11标准库新增的std::thread类可以方便地开启子线程。然而有个奇怪的现象是，如果在这些子线程中抛出了未处理的C++异常而导致程序崩溃，那么在生成的dump文件中将还原不出异常发生时的调用栈。可以通过下面的方法来展示这个现象。</p><span id="more"></span><p>首先使用以下代码生成一个控制台程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::thread* g_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    g_thread = <span class="keyword">new</span> std::<span class="built_in">thread</span>(ThreadEntry);</span><br><span class="line">    g_thread-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，就是通过std::thread创建一个子线程，并且在这个子线程中访问一个空的std::vector中的元素，让它抛出C++异常。务必要使用Release配置来生成程序，不能使用Debug配置。</p><p>接下来，在资源管理器中直接运行该程序，注意不要通过调试器来运行。一般会在第二次运行的时候，出现下面的Windows错误报告窗口：</p><img src="/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/1.png" class=""><p>在详细信息中的C:\Users\Zplutor\AppData\Local\Temp\WERBF98.tmp.mdmp文件即是Windows错误报告为崩溃的程序生成的dump文件，里面包含了程序崩溃时的一些信息，例如函数调用栈。该文件在关闭了错误报告窗口时即被删除，所以要先把这个文件复制出来。</p><p>最后，用WinDbg打开这个dump文件，先用.ecxr命令切换到异常环境，再用k命令显示调用栈，结果显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; k</span><br><span class="line">  *** Stack trace for last set context - .thread/.cxr resets it</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">0095f07c 6ba8dc5f msvcr120!abort+0x38 [f:\dd\vctools\crt\crtw32\misc\abort.c @ 90]</span><br><span class="line">0095f0ac 6b99f353 msvcr120!terminate+0x33 [f:\dd\vctools\crt\crtw32\eh\hooks.cpp @ 96]</span><br><span class="line">0095f8fc 6ba1c01d msvcp120!_Call_func+0x2e [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f934 6ba1c001 msvcr120!_callthreadstartex+0x1b [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]</span><br><span class="line">0095f940 7685ee6c msvcr120!_threadstartex+0x7c [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]</span><br><span class="line">0095f94c 77053ab3 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">0095f98c 77053a86 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">0095f9a4 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure><p>可以看到，显示出来的调用栈几乎没有用处，只能看出子线程在开始之后就调用了terminate函数来终止程序，完全看不出来是什么原因导致的。</p><p>在调试的时候，如果遇到难以逾越的问题，不妨大胆地进行推测，并根据这些推测进行尝试。推测不一定是正确的，但是在尝试的过程中很可能会发现新的解法。在当前这个例子中，即使不了解std::thread子线程的具体实现，也不难根据上面的调用栈推测出来。下面是一种可能的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _Call_func() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">ThreadEntry</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">terminate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_Call_func函数用来调用在std::thread的构造函数中传进来的入口函数，在本例中即是ThreadEntry。该入口函数通过一对try&#x2F;catch包裹起来，凡是在它里面抛出来的未处理异常都会被捕获，继而调用terminate函数来终止程序。由于terminate是在_Call_func函数中调用的，所以从调用栈上来看，terminate的上一个栈帧必然是_Call_func，ThreadEntry内部的所有栈帧都被跳过了。</p><p>根据以上的推测可知，异常发生时的调用栈还原不出来，只是因为它的栈帧被跳过了而已，假如这些栈帧还保留着，那肯定还是能还原出来的。继续观察上述的调用栈，发现_Call_func和terminate的栈帧之间尚有大约2KB（根据ChildEBP计算得来，0095f8fc - 0095f0ac）的内容，因此可以有八九分把握确定被跳过的栈帧就在这里面。</p><p>接下来要通过手工方式寻找那些被跳过的栈帧。从terminate栈帧的ChildEBP开始，使用dps命令逐步向上寻找。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; dps 0095f0ac l32</span><br><span class="line">0095f0ac  0095f8fc</span><br><span class="line">0095f0b0  6b99f353 msvcp120!_Call_func+0x2e [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f0b4  6ba097f2 msvcr120!_NLG_Return [f:\dd\vctools\crt\crtw32\eh\i386\lowhelpr.asm @ 64]</span><br><span class="line">0095f0b8  0095f8f0</span><br><span class="line">0095f0bc  0095f37c</span><br><span class="line">0095f0c0  0095f0d0</span><br><span class="line">0095f0c4  0095f8f0</span><br><span class="line">0095f0c8  00000000</span><br><span class="line">0095f0cc  0095f8fc</span><br><span class="line">0095f0d0  0095f0fc</span><br><span class="line">0095f0d4  6ba09861 msvcr120!_CallCatchBlock2+0x4f [f:\dd\vctools\crt\crtw32\eh\i386\trnsctrl.cpp @ 502]</span><br><span class="line">0095f0d8  6b99f34d msvcp120!_Call_func+0x28 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f0dc  0095f8f0</span><br><span class="line">0095f0e0  00000100</span><br><span class="line">0095f0e4  0095f158</span><br><span class="line">0095f0e8  6ba09ffc msvcr120!CatchGuardHandler [f:\dd\vctools\crt\crtw32\eh\i386\trnsctrl.cpp @ 535]</span><br><span class="line">0095f0ec  c29105eb</span><br><span class="line">0095f0f0  6b9b4bc0 msvcp120!_CTA4?AVsystem_errorstd+0x7c</span><br><span class="line">0095f0f4  0095f8f0</span><br><span class="line">0095f0f8  00000001</span><br><span class="line">0095f0fc  0095f168</span><br><span class="line">0095f100  6ba0999c msvcr120!CallCatchBlock+0x87 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1400]</span><br><span class="line">0095f104  0095f8f0</span><br><span class="line">0095f108  6b9b4bc0 msvcp120!_CTA4?AVsystem_errorstd+0x7c</span><br><span class="line">0095f10c  6b99f34d msvcp120!_Call_func+0x28 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f110  00000000</span><br><span class="line">0095f114  00000100</span><br><span class="line">0095f118  c2910467</span><br><span class="line">0095f11c  0095f8f0</span><br><span class="line">0095f120  6b9b4bac msvcp120!_CTA4?AVsystem_errorstd+0x68</span><br><span class="line">0095f124  0095f8f0</span><br><span class="line">0095f128  0095f898</span><br><span class="line">0095f12c  00000000</span><br><span class="line">0095f130  00000000</span><br><span class="line">0095f134  00000000</span><br><span class="line">0095f138  00000000</span><br><span class="line">0095f13c  0095f128</span><br><span class="line">0095f140  0095f8dc</span><br><span class="line">0095f144  6b9ff756 msvcr120!_getptd+0x6 [f:\dd\vctools\crt\crtw32\startup\tidtable.c @ 337]</span><br><span class="line">0095f148  00000000</span><br><span class="line">0095f14c  6b99f34d msvcp120!_Call_func+0x28 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]</span><br><span class="line">0095f150  0095f118</span><br><span class="line">0095f154  c291048b</span><br><span class="line">0095f158  0095f2a8</span><br><span class="line">0095f15c  6ba0a0d5 msvcr120!_except_handler4 [f:\dd\vctools\crt\crtw32\misc\i386\chandler4gs.c @ 84]</span><br><span class="line">0095f160  a9a46ccf</span><br><span class="line">0095f164  00000001</span><br><span class="line">0095f168  0095f1a4</span><br><span class="line">0095f16c  6ba09a50 msvcr120!CatchIt+0x69 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1211]</span><br><span class="line">0095f170  0095f37c</span><br></pre></td></tr></table></figure><p>这个寻找过程需要耐心和运气，因为dps命令输出的结果非常多，而且有些并不是真正的栈帧。在不了解C++异常处理的情况下只能逐个排查，排查的方法是，使用k命令从该栈帧开始回溯调用栈，看看最终能不能到达KiUserExceptionDispatcher的栈帧。例如，可以从上面结果的最后一个栈帧CatchIt开始回溯。要注意，根据栈帧的结构，0095f16c存放的是返回地址，上一个0095f168存放的才是ebp，所以应使用0095f168来回溯。结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; k = 0095f168</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">0095f07c 6ba8dc5f msvcr120!abort+0x38 [f:\dd\vctools\crt\crtw32\misc\abort.c @ 90]</span><br><span class="line">0095f168 6ba09a50 msvcr120!terminate+0x33 [f:\dd\vctools\crt\crtw32\eh\hooks.cpp @ 96]</span><br><span class="line">0095f1a4 6ba095ab msvcr120!CatchIt+0x69 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1211]</span><br><span class="line">0095f220 6ba09638 msvcr120!FindHandler+0x27b [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 689]</span><br><span class="line">0095f254 6ba096ba msvcr120!__InternalCxxFrameHandler+0xd6 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 439]</span><br><span class="line">0095f290 770372b9 msvcr120!__CxxFrameHandler3+0x26 [f:\dd\vctools\crt\crtw32\eh\i386\trnsctrl.cpp @ 301]</span><br><span class="line">0095f2b4 7703728b ntdll!ExecuteHandler2+0x26</span><br><span class="line">0095f2d8 7700f9d7 ntdll!ExecuteHandler+0x24</span><br><span class="line">0095f364 77037117 ntdll!RtlDispatchException+0x127</span><br><span class="line">0095f364 00000000 ntdll!KiUserExceptionDispatcher+0xf</span><br></pre></td></tr></table></figure><p>这个调用栈最终到达了KiUserExceptionDispatcher，也就是我们要找的栈帧。为什么要找KiUserExceptionDispatcher的栈帧呢？这是因为在Windows下所有异常都是通过KiUserExceptionDispatcher这个函数抛出来的，这个函数具有两个类型分别为PEXCEPTION_RECORD和PCONTEXT的参数，分别指向异常信息以及异常发生时的线程环境信息。</p><p>既然找到了KiUserExceptionDispatcher的栈帧，那么可以换用kb命令，显示出它的参数列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; kb = 0095f168</span><br><span class="line">ChildEBP RetAddr  Args to Child              </span><br><span class="line">（略）</span><br><span class="line">0095f364 00000000 0095f37c 0095f39c 0095f37c ntdll!KiUserExceptionDispatcher+0xf</span><br></pre></td></tr></table></figure><p>可知PEXCEPTION_RECORD的值是0095f37c，PCONTEXT的值是0095f39c。</p><p>WinDbg提供了.exr命令来显示PEXCEPTION_RECORD的内容，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; .exr 0095f37c</span><br><span class="line">ExceptionAddress: 74c4812f (KERNELBASE!RaiseException+0x00000058)</span><br><span class="line">   ExceptionCode: e06d7363 (C++ EH exception)</span><br><span class="line">  ExceptionFlags: 00000001</span><br><span class="line">NumberParameters: 3</span><br><span class="line">   Parameter[0]: 19930520</span><br><span class="line">   Parameter[1]: 0095f898</span><br><span class="line">   Parameter[2]: 6b9b5734</span><br><span class="line">  pExceptionObject: 0095f898</span><br><span class="line">  _s_ThrowInfo    : 6b9b5734</span><br><span class="line">  Type            : class std::out_of_range</span><br><span class="line">  Type            : class std::logic_error</span><br><span class="line">  Type            : class std::exception</span><br></pre></td></tr></table></figure><p>可以看到这是一个C++异常，并且类型是std::out_of_range。</p><p>WinDbg亦提供了.cxr命令，可以切换到指定PCONTEXT的线程环境，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; .cxr 0095f39c</span><br><span class="line">eax=0095f7f8 ebx=00431ee8 ecx=00000003 edx=00000000 esi=6b9b5734 edi=0095f898</span><br><span class="line">eip=74c4812f esp=0095f7f8 ebp=0095f848 iopl=0         nv up ei pl nz ac po nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212</span><br><span class="line">KERNELBASE!RaiseException+0x58:</span><br><span class="line">74c4812f c9              leave</span><br></pre></td></tr></table></figure><p>至此，异常发生时的各种寄存器信息一览无余。此时使用k命令即可得到异常发生时的调用栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0:002&gt; k</span><br><span class="line">  *** Stack trace for last set context - .thread/.cxr resets it</span><br><span class="line">ChildEBP RetAddr  </span><br><span class="line">0095f848 6ba09339 KERNELBASE!RaiseException+0x58</span><br><span class="line">0095f888 6b983a3a msvcr120!_CxxThrowException+0x5b [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]</span><br><span class="line">0095f8a4 00c2104c msvcp120!std::_Xout_of_range+0x2e [f:\dd\vctools\crt\crtw32\stdcpp\xthrow.cpp @ 24]</span><br><span class="line">0095f8cc 00c211ac ConsoleApplication!ThreadEntry+0x4c [c:\users\zplutor\documents\projects\tests\consoleapplication\main.cpp @ 9]</span><br><span class="line">0095f8d4 6b99f33c ConsoleApplication!std::_LaunchPad&lt;std::_Bind&lt;1,void,void (__cdecl*const)(void)&gt; &gt;::_Go+0xc [c:\program files\microsoft visual studio 12.0\vc\include\thr\xthread @ 187]</span><br><span class="line">0095f8fc 6ba1c01d msvcp120!_Call_func+0x17 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 28]</span><br><span class="line">0095f934 6ba1c001 msvcr120!_callthreadstartex+0x1b [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]</span><br><span class="line">0095f940 7685ee6c msvcr120!_threadstartex+0x7c [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]</span><br><span class="line">0095f94c 77053ab3 kernel32!BaseThreadInitThunk+0xe</span><br><span class="line">0095f98c 77053a86 ntdll!__RtlUserThreadStart+0x70</span><br><span class="line">0095f9a4 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure><p>本文开头提到的现象并不是std::thread特有的。事实上，如果在捕获了一个异常之后的处理过程中又抛出了一个新的异常，那么旧异常的调用栈会被新异常的调用栈覆盖。在本文的例子中，_Call_func捕获了第一个异常之后，调用了terminate函数，terminate继而又调用了abort函数来抛出新的异常。使用本文提到的方法，就可以应对这种情况，还原出旧异常的调用栈。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++11标准库新增的std::thread类可以方便地开启子线程。然而有个奇怪的现象是，如果在这些子线程中抛出了未处理的C++异常而导致程序崩溃，那么在生成的dump文件中将还原不出异常发生时的调用栈。可以通过下面的方法来展示这个现象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="STL" scheme="http://zplutor.github.io/tags/STL/"/>
    
    <category term="线程" scheme="http://zplutor.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="WinDbg" scheme="http://zplutor.github.io/tags/WinDbg/"/>
    
    <category term="异常" scheme="http://zplutor.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>使用预编译头提高编译速度</title>
    <link href="http://zplutor.github.io/2015/09/28/use-precompiled-header-to-speed-up-compilation/"/>
    <id>http://zplutor.github.io/2015/09/28/use-precompiled-header-to-speed-up-compilation/</id>
    <published>2015-09-28T04:00:51.000Z</published>
    <updated>2016-04-16T12:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是预编译头"><a href="#什么是预编译头" class="headerlink" title="什么是预编译头"></a>什么是预编译头</h2><p>在介绍预编译头之前，有必要了解一下C&#x2F;C++的编译方式。C&#x2F;C++的编译单元是源文件（带有.c、.cc、.cpp等扩展名的文件），在编译一个源文件之前，预处理器会把这个源文件中所有通过#include指令包含进来的头文件递归地展开，也就是把所有直接或间接包含的头文件原封不动地插入进来。当这个过程结束之后，才开始编译。</p><span id="more"></span><p>这种编译方式的缺点是会使头文件被重复编译。假如有一百个源文件都包含了Windows.h，那么这个头文件会在一百个源文件中展开，它里面的代码会被重复编译了一百次，尽管每次编译的结果都相同。对于具有成千上万个源文件的大型项目来说，重复编译是难以接受的，会浪费大量的编译时间。</p><p>为了解决这个问题，预编译头应运而生。顾名思义，预编译头就是预先把头文件编译好，在编译源文件的时候直接取用这些编译结果，避免对头文件重复编译。这项技术能大幅提高C++的编译速度。</p><p>Visual C++生成的扩展名为.pch的文件即是预编译头生成的结果。</p><h2 id="如何使用预编译头"><a href="#如何使用预编译头" class="headerlink" title="如何使用预编译头"></a>如何使用预编译头</h2><p>Visual C++对预编译头的设置并不直观，容易造成误解。在这里详细介绍一下如何启用预编译头。以下操作是在Visual Studio 2013上进行的，不过Visual Studio各版本之间的差异不大，更早或更新的版本也适用。</p><p>首先要做的，是在项目中添加一个头文件以及源文件，这两个文件是给预编译头这个机制使用的。它们的名称并没有限制，这里把它们命名为precompiled.h和precompiled.cpp（Visual C++使用的默认名字是StdAfx.h和StdAfx.cpp）。</p><p>precompiled.h将被指定成预编译头文件，所有在这个头文件中的代码都会被预编译。可以把任意代码添加到这个文件，一般的做法是把常用的头文件包含进来，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/format.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>precompiled.cpp则为precompiled.h提供了编译的载体，因为C&#x2F;C++只能对源文件编译，而不能对头文件编译。precompiled.cpp只需要包含precompiled.h即可（由于示例项目的需要，包含语句中包含了相对路径）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;win/precompiled.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>接下来，指定通过precompiled.cpp来生成预编译结果。在“解决方案资源管理器中”，右击precompiled.cpp文件，在弹出的菜单中点击“属性”，打开该文件的属性页窗口。</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/1.png" class=""><p>在属性页窗口中，打开“预编译头”配置页，设置“预编译头”选项的值为“创建（&#x2F;Yc）”，设置“预编译头文件”选项的值为“win&#x2F;precompiled.h”。如下图所示：</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/2.png" class=""><p>点击确定完成设置。如此一来，在编译precompiled.cpp的时候就会生成预编译结果，也就是.pch文件。</p><p>设置了生成预编译结果之后，还需要设置使用预编译结果。在“解决方案资源管理器中”，右击项目节点，在弹出的菜单中点击“属性”，打开项目的属性页窗口。</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/3.png" class=""><p>同样地，在属性页窗口中打开“预编译头”配置页，设置“预编译头”选项的值为“使用（&#x2F;Yu）”，设置“预编译头文件”选项的值为“win&#x2F;precompiled.h”。要注意“预编译头”选项的值跟之前的不同。如下图所示：</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/4.png" class=""><p>最后，需要在所有的源文件中包含预编译头文件，并且该文件必须是第一个包含的。这是使用预编译头的硬性规定，假如不遵守这个规定，编译会失败。重复地在所有源文件中添加预编译头文件很繁琐，所幸的是Visual C++提供了强制在所有源文件中包含指定头文件的选项。同样在项目的属性页窗口中，打开“C&#x2F;C++”分类下的“高级”配置页，在“强制包含文件”的选项中，添加“win&#x2F;precompiled.h”即可，如下图所示：</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/5.png" class=""><p>至此，预编译头的设置就完成了。注意，在预编译头文件之后再重复包含该文件内已包含的头文件并不会有问题，所以不必特意去掉那些重复的包含语句。</p><h2 id="预编译头性能实测"><a href="#预编译头性能实测" class="headerlink" title="预编译头性能实测"></a>预编译头性能实测</h2><p>预编译头对编译性能有多大的提升呢？这里用一个实际的项目进行测试。该项目共有1006个头文件和源文件，分别在关闭和打开预编译头的情况下重新生成整个项目两次，记录下生成的开始时间和结束时间。最终得到的数据如下：</p><img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/6.png" class=""><p>可以看到，使用了预编译头之后，编译性能有了30%以上的提升，节省了不少时间。当然，这里的数据只是一个参考值，实际的提升程度得视项目的具体情况而定。一般来说，预编译头文件中包含的头文件被使用得越多，性能提升越明显。</p><h2 id="使用预编译头的注意事项"><a href="#使用预编译头的注意事项" class="headerlink" title="使用预编译头的注意事项"></a>使用预编译头的注意事项</h2><p>既然预编译头有这样的好处，那么是不是加入预编译的头文件越多越好呢？答案是否定的。上文已经提到，使用预编译头的时候必须在所有源文件中包含预编译头文件，由此造成的影响是，一旦其中的头文件发生了变化，不论这个变化有多细微，整个项目都要重新编译。把一个会被频繁修改的头文件包含到预编译头文件中是非常不明智的做法，因此，理想的选择是下列几乎不会修改的头文件：</p><ul><li>操作系统API头文件，例如Windows.h。</li><li>C&#x2F;C++标准库头文件，例如string。</li><li>第三方库头文件，例如boost&#x2F;filesystem.hpp。</li></ul><p>另外一个要注意的是，C++的预编译头是不能用在C上的，反之亦然。也就是说，假如预编译头是通过.cpp源文件生成的，那么在.c源文件中使用了这个预编译头就会导致编译出错。有方法可以分别为这两种语言生成和使用不同的预编译头，不过这样做稍显复杂，最简单的做法是把源文件的扩展名改成.cpp，统一使用C++即可，这在大部分情况下都是可行的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是预编译头&quot;&gt;&lt;a href=&quot;#什么是预编译头&quot; class=&quot;headerlink&quot; title=&quot;什么是预编译头&quot;&gt;&lt;/a&gt;什么是预编译头&lt;/h2&gt;&lt;p&gt;在介绍预编译头之前，有必要了解一下C&amp;#x2F;C++的编译方式。C&amp;#x2F;C++的编译单元是源文件（带有.c、.cc、.cpp等扩展名的文件），在编译一个源文件之前，预处理器会把这个源文件中所有通过#include指令包含进来的头文件递归地展开，也就是把所有直接或间接包含的头文件原封不动地插入进来。当这个过程结束之后，才开始编译。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="编译" scheme="http://zplutor.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
    <category term="预编译头" scheme="http://zplutor.github.io/tags/%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>使用流式输出写调试日志</title>
    <link href="http://zplutor.github.io/2015/08/29/write-debug-log-streamly/"/>
    <id>http://zplutor.github.io/2015/08/29/write-debug-log-streamly/</id>
    <published>2015-08-29T12:50:54.000Z</published>
    <updated>2016-04-16T12:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>日志是一种有效的调试手段。但是日志写得太频繁会降低程序性能，所以一般采取的策略是，大部分日志只在调试版的程序中输出，少量重要的日志才在发行版的程序中输出。为了控制调试日志的输出，通常会使用下面的简便方法：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLOG(format, ...) printf(format, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLOG(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上面的代码定义了一个DLOG宏，当处于调试模式时，DLOG会展开成对printf函数（或者类似函数）的调用；否则什么也不做。使用这个宏之后，调试日志对发行版程序没有任何影响。</p><p>但是，由于printf固有的特点，使用这种方式写日志存在一些缺陷。最主要的是，格式化字符串中的形参与实参的个数和类型必须一致，否则，要么输出的信息不正确，要么程序直接崩溃。这种问题只有在真正执行的时候才显现出来，假如错误的DLOG调用位于深层次的条件语句中，那么它很可能会一直隐藏在那里。</p><p>不要觉得这种低级错误不会发生。根据实际经验来看，写了一句日志导致程序崩溃的尴尬情况还是挺常见的。</p><p>C++标准库使用的流式输出解决了上述缺陷。所谓流式输出，就像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Today is &quot;</span> &lt;&lt; <span class="number">2015</span> &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">&#x27;.&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这种方式不需要事先定义格式字符串，不必再担心实参个数和类型的匹配问题。更重要的是，如果实参不能被输出，在编译阶段就会出错，而不是等到运行的时候才出错。流式输出使用上更简便，安全性更高，假如能使用这种方式来写日志，无疑会提高开发效率。</p><p>流式输出的使用方式与printf截然不同，显然不能再使用可变参数宏来定义DLOG了。所以接下来的问题是，如何定义DLOG以支持流式输出。要是不能做到在发行版程序中完全消除调试日志的影响，那么它也只是一个不实用的花瓶。</p><p>这个问题看起来似乎很难，实际上并非如此。早已有人找到了解决方法——在Chromium中就是使用流式输出写日志的。Chromium是开源项目，可以直接从它的代码中寻找答案。不过它的相关代码中封装了太多功能，理解起来并不容易。在经过一番抽丝剥茧之后，这里还原出它的核心思想。</p><p>首先，根据是否处于调试模式定义ENABLE_DEBUG_LOG宏，这个宏仅仅是布尔值的简单替换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_DEBUG_LOG true</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_DEBUG_LOG false</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>接下来，把DLOG宏定义成一个问号表达式，为了便于理解，把这个定义分成多行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DLOG()                 \</span></span><br><span class="line"><span class="meta">    ! ENABLE_DEBUG_LOG  ?      \</span></span><br><span class="line"><span class="meta">        (void)0         :      \</span></span><br><span class="line"><span class="meta">        Vodify() &amp; std::cout</span></span><br></pre></td></tr></table></figure><p>问号表达式首先判断一下是否启用调试日志。如果不启用，则执行第一个分支，把0转换成void，也就是什么都不做。这是一种罕见的语法，可以把任意表达式转型为void。如果启用，则执行第二个分支，创建一个Vodify对象，并调用它的&amp;操作符。下面是Vodify类的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vodify</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>&amp;(<span class="type">const</span> std::ostream&amp;) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Vodify类是一个辅助类，它只有一个空的operator&amp;方法，其作用仅仅是为了使问号表达式两个分支的返回值相同。由于前面一个分支的返回值是void，第二个分支的返回值也必须是void，否则编译不通过。</p><p>一个提供了&lt;&lt;操作符的输出流对象必须放在最后面，这是为了接收后面的输出参数。在这里简单使用了std::cout对象。Vodify的operator&amp;方法必须能够接收这个对象的引用。</p><p>现在，可以这样来使用DLOG：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DLOG</span>() &lt;&lt; <span class="string">&quot;Today is &quot;</span> &lt;&lt; <span class="number">2015</span> &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">&#x27;.&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这句代码展开之后变成了下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">! ENABLE_DEBUG_LOG  ?</span><br><span class="line">    (<span class="type">void</span>)<span class="number">0</span>         :</span><br><span class="line">    <span class="built_in">Vodify</span>() &amp; std::cout &lt;&lt; <span class="string">&quot;Today is &quot;</span> &lt;&lt; <span class="number">2015</span> &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">&#x27;.&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果ENABLE_DEBUG_LOG为true，那么第二个分支会执行。&lt;&lt;操作符的优先级比&amp;操作符高，后面的一串&lt;&lt;调用会先执行，最后再调用Vodify对象的&amp;操作符，使整个表达式的返回值为void。</p><p>如果ENABLE_DEBUG_LOG为false，那么第二个分支永远都不会执行，无论它有多复杂。这是在编译期间就可以确定的，在发行版的程序中这部分代码完全可以优化掉，也就达到了调试日志不影响发行版程序的目的。</p><p>基于以上的核心思想，可以衍变出各种不同的版本来支持更丰富的功能，例如日志等级、日志分类等。C++中有很多小技巧，使用得当的话对程序开发有很大帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日志是一种有效的调试手段。但是日志写得太频繁会降低程序性能，所以一般采取的策略是，大部分日志只在调试版的程序中输出，少量重要的日志才在发行版的程序中输出。为了控制调试日志的输出，通常会使用下面的简便方法：&lt;/p&gt;</summary>
    
    
    
    
    <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="流式输出" scheme="http://zplutor.github.io/tags/%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/"/>
    
    <category term="日志" scheme="http://zplutor.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>C++拼接SQL语句的高效方法</title>
    <link href="http://zplutor.github.io/2015/08/14/fast-way-to-concatenate-sql-in-cpp/"/>
    <id>http://zplutor.github.io/2015/08/14/fast-way-to-concatenate-sql-in-cpp/</id>
    <published>2015-08-14T06:18:32.000Z</published>
    <updated>2016-04-16T12:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>访问数据库的应用程序一般都通过字符串拼接的方式来构造SQL语句。例如，可以使用boost的format，或者类似的拼接方法：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string sql = boost::<span class="built_in">str</span>(boost::format(<span class="string">&quot;select %1%, %2%, %3%, %4% from %5% where %1% = ?;&quot;</span>)</span><br><span class="line">                             % kUserIdColumnName</span><br><span class="line">                             % kUserNameColumnName</span><br><span class="line">                             % kUserEmailColumnName</span><br><span class="line">                             % kUserPhoneColumnName</span><br><span class="line">                             % kUserTableName);         </span><br></pre></td></tr></table></figure><p>上面的例子构造了一条从用户信息表获取用户信息的SQL语句，这并没有什么问题。但仔细想想，在运行时构造SQL语句是毫无必要的，因为这种SQL语句基本上不会在程序运行的时候改变。假如每次查询都要进行这样的拼接过程，那么这部分的性能就白白浪费掉了。另一种做法是把sql变量定义成局部静态变量，这样只需要拼接一次就可以了。不过要是这段代码运行在并发环境中，还需要考虑线程安全的问题，这会带来一些额外的工作。</p><p>当然啦，这种重复构造字符串本身的开销是非常小的，一般不会造成性能问题。但如果你是完美主义者，希望榨干最后一滴性能，那么可以考虑一下下面介绍的方法。</p><p>这种方法基于C++的字符串语法糖：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* string = <span class="string">&quot;Curlion is &quot;</span> <span class="string">&quot;a C++ wrapper&quot;</span></span><br><span class="line">                     <span class="string">&quot; for libcurl’s &quot;</span>            <span class="string">&quot;multi socket &quot;</span></span><br><span class="line">                     <span class="string">&quot;interface.&quot;</span>; </span><br></pre></td></tr></table></figure><p>上述语句等效于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* string = <span class="string">&quot;Curlion is a C++ wrapper for libcurl’s multi socket interface.&quot;</span>;</span><br></pre></td></tr></table></figure><p>也就是说，如果两个字符串字面量之间只包含空白字符，那么它们会被合并成一个。这个合并发生在编译时，不消耗运行时时间。</p><p>为了使用这种拼接方式，我们首先要把表名和列名变量修改成用宏来定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kUserTableName <span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kUserIdColumnName <span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kUserNameColumnName <span class="string">&quot;name&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kUserEmailColumnName <span class="string">&quot;email&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kUserPhoneColumnName <span class="string">&quot;phone&quot;</span></span></span><br></pre></td></tr></table></figure>    <p>然后就可以修改拼接方式了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* sql = <span class="string">&quot;select &quot;</span></span><br><span class="line">                  kUserIdColumnName <span class="string">&quot;, &quot;</span></span><br><span class="line">                  kUserNameColumnName <span class="string">&quot;, &quot;</span></span><br><span class="line">                  kUserEmailColumnName <span class="string">&quot;, &quot;</span></span><br><span class="line">                  kUserEmailColumnName <span class="string">&quot;, &quot;</span></span><br><span class="line">                  kUserPhoneColumnName</span><br><span class="line">                  <span class="string">&quot; from &quot;</span> kUserTableName</span><br><span class="line">                  <span class="string">&quot; where &quot;</span> kUserIdColumnName <span class="string">&quot; = ?;&quot;</span>;</span><br></pre></td></tr></table></figure>    <p>这样一来，sql相当于一个常量，不需要初始化，完全不消耗运行时的性能。另外，这么做也有一个好处，就是使得SQL语句的可读性有了一定提高。使用format的方法经常要手工一个个地去匹配参数列表，很繁琐也容易出错。特别是那些有一串长长的参数列表的复杂语句，看起来很恐怖。现在这种方法则好得多，参数直接放在了它所在的位置，一目了然。</p><p>使用宏来定义表名和列名可能会令人感到不安。但我觉得这是宏的合理使用，不会带来什么不良后果，因为表名和列名基本上只会用于SQL语句拼接的场景。有时候为了追求性能或者其他方面的目标，的确要牺牲一些代码的“观赏性”。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;访问数据库的应用程序一般都通过字符串拼接的方式来构造SQL语句。例如，可以使用boost的format，或者类似的拼接方法：&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
    <category term="字符串" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="SQL" scheme="http://zplutor.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>如何设置libcurl的动态超时值</title>
    <link href="http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/"/>
    <id>http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/</id>
    <published>2015-05-22T08:53:03.000Z</published>
    <updated>2016-04-16T12:26:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>针对连接超时，libcurl提供了两个设置选项，分别是CURLOPT_CONNECTTIMEOUT和CURLOPT_TIMEOUT。CURLOPT_CONNECTTIMEOUT设置的是连接阶段的超时值，而CURLOPT_TIMEOUT设置的是整个连接从开始到结束的超时值。libcurl把连接阶段的超时独立出来是好事，它给予了调用者更多的控制权，提高灵活性。但让人不解的是，libcurl没有提供动态超时值的设置，而只能设置固定的超时值。</p><span id="more"></span><p>所谓动态超时值，指的是允许连接空闲的最大时间值，也就是说，只有当连接没有数据传输的时候才开始计算超时时间。这也是平常说的超时的含义。正如上文所说，libcurl对超时的定义是允许连接执行的时间，这个定义在实际应用中会带来问题。例如，每个连接要传输的数据量是不一样的，为了让所有连接都能够正常执行，需要在执行之前计算出确切的超时值。然而这几乎不可能做到，因为网络环境时刻在变化，前一刻计算出来的超时值很快就不合适了。虽然固定超时值也有它特有的用途，但在绝大部分情况下它都不是我们想要的。</p><p>好在libcurl提供了很高的灵活性，我们可以借助另外两个设置选项，变通地实现动态超时值。这两个设置选项是CURLOPT_LOW_SPEED_LIMIT和CURLOPT_LOW_SPEED_TIME，它们的含义是：当连接以低于CURLOPT_LOW_SPEED_LIMIT的速率执行了CURLOPT_LOW_SPEED_TIME的时间时，它就会被终止。一个微妙的地方是，当连接由于这个原因被终止时，它的错误码是CURLE_OPERATION_TIMEOUT。与其说是巧合，倒不如说这是libcurl特意为动态超时值提供的一个更灵活的接口。</p><p>通过这两个设置选项，可以这样来设置动态超时值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">curl_easy_setopt</span>(curl_handle, CURLOPT_LOW_SPEED_LIMIT, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">curl_easy_setopt</span>(curl_handle, CURLOPT_LOW_SPEED_TIME, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>要注意的是，CURLOPT_LOW_SPEED_LIMIT的单位是字节&#x2F;秒，CURLOPT_LOW_SPEED_TIME的单位是秒。这样一来，若在10秒内连接的速率都是低于1字节&#x2F;秒（也就是无数据传输），它就被认为超时了。</p><p>如何设置动态超时值的问题到这里就结束了。但是显然还有另一个问题值得深究：连接的速率是怎么计算的呢？官方文档并没有解释清楚，不过既然libcurl是开源的，那么可以从它的源代码中寻找答案。检查速率的代码位于speedcheck.c的Curl_speedcheck函数中；计算速率的代码位于progress.c的Curl_pgrsUpdate函数中。下面简单解释一下计算速率的过程。</p><p>libcurl使用一个长度为5的循环数组来记录速率信息，速率信息包含了当前时间以及当前总数据量，总数据量取的是总下载数据量和总上传数据量的最大值。每隔一秒钟libcurl就会记录当前的速率信息；由于使用了循环数组，最旧的信息会被丢弃。例如，在第四秒时候，循环数组里的内容是这样的：</p><img src="/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/1.png" class=""><p>第七秒的时候，循环数组里的内容是这样的：</p><img src="/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/2.png" class=""><p>以此类推。接下来，会使用最新的速率信息和最旧的速率信息来计算速率。例如，在第四秒时，速率是这样算的：</p><pre><code>(total4 - total1) / (time4 - time1)</code></pre><p>在第七秒时，速率是这样算的：</p><pre><code>(total7 - total3) / (time7 - time3)</code></pre><p>总之，连接的速率指的是在最近至多五秒内的平均速率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;针对连接超时，libcurl提供了两个设置选项，分别是CURLOPT_CONNECTTIMEOUT和CURLOPT_TIMEOUT。CURLOPT_CONNECTTIMEOUT设置的是连接阶段的超时值，而CURLOPT_TIMEOUT设置的是整个连接从开始到结束的超时值。libcurl把连接阶段的超时独立出来是好事，它给予了调用者更多的控制权，提高灵活性。但让人不解的是，libcurl没有提供动态超时值的设置，而只能设置固定的超时值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="libcurl" scheme="http://zplutor.github.io/tags/libcurl/"/>
    
    <category term="超时" scheme="http://zplutor.github.io/tags/%E8%B6%85%E6%97%B6/"/>
    
  </entry>
  
</feed>
