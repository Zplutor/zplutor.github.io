<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Zplutor's]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://zplutor.github.io/"/>
  <updated>2015-11-24T16:47:52.000Z</updated>
  <id>http://zplutor.github.io/</id>
  
  <author>
    <name><![CDATA[Zplutor]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[RAND_poll函数在Windows下存在的问题]]></title>
    <link href="http://zplutor.github.io/2015/11/25/RAND-poll-function-s-issues-on-Windows/"/>
    <id>http://zplutor.github.io/2015/11/25/RAND-poll-function-s-issues-on-Windows/</id>
    <published>2015-11-24T16:26:09.000Z</published>
    <updated>2015-11-24T16:47:52.000Z</updated>
    <content type="html"><![CDATA[<p>RAND_poll函数是OpenSSL中用于初始化伪随机数生成器的函数，当首次调用诸如RAND_bytes等需要生成随机数的函数时，会先调用该函数进行初始化。在实际使用中发现，RAND_poll函数在Windows下存在一些问题，需要小心提放，否则可能会对程序造成不良影响。</p>
<a id="more"></a>
<h2 id="慢">慢</h2><p>RAND_poll的第一个问题是慢。早在2009年就有人反映这个问题，说这个函数居然要耗费超过一分钟的时间。要明白为什么RAND_poll这么慢，就要了解它的实现原理。为了保证伪随机数的不可预见性，需要用尽可能多的随机信息去初始化生成器，因此RAND_poll尝试收集程序运行时的各种环境信息。其中包括当前进程的内存信息，这是通过枚举每一个堆中已分配的前80个内存块来得到的。即使对于单个堆的数量有限制，总的枚举的次数仍然可能很多，况且用于枚举的API本身性能并不好，导致整体上耗费了大量时间。</p>
<p>这个问题在2009年之后的OpenSSL版本中得到了缓解。之所以说“缓解”，是因为RAND_poll的算法并没有改变，它仍然要枚举每个堆的内存块，只不过在枚举的过程中加上了时间检测，如果发现已经超过一秒就不再继续枚举了。因此，该函数最多耗时一秒多一点，这个时间对于某些场景来说仍然是比较慢的。</p>
<p>关于这个问题的讨论，可以参考 <a href="https://rt.openssl.org/Ticket/Display.html?id=2100&amp;user=guest&amp;pass=guest" target="_blank" rel="external">https://rt.openssl.org/Ticket/Display.html?id=2100&amp;user=guest&amp;pass=guest</a> 。</p>
<h2 id="死锁">死锁</h2><p>RAND_poll的第二个问题是它有一定几率导致死锁。原因还是在于枚举堆内存块——用于枚举的API会把进程所有的堆逐个加锁，在这个过程中，假如有其它线程也在操作堆，那么很有可能导致死锁。</p>
<p>按道理来说，死锁这么严重的问题应该尽早解决，然而奇怪的是，这个问题一直留存至今。综合网上的各种讨论来看，原因或许是这样的：OpenSSL认为这是Windows的问题，一个公开的系统API绝不应该导致程序死锁；而微软则声称这个API仅用于调试目的，不应该在正常的场合下使用。双方都认为这是对方的责任，因此谁都不愿意去修改。</p>
<p>关于这个问题的分析，可以参考 <a href="http://0cch.com/debugging/2015/09/08/foxmail-hung.html" target="_blank" rel="external">http://0cch.com/debugging/2015/09/08/foxmail-hung.html</a> 。</p>
<h2 id="对策">对策</h2><p>综上所述，RAND_poll的两个问题对程序的性能和稳定性都有影响。那么应该如何避免呢？很简单，只需要在程序入口点调用一下RAND_bytes，让它初始化伪随机数生成器即可。之所以在这个时间点来初始化，一是因为这时候堆的数量以及分配的内存块还很少，不会耗费太多时间去枚举；二是因为这时候只有一个主线程，不会有其它线程来同时操作堆，也就不会出现死锁。测试结果显示，在这个时间点调用RAND_poll只用了不到100毫秒的时间。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>RAND_poll函数是OpenSSL中用于初始化伪随机数生成器的函数，当首次调用诸如RAND_bytes等需要生成随机数的函数时，会先调用该函数进行初始化。在实际使用中发现，RAND_poll函数在Windows下存在一些问题，需要小心提放，否则可能会对程序造成不良影响。</p>]]>
    
    </summary>
    
      <category term="OpenSSL" scheme="http://zplutor.github.io/tags/OpenSSL/"/>
    
      <category term="RAND_bytes" scheme="http://zplutor.github.io/tags/RAND-bytes/"/>
    
      <category term="RAND_poll" scheme="http://zplutor.github.io/tags/RAND-poll/"/>
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="性能" scheme="http://zplutor.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="死锁" scheme="http://zplutor.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建一个最简单的Windowless RichEdit]]></title>
    <link href="http://zplutor.github.io/2015/11/22/create-a-simplest-windowless-richedit/"/>
    <id>http://zplutor.github.io/2015/11/22/create-a-simplest-windowless-richedit/</id>
    <published>2015-11-22T13:39:58.000Z</published>
    <updated>2015-11-22T14:27:16.000Z</updated>
    <content type="html"><![CDATA[<p>RichEdit是Windows上很常用的富文本控件，它有一个无窗口化的版本，即Windowless RichEdit，关于它的介绍，可以参考官方文档：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx</a> 。Windowless RichEdit与普通RichEdit在行为表现上毫无二致，但是在使用方法上却有较大的差异；而且Windowless RichEdit的官方文档少之又少，说明不够全面，甚至连一个完整的示例也没有；更甚者，在不同的Windows平台和开发环境下，Windowless RichEdit的用法都有差异。这让初次接触Windowless RichEdit的人举步维艰，处处碰壁，正应了“万事开头难”这句话。因此，本文聚焦于“开头”，介绍一下创建一个最简单的Windowless RichEdit需要做哪些事情。</p>
<a id="more"></a>
<h2 id="Windowless_RichEdit的接口">Windowless RichEdit的接口</h2><p>Windowless RichEdit是一个COM组件，使用者需要用到两个接口，分别是ITexService和ITextHost。ITextService表示Windowless RichEdit控件本身，提供了一系列访问该控件的方法。ITextHost是一个回调接口，需要由使用者实现，并传递给ITextService，当ITextService有需要的时候会调用该接口的方法。</p>
<h2 id="实现ITextHost">实现ITextHost</h2><p>在创建ITextService的时候需要传递一个ITextHost对象给它，所以首先要做的是实现ITextHost。ITextHost定义于TextServ.h，它包含了一系列回调方法，其中下面几个是必须要实现的：</p>
<ul>
<li>TxGetPropertyBits</li>
<li>TxGetCharFormat</li>
<li>TxGetParaFormat</li>
<li>TxGetSysColor</li>
<li>TxGetSelectionBarWidth</li>
</ul>
<p>TxGetPropertyBits用于获取Windowless RichEdit的各种属性，例如是否支持多行，是否支持富文本等。最简单的实现方式是使用默认属性，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetPropertyBits</span><span class="params">(DWORD dwMask, DWORD* pdwBits)</span> override </span>&#123;</span><br><span class="line">    *pdwBits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该方法的返回值不是S_OK，在创建ITextService的时候会失败。</p>
<p>TxGetCharFormat和TxGetParaFormat分别用于获取默认的字符格式和段落格式。字符格式包括字体、大小、颜色、加粗、倾斜等属性；段落格式包括对齐方式等属性。最简单的实现方式是使用默认的格式，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetCharFormat</span><span class="params">(<span class="keyword">const</span> CHARFORMATW** ppCF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (char_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        char_format_ = <span class="built_in">std</span>::make_unique&lt;CHARFORMATW&gt;();</span><br><span class="line">        char_format_-&gt;cbSize = <span class="keyword">sizeof</span>(CHARFORMATW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ppCF = char_format_.get();</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetParaFormat</span><span class="params">(<span class="keyword">const</span> PARAFORMAT** ppPF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (para_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        para_format_ = <span class="built_in">std</span>::make_unique&lt;PARAFORMAT&gt;();    </span><br><span class="line">        para_format_-&gt;cbSize = <span class="keyword">sizeof</span> PARAFORMAT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ppPF = para_format_.get();</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法都要取得结构体的指针，这要求实现者自己来维护这些结构体的生命周期。这里使用std::unique_ptr智能指针来维护这两个结构体，并且把它们作为成员变量。这两个结构体除了cbSize之外，其它字段都可以置为0，表示使用默认设置。</p>
<p>如果这两个方法的返回值不是S_OK，在创建ITextService的时候会失败。</p>
<p>TxGetSysColor用于获取各种默认颜色值，例如背景颜色、字符颜色等。如果没有特殊需求，只要调用GetSysColor即可，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">TxGetSysColor</span><span class="params">(<span class="keyword">int</span> nIndex)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GetSysColor(nIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TxGetSelectionBarWidth用于获取selection bar的宽度。所谓selection bar就是位于控件左侧的竖直长条形区域，这块区域不可见，当鼠标移动到上面时，鼠标指针会水平翻转，此时点击左键就可以快速选择一整行的内容。之所以要实现这个方法，是因为Windowless RichEdit没有初始化表示selection bar宽度的变量，导致这个宽度在大部分情况下远远超出了Windowless RichEdit的可视区域，造成文字绘制不出来的假象。所以初始化这个变量的任务要由实现者来完成了，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxGetSelectionBarWidth</span><span class="params">(LONG *lSelBarWidth)</span> override </span>&#123;</span><br><span class="line">    *lSelBarWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建ITextService">创建ITextService</h2><p>实现了ITextHost之后，即可使用函数CreateTextServices来创建ITextService，该函数也位于TextServ.h，其声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CreateTextServices</span><span class="params">(</span><br><span class="line">    _In_  IUnknown  *punkOuter,</span><br><span class="line">    _In_  ITextHost *pITextHost,</span><br><span class="line">    _Out_ IUnknown  **ppUnk</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数punkOuter用于对象聚合，一般情况下传nullptr即可；第二个参数plTextHost即ITextHost对象；第三个参数ppUnk是获取返回结果的输出参数，注意该参数的实际类型是IUnknown，而不是ITextService，所以之后还要再调用一次QueryInterface来取得ITextService。</p>
<p>官方文档指出使用CreateTextServices时需要导入riched20.lib这个库，但是在Visual Studio 2013环境下是找不到这个文件的，所以只能动态加载riched20.dll并且找出CreateTextServices的地址。更旧的Visual Studio版本可能没有这个问题。</p>
<p>同样的，查询ITextService时用到的IID_ITextService常量也要用这种方式来得到。不过，据说在riched20.dll中导出的IID_ITextService常量是错误的，使用它查询不到ITextService。但在Windows 7下试验过是可以的，可能在这个版本的Windows中已经修复了这个问题。如果从DLL中拿出来的IID_ITextService确实有问题，那么可以自己来定义这个常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTERN_C <span class="keyword">const</span> IID IID_ITextServices = &#123;</span><br><span class="line">    <span class="number">0x8d33f740</span>,</span><br><span class="line">    <span class="number">0xcf58</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9d</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过动态加载DLL来创建ITextService的过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">g_text_host = <span class="built_in">std</span>::make_shared&lt;TextHost&gt;();</span><br><span class="line"></span><br><span class="line">HMODULE module_handle = LoadLibrary(<span class="string">L"riched20.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(_stdcall*CreateTextServicesFunction)</span><span class="params">(IUnknown*, ITextHost*, IUnknown**)</span></span>;</span><br><span class="line">CreateTextServicesFunction create_function = <span class="keyword">reinterpret_cast</span>&lt;CreateTextServicesFunction&gt;(GetProcAddress(module_handle, <span class="string">"CreateTextServices"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IID* iid_text_service = <span class="keyword">reinterpret_cast</span>&lt;IID*&gt;(GetProcAddress(module_handle, <span class="string">"IID_ITextServices"</span>));</span><br><span class="line"></span><br><span class="line">CComPtr&lt;IUnknown&gt; unknown;</span><br><span class="line">create_function(<span class="literal">nullptr</span>, g_text_host.get(), &amp;unknown);</span><br><span class="line">unknown-&gt;QueryInterface(*iid_text_service, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;g_text_service));</span><br></pre></td></tr></table></figure>
<p>上述代码通过LoadLibrary加载riched20.dll，然后通过GetProcAddress得到CreateTextServices和IID_ITextService的地址。注意，当还在使用ITextService的时候，不能调用FreeLibrary卸载riched20.dll，否则会出错。</p>
<h2 id="绘制Windowless_RichEdit">绘制Windowless RichEdit</h2><p>最后要做的就是把Windowless RichEdit显示出来，只要调用ITextService的TxDraw方法即可完成。该方法的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">TxDraw</span><span class="params">(</span><br><span class="line">    DWORD          dwDrawAspect,</span><br><span class="line">    LONG           lindex,</span><br><span class="line">    <span class="keyword">void</span>           *pvAspect,</span><br><span class="line">    DVTARGETDEVICE *ptd,</span><br><span class="line">    HDC            hdcDraw,</span><br><span class="line">    HDC            hicTargetDev,</span><br><span class="line">    LPCRECTL       lprcBounds,</span><br><span class="line">    LPCRECTL       lprcWBounds,</span><br><span class="line">    LPRECT         lprcUpdate,</span><br><span class="line">    BOOL CALLBACK  *pfnContinue,</span><br><span class="line">    DWORD          dwContinue,</span><br><span class="line">    LONG           lViewId</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该方法的参数繁多，但大部分情况下只需要关注其中的<code>dwDrawAspect</code>、<code>hdcDraw</code>和<code>lprcBounds</code>即可。dwDrawAspect指定要绘制控件的哪一部分，传入DVASPECT_CONTENT即可，表示绘制控件内容；hdcDraw即用来绘制的DeviceContext句柄；lprcBounds指定要绘制的区域。其它参数只要指定无效值即可，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RECT rect;</span><br><span class="line">GetClientRect(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">g_text_service-&gt;TxDraw(</span><br><span class="line">    DVASPECT_CONTENT,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    hdc,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;LPCRECTL&gt;(&amp;rect),</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="literal">nullptr</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>lprcBounds的使用的类型是RECTL，与平常使用的RECT不一样，但是它们的定义是一模一样的，因此可以使用强制类型转换。</p>
<h2 id="完整代码">完整代码</h2><p>在本文的最后，附上完整的示例代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;atlbase.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;Richedit.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;TextServ.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TextHost : <span class="keyword">public</span> ITextHost &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HRESULT __<span class="function">stdcall <span class="title">QueryInterface</span><span class="params">(REFIID riid, <span class="keyword">void</span>** ppvObject)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ppvObject == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> E_POINTER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((riid == IID_IUnknown) || (riid == IID_ITextHost)) &#123;</span><br><span class="line">            *ppvObject = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> S_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppvObject = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> E_NOINTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG __<span class="function">stdcall <span class="title">AddRef</span><span class="params">(<span class="keyword">void</span>)</span> override </span>&#123; </span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG __<span class="function">stdcall <span class="title">Release</span><span class="params">(<span class="keyword">void</span>)</span> override </span>&#123; </span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HDC <span class="title">TxGetDC</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">INT <span class="title">TxReleaseDC</span><span class="params">(HDC hdc)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowScrollBar</span><span class="params">(INT fnBar, BOOL fShow)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxEnableScrollBar</span><span class="params">(INT fuSBFlags, INT fuArrowflags)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollRange</span><span class="params">(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetScrollPos</span><span class="params">(INT fnBar, INT nPos, BOOL fRedraw)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxInvalidateRect</span><span class="params">(LPCRECT prc, BOOL fMode)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxViewChange</span><span class="params">(BOOL fUpdate)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxCreateCaret</span><span class="params">(HBITMAP hbmp, INT xWidth, INT yHeight)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxShowCaret</span><span class="params">(BOOL fShow)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetCaretPos</span><span class="params">(INT x, INT y)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxSetTimer</span><span class="params">(UINT idTimer, UINT uTimeout)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxKillTimer</span><span class="params">(UINT idTimer)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxScrollWindowEx</span><span class="params">(INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxSetCapture</span><span class="params">(BOOL fCapture)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxSetFocus</span><span class="params">()</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxSetCursor</span><span class="params">(HCURSOR hcur, BOOL fText)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxScreenToClient</span><span class="params">(LPPOINT lppt)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BOOL <span class="title">TxClientToScreen</span><span class="params">(LPPOINT lppt)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxActivate</span><span class="params">(LONG * plOldState)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxDeactivate</span><span class="params">(LONG lNewState)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetClientRect</span><span class="params">(LPRECT prc)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetViewInset</span><span class="params">(LPRECT prc)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetCharFormat</span><span class="params">(<span class="keyword">const</span> CHARFORMATW **ppCF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (char_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            char_format_ = <span class="built_in">std</span>::make_unique&lt;CHARFORMATW&gt;();</span><br><span class="line">            char_format_-&gt;cbSize = <span class="keyword">sizeof</span>(CHARFORMATW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppCF = char_format_.get();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetParaFormat</span><span class="params">(<span class="keyword">const</span> PARAFORMAT **ppPF)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (para_format_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            para_format_ = <span class="built_in">std</span>::make_unique&lt;PARAFORMAT&gt;();    </span><br><span class="line">            para_format_-&gt;cbSize = <span class="keyword">sizeof</span> PARAFORMAT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppPF = para_format_.get();</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">COLORREF <span class="title">TxGetSysColor</span><span class="params">(<span class="keyword">int</span> nIndex)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GetSysColor(nIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetBackStyle</span><span class="params">(TXTBACKSTYLE *pstyle)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetMaxLength</span><span class="params">(DWORD *plength)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetScrollBars</span><span class="params">(DWORD *pdwScrollBar)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPasswordChar</span><span class="params">(_Out_ TCHAR *pch)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetAcceleratorPos</span><span class="params">(LONG *pcp)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetExtent</span><span class="params">(LPSIZEL lpExtent)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxCharFormatChange</span><span class="params">(<span class="keyword">const</span> CHARFORMATW * pCF)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">OnTxParaFormatChange</span><span class="params">(<span class="keyword">const</span> PARAFORMAT * pPF)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetPropertyBits</span><span class="params">(DWORD dwMask, DWORD *pdwBits)</span> override </span>&#123;</span><br><span class="line">        *pdwBits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxNotify</span><span class="params">(DWORD iNotify, <span class="keyword">void</span> *pv)</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E_NOTIMPL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HIMC <span class="title">TxImmGetContext</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TxImmReleaseContext</span><span class="params">(HIMC himc)</span> override </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HRESULT <span class="title">TxGetSelectionBarWidth</span><span class="params">(LONG *lSelBarWidth)</span> override </span>&#123;</span><br><span class="line">        *lSelBarWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::unique_ptr&lt;CHARFORMATW&gt; char_format_;</span><br><span class="line">    <span class="built_in">std</span>::unique_ptr&lt;PARAFORMAT&gt; para_format_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="keyword">const</span> IID IID_ITextServices = &#123;</span><br><span class="line">    <span class="number">0x8d33f740</span>,</span><br><span class="line">    <span class="number">0xcf58</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9d</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXTERN_C <span class="keyword">const</span> IID IID_ITextHost = &#123;</span><br><span class="line">    <span class="number">0xc5bdd8d0</span>,</span><br><span class="line">    <span class="number">0xd26e</span>,</span><br><span class="line">    <span class="number">0x11ce</span>,</span><br><span class="line">    &#123; <span class="number">0xa8</span>, <span class="number">0x9e</span>, <span class="number">0x00</span>, <span class="number">0xaa</span>, <span class="number">0x00</span>, <span class="number">0x6c</span>, <span class="number">0xad</span>, <span class="number">0xc5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TextHost&gt; g_text_host;</span><br><span class="line">CComPtr&lt;ITextServices&gt; g_text_service;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="keyword">char</span>*, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    WNDCLASSEX default_class = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    default_class.cbSize = <span class="keyword">sizeof</span>(default_class);</span><br><span class="line">    default_class.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    default_class.lpfnWndProc = WindowProcedure;</span><br><span class="line">    default_class.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    default_class.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    default_class.hInstance = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.hIcon = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.hCursor = LoadCursor(<span class="literal">nullptr</span>, IDI_APPLICATION);</span><br><span class="line">    default_class.hbrBackground = <span class="keyword">reinterpret_cast</span>&lt;HBRUSH&gt;(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line">    default_class.lpszMenuName = <span class="literal">nullptr</span>;</span><br><span class="line">    default_class.lpszClassName = <span class="string">L"WindowlessRichEdit"</span>;</span><br><span class="line">    default_class.hIconSm = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    RegisterClassEx(&amp;default_class);</span><br><span class="line"></span><br><span class="line">    HWND window_handle = CreateWindowEx(</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="string">L"WindowlessRichEdit"</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        WS_OVERLAPPEDWINDOW | WS_VISIBLE,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_CREATE: &#123;</span><br><span class="line"></span><br><span class="line">        g_text_host = <span class="built_in">std</span>::make_shared&lt;TextHost&gt;();</span><br><span class="line"></span><br><span class="line">        HMODULE module_handle = LoadLibrary(<span class="string">L"riched20.dll"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(_stdcall*CreateTextServicesFunction)</span><span class="params">(IUnknown*, ITextHost*, IUnknown**)</span></span>;</span><br><span class="line">        CreateTextServicesFunction create_function = <span class="keyword">reinterpret_cast</span>&lt;CreateTextServicesFunction&gt;(GetProcAddress(module_handle, <span class="string">"CreateTextServices"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> IID* iid_text_service = <span class="keyword">reinterpret_cast</span>&lt;IID*&gt;(GetProcAddress(module_handle, <span class="string">"IID_ITextServices"</span>));</span><br><span class="line"></span><br><span class="line">        CComPtr&lt;IUnknown&gt; unknown;</span><br><span class="line">        create_function(<span class="literal">nullptr</span>, g_text_host.get(), &amp;unknown);</span><br><span class="line">        unknown-&gt;QueryInterface(*iid_text_service, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;g_text_service));</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;TxSetText(<span class="string">L"Windowless RichEdit"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_PAINT: &#123;</span><br><span class="line"></span><br><span class="line">        PAINTSTRUCT paint_struct;</span><br><span class="line">        HDC hdc = BeginPaint(hwnd, &amp;paint_struct);</span><br><span class="line"></span><br><span class="line">        RECT rect;</span><br><span class="line">        GetClientRect(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">        g_text_service-&gt;TxDraw(</span><br><span class="line">            DVASPECT_CONTENT,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            hdc,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;LPCRECTL&gt;(&amp;rect),</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        EndPaint(hwnd, &amp;paint_struct);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> CallWindowProc(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>RichEdit是Windows上很常用的富文本控件，它有一个无窗口化的版本，即Windowless RichEdit，关于它的介绍，可以参考官方文档：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx</a> 。Windowless RichEdit与普通RichEdit在行为表现上毫无二致，但是在使用方法上却有较大的差异；而且Windowless RichEdit的官方文档少之又少，说明不够全面，甚至连一个完整的示例也没有；更甚者，在不同的Windows平台和开发环境下，Windowless RichEdit的用法都有差异。这让初次接触Windowless RichEdit的人举步维艰，处处碰壁，正应了“万事开头难”这句话。因此，本文聚焦于“开头”，介绍一下创建一个最简单的Windowless RichEdit需要做哪些事情。</p>]]>
    
    </summary>
    
      <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
      <category term="ITextHost" scheme="http://zplutor.github.io/tags/ITextHost/"/>
    
      <category term="ITextService" scheme="http://zplutor.github.io/tags/ITextService/"/>
    
      <category term="RichEdit" scheme="http://zplutor.github.io/tags/RichEdit/"/>
    
      <category term="Windowless RichEdit" scheme="http://zplutor.github.io/tags/Windowless-RichEdit/"/>
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WM_TIMER消息是否会在消息队列中堆积]]></title>
    <link href="http://zplutor.github.io/2015/11/09/whether-WM-TIMER-message-would-accumulate-in-message-queue/"/>
    <id>http://zplutor.github.io/2015/11/09/whether-WM-TIMER-message-would-accumulate-in-message-queue/</id>
    <published>2015-11-09T15:29:31.000Z</published>
    <updated>2015-11-22T14:09:31.000Z</updated>
    <content type="html"><![CDATA[<p>在Windows界面开发中，启动定时器的最常用方法是使用SetTimer这个API。通过这个API启动的定时器会持续不断地往窗口消息队列中投递WM_TIMER消息，直到调用了KillTimer来停止。一个有趣的问题是，假如定时器的消息程序处理不过来，即处理WM_TIMER的时间比定时器的间隔时间长，会发生什么事情呢？消息队列中是否会堆积越来越多的WM_TIMER消息？官方文档中并没有指出这个问题，只能通过实践来找出答案。</p>
<a id="more"></a>
<p>定时器有多种使用场景，下面针对每种场景分别进行试验。</p>
<h2 id="一个窗口一个定时器">一个窗口一个定时器</h2><p>首先是最简单的使用场景，在一个窗口中启动一个定时器。使用下面的代码生成一个Windows应用程序（为了便于阅读，省略了注册窗口类和创建窗口的代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line">DWORD g_begin_tick_count = <span class="number">0</span>;</span><br><span class="line">DWORD g_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kTimerId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="keyword">char</span>*, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RegisterClassEx(...);</span><br><span class="line">    HWND window_handle = CreateWindowEx(...);</span><br><span class="line"></span><br><span class="line">    g_begin_tick_count = GetTickCount();</span><br><span class="line">    SetTimer(window_handle, kTimerId, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstringstream stream;</span><br><span class="line">        stream &lt;&lt; <span class="string">L"Process WM_TIMER. "</span> </span><br><span class="line">            &lt;&lt; <span class="string">L"TimerId: "</span> &lt;&lt; wParam &lt;&lt; <span class="string">". "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Counter: "</span> &lt;&lt; ++g_counter &lt;&lt; <span class="string">", "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Time: "</span> &lt;&lt; GetTickCount() - g_begin_tick_count &lt;&lt; <span class="string">'.'</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstring <span class="built_in">string</span> = stream.str();</span><br><span class="line">        OutputDebugString(<span class="built_in">string</span>.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_counter &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            Sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> CallWindowProc(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个间隔时间为1秒的定时器，在处理WM_TIMER的时候，输出定时器ID，消息个数以及当前时间。<code>g_counter</code>全局变量记录处理过的WM_TIMER消息的数量；时间的计算使用GetTickCount函数，单位是毫秒。在处理前面4个WM_TIMER的时候，使用Sleep函数使程序挂起5秒，模拟处理时间过长的情景。</p>
<p>程序总的挂起时间是<code>4*5=20</code>秒，在这段时间内，定时器理应触发20次，即投递20个WM_TIMER消息，但是程序只能处理其中的3个（第一个不算）。假如WM_TIMER消息会堆积，那么从第5个开始，由于不再挂起程序，这些堆积的消息可以一口气处理完。观察程序是否会在短时间内连续输出，即可验证这个假设。</p>
<p>启动程序，静置一段时间之后，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.&#10;Process WM_TIMER. TimerId: 1. Counter: 2, Time: 6022.&#10;Process WM_TIMER. TimerId: 1. Counter: 3, Time: 11029.&#10;Process WM_TIMER. TimerId: 1. Counter: 4, Time: 16037.&#10;Process WM_TIMER. TimerId: 1. Counter: 5, Time: 21045.&#10;Process WM_TIMER. TimerId: 1. Counter: 6, Time: 21294.&#10;Process WM_TIMER. TimerId: 1. Counter: 7, Time: 22308.&#10;Process WM_TIMER. TimerId: 1. Counter: 8, Time: 23322.&#10;Process WM_TIMER. TimerId: 1. Counter: 9, Time: 24336.&#10;Process WM_TIMER. TimerId: 1. Counter: 10, Time: 25350.</span><br></pre></td></tr></table></figure>
<p>可以看到，在处理了第5个WM_TIMER消息之后，紧接着就处理了第6个，接下来每隔1秒处理一个，并没有一口气处理了一批。也就是说，WM_TIMER消息并不会堆积。</p>
<h2 id="一个窗口多个定时器">一个窗口多个定时器</h2><p>如果一个窗口中多有个定时器，其中某个定时器处理不过来，对其它的定时器有什么影响呢？继续进行试验，把上面的代码稍作修改，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line">DWORD g_begin_tick_count = <span class="number">0</span>;</span><br><span class="line">DWORD g_counter1 = <span class="number">0</span>;</span><br><span class="line">DWORD g_counter2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kTimerId1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kTimerId2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="keyword">char</span>*, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RegisterClassEx(...);</span><br><span class="line">    HWND window_handle = CreateWindowEx(...);</span><br><span class="line"></span><br><span class="line">    g_begin_tick_count = GetTickCount();</span><br><span class="line">    SetTimer(window_handle, kTimerId1, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    SetTimer(window_handle, kTimerId2, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstringstream stream;</span><br><span class="line">        stream &lt;&lt; <span class="string">L"Process WM_TIMER. "</span> </span><br><span class="line">            &lt;&lt; <span class="string">L"TimerId: "</span> &lt;&lt; wParam &lt;&lt; <span class="string">". "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Counter: "</span> &lt;&lt; (wParam == kTimerId1 ? ++g_counter1 : ++g_counter2) &lt;&lt; <span class="string">", "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Time: "</span> &lt;&lt; GetTickCount() - g_begin_tick_count &lt;&lt; <span class="string">'.'</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstring <span class="built_in">string</span> = stream.str();</span><br><span class="line">        OutputDebugString(<span class="built_in">string</span>.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wParam == kTimerId1) &amp;&amp; (g_counter1 &lt; <span class="number">5</span>)) &#123;</span><br><span class="line">            Sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> CallWindowProc(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了两个间隔都是1秒的定时器，分别用<code>g_counter1</code>和<code>g_counter2</code>两个全局变量来记录它们处理过的WM_TIMER消息的数量。同样地，在处理第一个定时器的前4个WM_TIMER消息时，调用Sleep函数挂起程序5秒。第二个定时器的WM_TIMER消息不做特殊处理。</p>
<p>启动程序，静置一段时间之后，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 2. Counter: 1, Time: 1014.&#10;Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.&#10;Process WM_TIMER. TimerId: 2. Counter: 2, Time: 6022.&#10;Process WM_TIMER. TimerId: 1. Counter: 2, Time: 6022.&#10;Process WM_TIMER. TimerId: 2. Counter: 3, Time: 11030.&#10;Process WM_TIMER. TimerId: 1. Counter: 3, Time: 11030.&#10;Process WM_TIMER. TimerId: 2. Counter: 4, Time: 16037.&#10;Process WM_TIMER. TimerId: 1. Counter: 4, Time: 16037.&#10;Process WM_TIMER. TimerId: 2. Counter: 5, Time: 21045.&#10;Process WM_TIMER. TimerId: 1. Counter: 5, Time: 21045.&#10;Process WM_TIMER. TimerId: 2. Counter: 6, Time: 21295.&#10;Process WM_TIMER. TimerId: 1. Counter: 6, Time: 21295.&#10;Process WM_TIMER. TimerId: 2. Counter: 7, Time: 22309.&#10;Process WM_TIMER. TimerId: 1. Counter: 7, Time: 22309.&#10;Process WM_TIMER. TimerId: 2. Counter: 8, Time: 23323.&#10;Process WM_TIMER. TimerId: 1. Counter: 8, Time: 23323.&#10;Process WM_TIMER. TimerId: 2. Counter: 9, Time: 24337.&#10;Process WM_TIMER. TimerId: 1. Counter: 9, Time: 24337.&#10;Process WM_TIMER. TimerId: 2. Counter: 10, Time: 25351.&#10;Process WM_TIMER. TimerId: 1. Counter: 10, Time: 25351.</span><br></pre></td></tr></table></figure>
<p>两个定时器的行为基本一致，而且跟上一个场景一样，在连续处理了第5个和第6个WM_TIMER消息之后，还是每隔1秒处理一个。可见，第一个定时器处理不过来，会影响到第二个定时器，但是它们的WM_TIMER消息都不会堆积。</p>
<h2 id="多个窗口多个定时器">多个窗口多个定时器</h2><p>最后再看看在不同窗口中启动多个定时器的场景。修改上一个场景的代码，在另一个窗口中创建第二个定时器，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE, HINSTANCE, <span class="keyword">char</span>*, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RegisterClassEx(...);</span><br><span class="line">    HWND window_handle1 = CreateWindowEx(...);</span><br><span class="line">    HWND window_handle2 = CreateWindowEx(...);</span><br><span class="line"></span><br><span class="line">    g_begin_tick_count = GetTickCount();</span><br><span class="line">    SetTimer(window_handle1, kTimerId1, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    SetTimer(window_handle2, kTimerId2, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其余的代码保持不变。</p>
<p>启动程序，静置一段时间之后，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 2. Counter: 1, Time: 1014.&#10;Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.&#10;Process WM_TIMER. TimerId: 2. Counter: 2, Time: 6022.&#10;Process WM_TIMER. TimerId: 1. Counter: 2, Time: 6022.&#10;Process WM_TIMER. TimerId: 2. Counter: 3, Time: 11030.&#10;Process WM_TIMER. TimerId: 1. Counter: 3, Time: 11030.&#10;Process WM_TIMER. TimerId: 2. Counter: 4, Time: 16037.&#10;Process WM_TIMER. TimerId: 1. Counter: 4, Time: 16037.&#10;Process WM_TIMER. TimerId: 2. Counter: 5, Time: 21045.&#10;Process WM_TIMER. TimerId: 1. Counter: 5, Time: 21045.&#10;Process WM_TIMER. TimerId: 2. Counter: 6, Time: 21295.&#10;Process WM_TIMER. TimerId: 1. Counter: 6, Time: 21295.&#10;Process WM_TIMER. TimerId: 2. Counter: 7, Time: 22309.&#10;Process WM_TIMER. TimerId: 1. Counter: 7, Time: 22309.&#10;Process WM_TIMER. TimerId: 2. Counter: 8, Time: 23323.&#10;Process WM_TIMER. TimerId: 1. Counter: 8, Time: 23323.&#10;Process WM_TIMER. TimerId: 2. Counter: 9, Time: 24337.&#10;Process WM_TIMER. TimerId: 1. Counter: 9, Time: 24337.&#10;Process WM_TIMER. TimerId: 2. Counter: 10, Time: 25351.&#10;Process WM_TIMER. TimerId: 1. Counter: 10, Time: 25351.</span><br></pre></td></tr></table></figure>
<p>结果跟第二个场景一模一样，可见即使是不同窗口中的定时器，WM_TIMER消息也不会堆积。</p>
<h2 id="总结">总结</h2><p>经过以上三个场景的试验，可以得出这个结论：同一个定时器的WM_TIMER消息在消息队列中至多存在一个，不会堆积。</p>
<p>要注意的是，即使WM_TIMER消息不会堆积，在使用定时器时仍然要小心避免处理时间比间隔时间长的情况。由试验结果可以看到，一旦出现这种情况，消息队列中总会存在一个WM_TIMER消息等待处理，程序会忙于处理这些WM_TIMER消息，一刻都不停歇，就像陷入了一个循环，这对程序有严重的影响。</p>
<p>由于各种因素的影响，对于同样的处理逻辑，每次执行所用的时间很可能都不一样。所以，如果担心处理时间过长，可以通过更安全的方式来使用定时器，即模拟一次性定时器：在开始处理WM_TIMER消息的时候，调用KillTimer停止定时器；处理完成之后，再调用SetTimer重新开启定时器。例如，把第一个场景中处理WM_TIMER的代码改成以下的安全方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProcedure</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_TIMER: &#123;</span><br><span class="line"></span><br><span class="line">        KillTimer(hwnd, kTimerId);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstringstream stream;</span><br><span class="line">        stream &lt;&lt; <span class="string">L"Process WM_TIMER. "</span> </span><br><span class="line">            &lt;&lt; <span class="string">L"TimerId: "</span> &lt;&lt; wParam &lt;&lt; <span class="string">". "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Counter: "</span> &lt;&lt; ++g_counter &lt;&lt; <span class="string">", "</span></span><br><span class="line">            &lt;&lt; <span class="string">L"Time: "</span> &lt;&lt; GetTickCount() - g_begin_tick_count &lt;&lt; <span class="string">'.'</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::wstring <span class="built_in">string</span> = stream.str();</span><br><span class="line">        OutputDebugString(<span class="built_in">string</span>.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_counter &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            Sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SetTimer(hwnd, kTimerId, <span class="number">1000</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> CallWindowProc(DefWindowProc, hwnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动程序，静置一段时间之后，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process WM_TIMER. TimerId: 1. Counter: 1, Time: 1014.&#10;Process WM_TIMER. TimerId: 1. Counter: 2, Time: 7036.&#10;Process WM_TIMER. TimerId: 1. Counter: 3, Time: 13058.&#10;Process WM_TIMER. TimerId: 1. Counter: 4, Time: 19079.&#10;Process WM_TIMER. TimerId: 1. Counter: 5, Time: 25101.&#10;Process WM_TIMER. TimerId: 1. Counter: 6, Time: 26115.&#10;Process WM_TIMER. TimerId: 1. Counter: 7, Time: 27129.&#10;Process WM_TIMER. TimerId: 1. Counter: 8, Time: 28143.&#10;Process WM_TIMER. TimerId: 1. Counter: 9, Time: 29157.&#10;Process WM_TIMER. TimerId: 1. Counter: 10, Time: 30171.&#10;Process WM_TIMER. TimerId: 1. Counter: 11, Time: 31185.</span><br></pre></td></tr></table></figure>
<p>通过这种方式，不管处理时间有多长，在处理完一个WM_TIMER消息之后，总会真正等待1秒才处理下一个，避免了程序长时间处于繁忙状态的情况。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Windows界面开发中，启动定时器的最常用方法是使用SetTimer这个API。通过这个API启动的定时器会持续不断地往窗口消息队列中投递WM_TIMER消息，直到调用了KillTimer来停止。一个有趣的问题是，假如定时器的消息程序处理不过来，即处理WM_TIMER的时间比定时器的间隔时间长，会发生什么事情呢？消息队列中是否会堆积越来越多的WM_TIMER消息？官方文档中并没有指出这个问题，只能通过实践来找出答案。</p>]]>
    
    </summary>
    
      <category term="WM_TIMER" scheme="http://zplutor.github.io/tags/WM-TIMER/"/>
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="定时器" scheme="http://zplutor.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
      <category term="消息队列" scheme="http://zplutor.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何让std::shared_ptr持有IUnknown对象]]></title>
    <link href="http://zplutor.github.io/2015/10/31/how-to-maintain-iunknown-object-in-shared-ptr/"/>
    <id>http://zplutor.github.io/2015/10/31/how-to-maintain-iunknown-object-in-shared-ptr/</id>
    <published>2015-10-31T03:26:46.000Z</published>
    <updated>2015-11-22T14:09:11.000Z</updated>
    <content type="html"><![CDATA[<p>C++11新增的智能指针std::shared_ptr使用引用计数来管理对象的生命周期，而COM提供的IUnknown接口也使用引用计数来管理自身的生命周期。理论上来说，在同一个环境中不应该同时使用两套引用计数方案，不然会造成混乱，带来很多麻烦。然而实际上，需要同时使用这两种方案的情况并不少见，有时的确需要用std::shared_ptr来持有COM对象。虽然这种做法看上去丑陋，并且是可以用别的方法来避免的，但本文不讨论这些方面，只聚焦于问题的本身。</p>
<a id="more"></a>
<p>得益于std::shared_ptr提供的灵活性，持有COM对象是十分简单的。在默认情况下，当std::shared_ptr的引用计数达到0时，它会调用delete操作符来销毁持有的对象。然而在构造std::shared_ptr的时候，可以传入一个自定义的删除器，来改变它默认的删除行为。删除器可以是函数、仿函数或者lambda表达式等可调用的函数对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> deletor = [](<span class="keyword">int</span>* p) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deleting "</span> &lt;&lt; p &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; i1(<span class="keyword">new</span> <span class="keyword">int</span>(), deletor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; i2 = i1;</span><br><span class="line">    i1.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码用一个lambda表达式作为变量<code>i1</code>的删除器，该删除器在销毁int之前会打印出一行消息。删除器会随着std::shared_ptr一同拷贝或赋值，所以不必担心删除器会丢失。在上面的代码中，变量<code>i2</code>接管了删除器，在程序退出之前依然会打印出那条消息。</p>
<p>显然，对于COM对象来说，只要在删除器里调用Release方法来替换delete操作符即可。下面是将IUnknown对象转成std::shared_ptr的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IUnknown&gt; ConvertToSharedPtr(IUnknown* unknown) &#123;</span><br><span class="line"></span><br><span class="line">    unknown-&gt;AddRef();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IUnknown&gt;(unknown, [](IUnknown* p) &#123; p-&gt;Release(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在将COM对象传递给std::shared_ptr之前务必要调用AddRef方法增加它的引用计数。这样一来，在同一个对象上存在着两个引用计数：IUnknown的引用计数是主要的，只有当这个引用计数达到0时，对象才会被销毁；std::shared_ptr的引用计数是次要的，当这个引用计数达到0时，只会把IUnknown的引用计数减一。两者和谐共存，不会相互影响。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>C++11新增的智能指针std::shared_ptr使用引用计数来管理对象的生命周期，而COM提供的IUnknown接口也使用引用计数来管理自身的生命周期。理论上来说，在同一个环境中不应该同时使用两套引用计数方案，不然会造成混乱，带来很多麻烦。然而实际上，需要同时使用这两种方案的情况并不少见，有时的确需要用std::shared_ptr来持有COM对象。虽然这种做法看上去丑陋，并且是可以用别的方法来避免的，但本文不讨论这些方面，只聚焦于问题的本身。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="COM" scheme="http://zplutor.github.io/tags/COM/"/>
    
      <category term="IUnknown" scheme="http://zplutor.github.io/tags/IUnknown/"/>
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="std::shared_ptr" scheme="http://zplutor.github.io/tags/std-shared-ptr/"/>
    
      <category term="引用计数" scheme="http://zplutor.github.io/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
      <category term="智能指针" scheme="http://zplutor.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何调试在std::thread子线程中抛出的C++异常]]></title>
    <link href="http://zplutor.github.io/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/"/>
    <id>http://zplutor.github.io/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/</id>
    <published>2015-10-11T12:06:41.000Z</published>
    <updated>2015-11-22T14:08:58.000Z</updated>
    <content type="html"><![CDATA[<p>C++11标准库新增的std::thread类可以方便地开启子线程。然而有个奇怪的现象是，如果在这些子线程中抛出了未处理的C++异常而导致程序崩溃，那么在生成的dump文件中将还原不出异常发生时的调用栈。可以通过下面的方法来展示这个现象。</p>
<a id="more"></a>
<p>首先使用以下代码生成一个控制台程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread* g_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.at(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    g_thread = <span class="keyword">new</span> <span class="built_in">std</span>::thread(ThreadEntry);</span><br><span class="line">    g_thread-&gt;join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，就是通过std::thread创建一个子线程，并且在这个子线程中访问一个空的std::vector中的元素，让它抛出C++异常。务必要使用Release配置来生成程序，不能使用Debug配置。</p>
<p>接下来，在资源管理器中直接运行该程序，注意不要通过调试器来运行。一般会在第二次运行的时候，出现下面的Windows错误报告窗口：</p>
<img src="/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/1.png" alt="1.png" title="">
<p>在详细信息中的C:\Users\Zplutor\AppData\Local\Temp\WERBF98.tmp.mdmp文件即是Windows错误报告为崩溃的程序生成的dump文件，里面包含了程序崩溃时的一些信息，例如函数调用栈。该文件在关闭了错误报告窗口时即被删除，所以要先把这个文件复制出来。</p>
<p>最后，用WinDbg打开这个dump文件，先用.ecxr命令切换到异常环境，再用k命令显示调用栈，结果显示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:002&#62; k&#10;  *** Stack trace for last set context - .thread/.cxr resets it&#10;ChildEBP RetAddr  &#10;0095f07c 6ba8dc5f msvcr120!abort+0x38 [f:\dd\vctools\crt\crtw32\misc\abort.c @ 90]&#10;0095f0ac 6b99f353 msvcr120!terminate+0x33 [f:\dd\vctools\crt\crtw32\eh\hooks.cpp @ 96]&#10;0095f8fc 6ba1c01d msvcp120!_Call_func+0x2e [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]&#10;0095f934 6ba1c001 msvcr120!_callthreadstartex+0x1b [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]&#10;0095f940 7685ee6c msvcr120!_threadstartex+0x7c [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]&#10;0095f94c 77053ab3 kernel32!BaseThreadInitThunk+0xe&#10;0095f98c 77053a86 ntdll!__RtlUserThreadStart+0x70&#10;0095f9a4 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure>
<p>可以看到，显示出来的调用栈几乎没有用处，只能看出子线程在开始之后就调用了terminate函数来终止程序，完全看不出来是什么原因导致的。</p>
<p>在调试的时候，如果遇到难以逾越的问题，不妨大胆地进行推测，并根据这些推测进行尝试。推测不一定是正确的，但是在尝试的过程中很可能会发现新的解法。在当前这个例子中，即使不了解std::thread子线程的具体实现，也不难根据上面的调用栈推测出来。下面是一种可能的实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Call_func() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ThreadEntry();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        terminate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_Call_func函数用来调用在std::thread的构造函数中传进来的入口函数，在本例中即是ThreadEntry。该入口函数通过一对try/catch包裹起来，凡是在它里面抛出来的未处理异常都会被捕获，继而调用terminate函数来终止程序。由于terminate是在_Call_func函数中调用的，所以从调用栈上来看，terminate的上一个栈帧必然是_Call_func，ThreadEntry内部的所有栈帧都被跳过了。</p>
<p>根据以上的推测可知，异常发生时的调用栈还原不出来，只是因为它的栈帧被跳过了而已，假如这些栈帧还保留着，那肯定还是能还原出来的。继续观察上述的调用栈，发现_Call_func和terminate的栈帧之间尚有大约2KB（根据ChildEBP计算得来，0095f8fc - 0095f0ac）的内容，因此可以有八九分把握确定被跳过的栈帧就在这里面。</p>
<p>接下来要通过手工方式寻找那些被跳过的栈帧。从terminate栈帧的ChildEBP开始，使用dps命令逐步向上寻找。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:002&#62; dps 0095f0ac l32&#10;0095f0ac  0095f8fc&#10;0095f0b0  6b99f353 msvcp120!_Call_func+0x2e [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]&#10;0095f0b4  6ba097f2 msvcr120!_NLG_Return [f:\dd\vctools\crt\crtw32\eh\i386\lowhelpr.asm @ 64]&#10;0095f0b8  0095f8f0&#10;0095f0bc  0095f37c&#10;0095f0c0  0095f0d0&#10;0095f0c4  0095f8f0&#10;0095f0c8  00000000&#10;0095f0cc  0095f8fc&#10;0095f0d0  0095f0fc&#10;0095f0d4  6ba09861 msvcr120!_CallCatchBlock2+0x4f [f:\dd\vctools\crt\crtw32\eh\i386\trnsctrl.cpp @ 502]&#10;0095f0d8  6b99f34d msvcp120!_Call_func+0x28 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]&#10;0095f0dc  0095f8f0&#10;0095f0e0  00000100&#10;0095f0e4  0095f158&#10;0095f0e8  6ba09ffc msvcr120!CatchGuardHandler [f:\dd\vctools\crt\crtw32\eh\i386\trnsctrl.cpp @ 535]&#10;0095f0ec  c29105eb&#10;0095f0f0  6b9b4bc0 msvcp120!_CTA4?AVsystem_errorstd+0x7c&#10;0095f0f4  0095f8f0&#10;0095f0f8  00000001&#10;0095f0fc  0095f168&#10;0095f100  6ba0999c msvcr120!CallCatchBlock+0x87 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1400]&#10;0095f104  0095f8f0&#10;0095f108  6b9b4bc0 msvcp120!_CTA4?AVsystem_errorstd+0x7c&#10;0095f10c  6b99f34d msvcp120!_Call_func+0x28 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]&#10;0095f110  00000000&#10;0095f114  00000100&#10;0095f118  c2910467&#10;0095f11c  0095f8f0&#10;0095f120  6b9b4bac msvcp120!_CTA4?AVsystem_errorstd+0x68&#10;0095f124  0095f8f0&#10;0095f128  0095f898&#10;0095f12c  00000000&#10;0095f130  00000000&#10;0095f134  00000000&#10;0095f138  00000000&#10;0095f13c  0095f128&#10;0095f140  0095f8dc&#10;0095f144  6b9ff756 msvcr120!_getptd+0x6 [f:\dd\vctools\crt\crtw32\startup\tidtable.c @ 337]&#10;0095f148  00000000&#10;0095f14c  6b99f34d msvcp120!_Call_func+0x28 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 35]&#10;0095f150  0095f118&#10;0095f154  c291048b&#10;0095f158  0095f2a8&#10;0095f15c  6ba0a0d5 msvcr120!_except_handler4 [f:\dd\vctools\crt\crtw32\misc\i386\chandler4gs.c @ 84]&#10;0095f160  a9a46ccf&#10;0095f164  00000001&#10;0095f168  0095f1a4&#10;0095f16c  6ba09a50 msvcr120!CatchIt+0x69 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1211]&#10;0095f170  0095f37c</span><br></pre></td></tr></table></figure>
<p>这个寻找过程需要耐心和运气，因为dps命令输出的结果非常多，而且有些并不是真正的栈帧。在不了解C++异常处理的情况下只能逐个排查，排查的方法是，使用k命令从该栈帧开始回溯调用栈，看看最终能不能到达KiUserExceptionDispatcher的栈帧。例如，可以从上面结果的最后一个栈帧CatchIt开始回溯。要注意，根据栈帧的结构，0095f16c存放的是返回地址，上一个0095f168存放的才是ebp，所以应使用0095f168来回溯。结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:002&#62; k = 0095f168&#10;ChildEBP RetAddr  &#10;0095f07c 6ba8dc5f msvcr120!abort+0x38 [f:\dd\vctools\crt\crtw32\misc\abort.c @ 90]&#10;0095f168 6ba09a50 msvcr120!terminate+0x33 [f:\dd\vctools\crt\crtw32\eh\hooks.cpp @ 96]&#10;0095f1a4 6ba095ab msvcr120!CatchIt+0x69 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 1211]&#10;0095f220 6ba09638 msvcr120!FindHandler+0x27b [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 689]&#10;0095f254 6ba096ba msvcr120!__InternalCxxFrameHandler+0xd6 [f:\dd\vctools\crt\crtw32\eh\frame.cpp @ 439]&#10;0095f290 770372b9 msvcr120!__CxxFrameHandler3+0x26 [f:\dd\vctools\crt\crtw32\eh\i386\trnsctrl.cpp @ 301]&#10;0095f2b4 7703728b ntdll!ExecuteHandler2+0x26&#10;0095f2d8 7700f9d7 ntdll!ExecuteHandler+0x24&#10;0095f364 77037117 ntdll!RtlDispatchException+0x127&#10;0095f364 00000000 ntdll!KiUserExceptionDispatcher+0xf</span><br></pre></td></tr></table></figure>
<p>这个调用栈最终到达了KiUserExceptionDispatcher，也就是我们要找的栈帧。为什么要找KiUserExceptionDispatcher的栈帧呢？这是因为在Windows下所有异常都是通过KiUserExceptionDispatcher这个函数抛出来的，这个函数具有两个类型分别为PEXCEPTION_RECORD和PCONTEXT的参数，分别指向异常信息以及异常发生时的线程环境信息。</p>
<p>既然找到了KiUserExceptionDispatcher的栈帧，那么可以换用kb命令，显示出它的参数列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:002&#62; kb = 0095f168&#10;ChildEBP RetAddr  Args to Child              &#10;&#65288;&#30053;&#65289;&#10;0095f364 00000000 0095f37c 0095f39c 0095f37c ntdll!KiUserExceptionDispatcher+0xf</span><br></pre></td></tr></table></figure>
<p>可知PEXCEPTION_RECORD的值是0095f37c，PCONTEXT的值是0095f39c。</p>
<p>WinDbg提供了.exr命令来显示PEXCEPTION_RECORD的内容，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:002&#62; .exr 0095f37c&#10;ExceptionAddress: 74c4812f (KERNELBASE!RaiseException+0x00000058)&#10;   ExceptionCode: e06d7363 (C++ EH exception)&#10;  ExceptionFlags: 00000001&#10;NumberParameters: 3&#10;   Parameter[0]: 19930520&#10;   Parameter[1]: 0095f898&#10;   Parameter[2]: 6b9b5734&#10;  pExceptionObject: 0095f898&#10;  _s_ThrowInfo    : 6b9b5734&#10;  Type            : class std::out_of_range&#10;  Type            : class std::logic_error&#10;  Type            : class std::exception</span><br></pre></td></tr></table></figure>
<p>可以看到这是一个C++异常，并且类型是std::out_of_range。</p>
<p>WinDbg亦提供了.cxr命令，可以切换到指定PCONTEXT的线程环境，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:002&#62; .cxr 0095f39c&#10;eax=0095f7f8 ebx=00431ee8 ecx=00000003 edx=00000000 esi=6b9b5734 edi=0095f898&#10;eip=74c4812f esp=0095f7f8 ebp=0095f848 iopl=0         nv up ei pl nz ac po nc&#10;cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212&#10;KERNELBASE!RaiseException+0x58:&#10;74c4812f c9              leave</span><br></pre></td></tr></table></figure>
<p>至此，异常发生时的各种寄存器信息一览无余。此时使用k命令即可得到异常发生时的调用栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:002&#62; k&#10;  *** Stack trace for last set context - .thread/.cxr resets it&#10;ChildEBP RetAddr  &#10;0095f848 6ba09339 KERNELBASE!RaiseException+0x58&#10;0095f888 6b983a3a msvcr120!_CxxThrowException+0x5b [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]&#10;0095f8a4 00c2104c msvcp120!std::_Xout_of_range+0x2e [f:\dd\vctools\crt\crtw32\stdcpp\xthrow.cpp @ 24]&#10;0095f8cc 00c211ac ConsoleApplication!ThreadEntry+0x4c [c:\users\zplutor\documents\projects\tests\consoleapplication\main.cpp @ 9]&#10;0095f8d4 6b99f33c ConsoleApplication!std::_LaunchPad&#60;std::_Bind&#60;1,void,void (__cdecl*const)(void)&#62; &#62;::_Go+0xc [c:\program files\microsoft visual studio 12.0\vc\include\thr\xthread @ 187]&#10;0095f8fc 6ba1c01d msvcp120!_Call_func+0x17 [f:\dd\vctools\crt\crtw32\stdcpp\thr\threadcall.cpp @ 28]&#10;0095f934 6ba1c001 msvcr120!_callthreadstartex+0x1b [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]&#10;0095f940 7685ee6c msvcr120!_threadstartex+0x7c [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]&#10;0095f94c 77053ab3 kernel32!BaseThreadInitThunk+0xe&#10;0095f98c 77053a86 ntdll!__RtlUserThreadStart+0x70&#10;0095f9a4 00000000 ntdll!_RtlUserThreadStart+0x1b</span><br></pre></td></tr></table></figure>
<p>本文开头提到的现象并不是std::thread特有的。事实上，如果在捕获了一个异常之后的处理过程中又抛出了一个新的异常，那么旧异常的调用栈会被新异常的调用栈覆盖。在本文的例子中，_Call_func捕获了第一个异常之后，调用了terminate函数，terminate继而又调用了abort函数来抛出新的异常。使用本文提到的方法，就可以应对这种情况，还原出旧异常的调用栈。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>C++11标准库新增的std::thread类可以方便地开启子线程。然而有个奇怪的现象是，如果在这些子线程中抛出了未处理的C++异常而导致程序崩溃，那么在生成的dump文件中将还原不出异常发生时的调用栈。可以通过下面的方法来展示这个现象。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="WinDbg" scheme="http://zplutor.github.io/tags/WinDbg/"/>
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="std::thread" scheme="http://zplutor.github.io/tags/std-thread/"/>
    
      <category term="异常" scheme="http://zplutor.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="线程" scheme="http://zplutor.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用预编译头提高编译速度]]></title>
    <link href="http://zplutor.github.io/2015/09/28/use-precompiled-header-to-speed-up-compilation/"/>
    <id>http://zplutor.github.io/2015/09/28/use-precompiled-header-to-speed-up-compilation/</id>
    <published>2015-09-28T04:00:51.000Z</published>
    <updated>2015-11-22T14:09:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是预编译头">什么是预编译头</h2><p>在介绍预编译头之前，有必要了解一下C/C++的编译方式。C/C++的编译单元是源文件（带有.c、.cc、.cpp等扩展名的文件），在编译一个源文件之前，预处理器会把这个源文件中所有通过#include指令包含进来的头文件递归地展开，也就是把所有直接或间接包含的头文件原封不动地插入进来。当这个过程结束之后，才开始编译。</p>
<a id="more"></a>
<p>这种编译方式的缺点是会使头文件被重复编译。假如有一百个源文件都包含了Windows.h，那么这个头文件会在一百个源文件中展开，它里面的代码会被重复编译了一百次，尽管每次编译的结果都相同。对于具有成千上万个源文件的大型项目来说，重复编译是难以接受的，会浪费大量的编译时间。</p>
<p>为了解决这个问题，预编译头应运而生。顾名思义，预编译头就是预先把头文件编译好，在编译源文件的时候直接取用这些编译结果，避免对头文件重复编译。这项技术能大幅提高C++的编译速度。</p>
<p>Visual C++生成的扩展名为.pch的文件即是预编译头生成的结果。</p>
<h2 id="如何使用预编译头">如何使用预编译头</h2><p>Visual C++对预编译头的设置并不直观，容易造成误解。在这里详细介绍一下如何启用预编译头。以下操作是在Visual Studio 2013上进行的，不过Visual Studio各版本之间的差异不大，更早或更新的版本也适用。</p>
<p>首先要做的，是在项目中添加一个头文件以及源文件，这两个文件是给预编译头这个机制使用的。它们的名称并没有限制，这里把它们命名为precompiled.h和precompiled.cpp（Visual C++使用的默认名字是StdAfx.h和StdAfx.cpp）。</p>
<p>precompiled.h将被指定成预编译头文件，所有在这个头文件中的代码都会被预编译。可以把任意代码添加到这个文件，一般的做法是把常用的头文件包含进来，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;boost/format.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>precompiled.cpp则为precompiled.h提供了编译的载体，因为C/C++只能对源文件编译，而不能对头文件编译。precompiled.cpp只需要包含precompiled.h即可（由于示例项目的需要，包含语句中包含了相对路径）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"win/precompiled.h"</span></span></span><br></pre></td></tr></table></figure>
<p>接下来，指定通过precompiled.cpp来生成预编译结果。在“解决方案资源管理器中”，右击precompiled.cpp文件，在弹出的菜单中点击“属性”，打开该文件的属性页窗口。</p>
<img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/1.png" alt="1.png" title="">
<p>在属性页窗口中，打开“预编译头”配置页，设置“预编译头”选项的值为“创建（/Yc）”，设置“预编译头文件”选项的值为“win/precompiled.h”。如下图所示：</p>
<img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/2.png" alt="2.png" title="">
<p>点击确定完成设置。如此一来，在编译precompiled.cpp的时候就会生成预编译结果，也就是.pch文件。</p>
<p>设置了生成预编译结果之后，还需要设置使用预编译结果。在“解决方案资源管理器中”，右击项目节点，在弹出的菜单中点击“属性”，打开项目的属性页窗口。</p>
<img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/3.png" alt="3.png" title="">
<p>同样地，在属性页窗口中打开“预编译头”配置页，设置“预编译头”选项的值为“使用（/Yu）”，设置“预编译头文件”选项的值为“win/precompiled.h”。要注意“预编译头”选项的值跟之前的不同。如下图所示：</p>
<img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/4.png" alt="4.png" title="">
<p>最后，需要在所有的源文件中包含预编译头文件，并且该文件必须是第一个包含的。这是使用预编译头的硬性规定，假如不遵守这个规定，编译会失败。重复地在所有源文件中添加预编译头文件很繁琐，所幸的是Visual C++提供了强制在所有源文件中包含指定头文件的选项。同样在项目的属性页窗口中，打开“C/C++”分类下的“高级”配置页，在“强制包含文件”的选项中，添加“win/precompiled.h”即可，如下图所示：</p>
<img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/5.png" alt="5.png" title="">
<p>至此，预编译头的设置就完成了。注意，在预编译头文件之后再重复包含该文件内已包含的头文件并不会有问题，所以不必特意去掉那些重复的包含语句。</p>
<h2 id="预编译头性能实测">预编译头性能实测</h2><p>预编译头对编译性能有多大的提升呢？这里用一个实际的项目进行测试。该项目共有1006个头文件和源文件，分别在关闭和打开预编译头的情况下重新生成整个项目两次，记录下生成的开始时间和结束时间。最终得到的数据如下：</p>
<img src="/2015/09/28/use-precompiled-header-to-speed-up-compilation/6.png" alt="6.png" title="">
<p>可以看到，使用了预编译头之后，编译性能有了30%以上的提升，节省了不少时间。当然，这里的数据只是一个参考值，实际的提升程度得视项目的具体情况而定。一般来说，预编译头文件中包含的头文件被使用得越多，性能提升越明显。</p>
<h2 id="使用预编译头的注意事项">使用预编译头的注意事项</h2><p>既然预编译头有这样的好处，那么是不是加入预编译的头文件越多越好呢？答案是否定的。上文已经提到，使用预编译头的时候必须在所有源文件中包含预编译头文件，由此造成的影响是，一旦其中的头文件发生了变化，不论这个变化有多细微，整个项目都要重新编译。把一个会被频繁修改的头文件包含到预编译头文件中是非常不明智的做法，因此，理想的选择是下列几乎不会修改的头文件：</p>
<ul>
<li>操作系统API头文件，例如Windows.h。</li>
<li>C/C++标准库头文件，例如string。</li>
<li>第三方库头文件，例如boost/filesystem.hpp。</li>
</ul>
<p>另外一个要注意的是，C++的预编译头是不能用在C上的，反之亦然。也就是说，假如预编译头是通过.cpp源文件生成的，那么在.c源文件中使用了这个预编译头就会导致编译出错。有方法可以分别为这两种语言生成和使用不同的预编译头，不过这样做稍显复杂，最简单的做法是把源文件的扩展名改成.cpp，统一使用C++即可，这在大部分情况下都是可行的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="什么是预编译头">什么是预编译头</h2><p>在介绍预编译头之前，有必要了解一下C/C++的编译方式。C/C++的编译单元是源文件（带有.c、.cc、.cpp等扩展名的文件），在编译一个源文件之前，预处理器会把这个源文件中所有通过#include指令包含进来的头文件递归地展开，也就是把所有直接或间接包含的头文件原封不动地插入进来。当这个过程结束之后，才开始编译。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="Windows" scheme="http://zplutor.github.io/tags/Windows/"/>
    
      <category term="编译" scheme="http://zplutor.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="预编译头" scheme="http://zplutor.github.io/tags/%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用流式输出写调试日志]]></title>
    <link href="http://zplutor.github.io/2015/08/29/write-debug-log-streamly/"/>
    <id>http://zplutor.github.io/2015/08/29/write-debug-log-streamly/</id>
    <published>2015-08-29T12:50:54.000Z</published>
    <updated>2015-09-28T05:42:21.000Z</updated>
    <content type="html"><![CDATA[<p>日志是一种有效的调试手段。但是日志写得太频繁会降低程序性能，所以一般采取的策略是，大部分日志只在调试版的程序中输出，少量重要的日志才在发行版的程序中输出。为了控制调试日志的输出，通常会使用下面的简便方法：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DLOG(format, ...) printf(format, __VA_ARGS__)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DLOG(format, ...)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个DLOG宏，当处于调试模式时，DLOG会展开成对printf函数（或者类似函数）的调用；否则什么也不做。使用这个宏之后，调试日志对发行版程序没有任何影响。</p>
<p>但是，由于printf固有的特点，使用这种方式写日志存在一些缺陷。最主要的是，格式化字符串中的形参与实参的个数和类型必须一致，否则，要么输出的信息不正确，要么程序直接崩溃。这种问题只有在真正执行的时候才显现出来，假如错误的DLOG调用位于深层次的条件语句中，那么它很可能会一直隐藏在那里。</p>
<p>不要觉得这种低级错误不会发生。根据实际经验来看，写了一句日志导致程序崩溃的尴尬情况还是挺常见的。</p>
<p>C++标准库使用的流式输出解决了上述缺陷。所谓流式输出，就像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Today is "</span> &lt;&lt; <span class="number">2015</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">'.'</span>;</span><br></pre></td></tr></table></figure>
<p>这种方式不需要事先定义格式字符串，不必再担心实参个数和类型的匹配问题。更重要的是，如果实参不能被输出，在编译阶段就会出错，而不是等到运行的时候才出错。流式输出使用上更简便，安全性更高，假如能使用这种方式来写日志，无疑会提高开发效率。</p>
<p>流式输出的使用方式与printf截然不同，显然不能再使用可变参数宏来定义DLOG了。所以接下来的问题是，如何定义DLOG以支持流式输出。要是不能做到在发行版程序中完全消除调试日志的影响，那么它也只是一个不实用的花瓶。</p>
<p>这个问题看起来似乎很难，实际上并非如此。早已有人找到了解决方法——在Chromium中就是使用流式输出写日志的。Chromium是开源项目，可以直接从它的代码中寻找答案。不过它的相关代码中封装了太多功能，理解起来并不容易。在经过一番抽丝剥茧之后，这里还原出它的核心思想。</p>
<p>首先，根据是否处于调试模式定义ENABLE_DEBUG_LOG宏，这个宏仅仅是布尔值的简单替换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ENABLE_DEBUG_LOG true</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ENABLE_DEBUG_LOG false</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>接下来，把DLOG宏定义成一个问号表达式，为了便于理解，把这个定义分成多行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DLOG()                 \</span><br><span class="line">    ! ENABLE_DEBUG_LOG  ?      \</span><br><span class="line">        (void)<span class="number">0</span>         :      \</span><br><span class="line">        Vodify() &amp; std::cout</span></span><br></pre></td></tr></table></figure>
<p>问号表达式首先判断一下是否启用调试日志。如果不启用，则执行第一个分支，把0转换成void，也就是什么都不做。这是一种罕见的语法，可以把任意表达式转型为void。如果启用，则执行第二个分支，创建一个Vodify对象，并调用它的&amp;操作符。下面是Vodify类的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Vodify &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> <span class="built_in">std</span>::ostream&amp;) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Vodify类是一个辅助类，它只有一个空的operator&amp;方法，其作用仅仅是为了使问号表达式两个分支的返回值相同。由于前面一个分支的返回值是void，第二个分支的返回值也必须是void，否则编译不通过。</p>
<p>一个提供了&lt;&lt;操作符的输出流对象必须放在最后面，这是为了接收后面的输出参数。在这里简单使用了std::cout对象。Vodify的operator&amp;方法必须能够接收这个对象的引用。</p>
<p>现在，可以这样来使用DLOG：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DLOG() &lt;&lt; <span class="string">"Today is "</span> &lt;&lt; <span class="number">2015</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">'.'</span>;</span><br></pre></td></tr></table></figure>
<p>这句代码展开之后变成了下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">! ENABLE_DEBUG_LOG  ?</span><br><span class="line">    (<span class="keyword">void</span>)<span class="number">0</span>         :</span><br><span class="line">    Vodify() &amp; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Today is "</span> &lt;&lt; <span class="number">2015</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="number">29</span> &lt;&lt; <span class="string">'.'</span>;</span><br></pre></td></tr></table></figure>
<p>如果ENABLE_DEBUG_LOG为true，那么第二个分支会执行。&lt;&lt;操作符的优先级比&amp;操作符高，后面的一串&lt;&lt;调用会先执行，最后再调用Vodify对象的&amp;操作符，使整个表达式的返回值为void。</p>
<p>如果ENABLE_DEBUG_LOG为false，那么第二个分支永远都不会执行，无论它有多复杂。这是在编译期间就可以确定的，在发行版的程序中这部分代码完全可以优化掉，也就达到了调试日志不影响发行版程序的目的。</p>
<p>基于以上的核心思想，可以衍变出各种不同的版本来支持更丰富的功能，例如日志等级、日志分类等。C++中有很多小技巧，使用得当的话对程序开发有很大帮助。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>日志是一种有效的调试手段。但是日志写得太频繁会降低程序性能，所以一般采取的策略是，大部分日志只在调试版的程序中输出，少量重要的日志才在发行版的程序中输出。为了控制调试日志的输出，通常会使用下面的简便方法：</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="日志" scheme="http://zplutor.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="流式输出" scheme="http://zplutor.github.io/tags/%E6%B5%81%E5%BC%8F%E8%BE%93%E5%87%BA/"/>
    
      <category term="调试" scheme="http://zplutor.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++拼接SQL语句的高效方法]]></title>
    <link href="http://zplutor.github.io/2015/08/14/fast-way-to-concatenate-sql-in-cpp/"/>
    <id>http://zplutor.github.io/2015/08/14/fast-way-to-concatenate-sql-in-cpp/</id>
    <published>2015-08-14T06:18:32.000Z</published>
    <updated>2015-09-28T05:41:17.000Z</updated>
    <content type="html"><![CDATA[<p>访问数据库的应用程序一般都通过字符串拼接的方式来构造SQL语句。例如，可以使用boost的format，或者类似的拼接方法：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> sql = boost::str(boost::format(<span class="string">"select %1%, %2%, %3%, %4% from %5% where %1% = ?;"</span>)</span><br><span class="line">                             % kUserIdColumnName</span><br><span class="line">                             % kUserNameColumnName</span><br><span class="line">                             % kUserEmailColumnName</span><br><span class="line">                             % kUserPhoneColumnName</span><br><span class="line">                             % kUserTableName);</span><br></pre></td></tr></table></figure>
<p>上面的例子构造了一条从用户信息表获取用户信息的SQL语句，这并没有什么问题。但仔细想想，在运行时构造SQL语句是毫无必要的，因为这种SQL语句基本上不会在程序运行的时候改变。假如每次查询都要进行这样的拼接过程，那么这部分的性能就白白浪费掉了。另一种做法是把sql变量定义成局部静态变量，这样只需要拼接一次就可以了。不过要是这段代码运行在并发环境中，还需要考虑线程安全的问题，这会带来一些额外的工作。</p>
<p>当然啦，这种重复构造字符串本身的开销是非常小的，一般不会造成性能问题。但如果你是完美主义者，希望榨干最后一滴性能，那么可以考虑一下下面介绍的方法。</p>
<p>这种方法基于C++的字符串语法糖：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span> = <span class="string">"Curlion is "</span> <span class="string">"a C++ wrapper"</span></span><br><span class="line">                     <span class="string">" for libcurl’s "</span>            <span class="string">"multi socket "</span></span><br><span class="line">                     <span class="string">"interface."</span>;</span><br></pre></td></tr></table></figure>
<p>上述语句等效于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">string</span> = <span class="string">"Curlion is a C++ wrapper for libcurl’s multi socket interface."</span>;</span><br></pre></td></tr></table></figure>
<p>也就是说，如果两个字符串字面量之间只包含空白字符，那么它们会被合并成一个。这个合并发生在编译时，不消耗运行时时间。</p>
<p>为了使用这种拼接方式，我们首先要把表名和列名变量修改成用宏来定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kUserTableName <span class="string">"user"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kUserIdColumnName <span class="string">"id"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kUserNameColumnName <span class="string">"name"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kUserEmailColumnName <span class="string">"email"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> kUserPhoneColumnName <span class="string">"phone"</span></span></span><br></pre></td></tr></table></figure>    
<p>然后就可以修改拼接方式了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* sql = <span class="string">"select "</span></span><br><span class="line">                  kUserIdColumnName <span class="string">", "</span></span><br><span class="line">                  kUserNameColumnName <span class="string">", "</span></span><br><span class="line">                  kUserEmailColumnName <span class="string">", "</span></span><br><span class="line">                  kUserEmailColumnName <span class="string">", "</span></span><br><span class="line">                  kUserPhoneColumnName</span><br><span class="line">                  <span class="string">" from "</span> kUserTableName</span><br><span class="line">                  <span class="string">" where "</span> kUserIdColumnName <span class="string">" = ?;"</span>;</span><br></pre></td></tr></table></figure>    
<p>这样一来，sql相当于一个常量，不需要初始化，完全不消耗运行时的性能。另外，这么做也有一个好处，就是使得SQL语句的可读性有了一定提高。使用format的方法经常要手工一个个地去匹配参数列表，很繁琐也容易出错。特别是那些有一串长长的参数列表的复杂语句，看起来很恐怖。现在这种方法则好得多，参数直接放在了它所在的位置，一目了然。</p>
<p>使用宏来定义表名和列名可能会令人感到不安。但我觉得这是宏的合理使用，不会带来什么不良后果，因为表名和列名基本上只会用于SQL语句拼接的场景。有时候为了追求性能或者其他方面的目标，的确要牺牲一些代码的“观赏性”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>访问数据库的应用程序一般都通过字符串拼接的方式来构造SQL语句。例如，可以使用boost的format，或者类似的拼接方法：</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://zplutor.github.io/tags/C/"/>
    
      <category term="SQL" scheme="http://zplutor.github.io/tags/SQL/"/>
    
      <category term="字符串拼接" scheme="http://zplutor.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何设置libcurl的动态超时值]]></title>
    <link href="http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/"/>
    <id>http://zplutor.github.io/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/</id>
    <published>2015-05-22T08:53:03.000Z</published>
    <updated>2015-09-28T05:41:47.000Z</updated>
    <content type="html"><![CDATA[<p>针对连接超时，libcurl提供了两个设置选项，分别是CURLOPT_CONNECTTIMEOUT和CURLOPT_TIMEOUT。CURLOPT_CONNECTTIMEOUT设置的是连接阶段的超时值，而CURLOPT_TIMEOUT设置的是整个连接从开始到结束的超时值。libcurl把连接阶段的超时独立出来是好事，它给予了调用者更多的控制权，提高灵活性。但让人不解的是，libcurl没有提供动态超时值的设置，而只能设置固定的超时值。</p>
<a id="more"></a>
<p>所谓动态超时值，指的是允许连接空闲的最大时间值，也就是说，只有当连接没有数据传输的时候才开始计算超时时间。这也是平常说的超时的含义。正如上文所说，libcurl对超时的定义是允许连接执行的时间，这个定义在实际应用中会带来问题。例如，每个连接要传输的数据量是不一样的，为了让所有连接都能够正常执行，需要在执行之前计算出确切的超时值。然而这几乎不可能做到，因为网络环境时刻在变化，前一刻计算出来的超时值很快就不合适了。虽然固定超时值也有它特有的用途，但在绝大部分情况下它都不是我们想要的。</p>
<p>好在libcurl提供了很高的灵活性，我们可以借助另外两个设置选项，变通地实现动态超时值。这两个设置选项是CURLOPT_LOW_SPEED_LIMIT和CURLOPT_LOW_SPEED_TIME，它们的含义是：当连接以低于CURLOPT_LOW_SPEED_LIMIT的速率执行了CURLOPT_LOW_SPEED_TIME的时间时，它就会被终止。一个微妙的地方是，当连接由于这个原因被终止时，它的错误码是CURLE_OPERATION_TIMEOUT。与其说是巧合，倒不如说这是libcurl特意为动态超时值提供的一个更灵活的接口。</p>
<p>通过这两个设置选项，可以这样来设置动态超时值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(curl_handle, CURLOPT_LOW_SPEED_LIMIT, <span class="number">1</span>);</span><br><span class="line">curl_easy_setopt(curl_handle, CURLOPT_LOW_SPEED_TIME, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>要注意的是，CURLOPT_LOW_SPEED_LIMIT的单位是字节/秒，CURLOPT_LOW_SPEED_TIME的单位是秒。这样一来，若在10秒内连接的速率都是低于1字节/秒（也就是无数据传输），它就被认为超时了。</p>
<p>如何设置动态超时值的问题到这里就结束了。但是显然还有另一个问题值得深究：连接的速率是怎么计算的呢？官方文档并没有解释清楚，不过既然libcurl是开源的，那么可以从它的源代码中寻找答案。检查速率的代码位于speedcheck.c的Curl_speedcheck函数中；计算速率的代码位于progress.c的Curl_pgrsUpdate函数中。下面简单解释一下计算速率的过程。</p>
<p>libcurl使用一个长度为5的循环数组来记录速率信息，速率信息包含了当前时间以及当前总数据量，总数据量取的是总下载数据量和总上传数据量的最大值。每隔一秒钟libcurl就会记录当前的速率信息；由于使用了循环数组，最旧的信息会被丢弃。例如，在第四秒时候，循环数组里的内容是这样的：</p>
<img src="/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/1.png" alt="1.png" title="">
<p>第七秒的时候，循环数组里的内容是这样的：</p>
<img src="/2015/05/22/how-to-set-dynamic-timeout-for-libcurl/2.png" alt="2.png" title="">
<p>以此类推。接下来，会使用最新的速率信息和最旧的速率信息来计算速率。例如，在第四秒时，速率是这样算的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(total4 - total1) / (time4 - time1)</span><br></pre></td></tr></table></figure>
<p>在第七秒时，速率是这样算的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(total7 - total3) / (time7 - time3)</span><br></pre></td></tr></table></figure>
<p>总之，连接的速率指的是在最近至多五秒内的平均速率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>针对连接超时，libcurl提供了两个设置选项，分别是CURLOPT_CONNECTTIMEOUT和CURLOPT_TIMEOUT。CURLOPT_CONNECTTIMEOUT设置的是连接阶段的超时值，而CURLOPT_TIMEOUT设置的是整个连接从开始到结束的超时值。libcurl把连接阶段的超时独立出来是好事，它给予了调用者更多的控制权，提高灵活性。但让人不解的是，libcurl没有提供动态超时值的设置，而只能设置固定的超时值。</p>]]>
    
    </summary>
    
      <category term="libcurl" scheme="http://zplutor.github.io/tags/libcurl/"/>
    
      <category term="超时" scheme="http://zplutor.github.io/tags/%E8%B6%85%E6%97%B6/"/>
    
  </entry>
  
</feed>
