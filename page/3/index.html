<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta name="google-site-verification" content="C99UqEDEOWXxRodhn8sWg1NRTdOgYZPbS0mgBURT9Pw">
  <meta name="msvalidate.01" content="86FFF123B293617931E24F9B61CA5E1E">
  <meta name="baidu-site-verification" content="GDPyw3Yidj">
  <meta charset="utf-8">
  
  <title>第 3 页 | Zplutor&#39;s</title>
  <meta name="author" content="Zplutor">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Zplutor&#39;s">

  
    <meta property="og:image" content="undefined">
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Zplutor&#39;s" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Zplutor&#39;s</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/atom.xml">Feed</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-01-02T04:13:36.000Z"><a href="/2016/01/02/why-can-t-std-tolower-be-used-with-std-transform/">2016-01-02</a></time>
      
      
  
    <h1 class="title"><a href="/2016/01/02/why-can-t-std-tolower-be-used-with-std-transform/">为什么std::tolower不能用于std::transform</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在C++中，std::tolower和std::toupper函数（在本文中都用std::tolower指代两者）用于对一个字符进行大小写转换，将其与std::transform函数结合则可以对整个字符串进行大小写转换，如下所示：</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/01/02/why-can-t-std-tolower-be-used-with-std-transform/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-06T13:16:04.000Z"><a href="/2015/12/06/implement-an-editable-windowless-richedit/">2015-12-06</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/06/implement-an-editable-windowless-richedit/">实现一个可编辑的Windowless RichEdit</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文在《创建一个最简单的Windowless RichEdit》一文的基础上，介绍如何让Windowless RichEdit支持编辑功能。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/06/implement-an-editable-windowless-richedit/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-28T05:20:30.000Z"><a href="/2015/11/28/keywindow-0-1-2/">2015-11-28</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/28/keywindow-0-1-2/">KeyWindow 0.1.2</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>KeyWindow是一个通过快捷键快速调整窗口布局的工具。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/11/28/keywindow-0-1-2/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-24T16:26:09.000Z"><a href="/2015/11/25/RAND-poll-function-s-issues-on-Windows/">2015-11-25</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/25/RAND-poll-function-s-issues-on-Windows/">RAND_poll函数在Windows下存在的问题</a></h1>
  

    </header>
    <div class="entry">
      
        <p>RAND_poll函数是OpenSSL中用于初始化伪随机数生成器的函数，当首次调用诸如RAND_bytes等需要生成随机数的函数时，会先调用该函数进行初始化。在实际使用中发现，RAND_poll函数在Windows下存在一些问题，需要小心提放，否则可能会对程序造成不良影响。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/11/25/RAND-poll-function-s-issues-on-Windows/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-22T13:39:58.000Z"><a href="/2015/11/22/create-a-simplest-windowless-richedit/">2015-11-22</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/22/create-a-simplest-windowless-richedit/">创建一个最简单的Windowless RichEdit</a></h1>
  

    </header>
    <div class="entry">
      
        <p>RichEdit是Windows上很常用的富文本控件，它有一个无窗口化的版本，即Windowless RichEdit，关于它的介绍，可以参考官方文档：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/bb787609(v=vs.85).aspx</a> 。Windowless RichEdit与普通RichEdit在行为表现上毫无二致，但是在使用方法上却有较大的差异；而且Windowless RichEdit的官方文档少之又少，说明不够全面，甚至连一个完整的示例也没有；更甚者，在不同的Windows平台和开发环境下，Windowless RichEdit的用法都有差异。这让初次接触Windowless RichEdit的人举步维艰，处处碰壁，正应了“万事开头难”这句话。因此，本文聚焦于“开头”，介绍一下创建一个最简单的Windowless RichEdit需要做哪些事情。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/11/22/create-a-simplest-windowless-richedit/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-09T15:29:31.000Z"><a href="/2015/11/09/whether-WM-TIMER-message-would-accumulate-in-message-queue/">2015-11-09</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/09/whether-WM-TIMER-message-would-accumulate-in-message-queue/">WM_TIMER消息是否会在消息队列中堆积</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在Windows界面开发中，启动定时器的最常用方法是使用SetTimer这个API。通过这个API启动的定时器会持续不断地往窗口消息队列中投递WM_TIMER消息，直到调用了KillTimer来停止。一个有趣的问题是，假如定时器的消息程序处理不过来，即处理WM_TIMER的时间比定时器的间隔时间长，会发生什么事情呢？消息队列中是否会堆积越来越多的WM_TIMER消息？官方文档中并没有指出这个问题，只能通过实践来找出答案。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/11/09/whether-WM-TIMER-message-would-accumulate-in-message-queue/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-10-31T03:26:46.000Z"><a href="/2015/10/31/how-to-maintain-iunknown-object-in-shared-ptr/">2015-10-31</a></time>
      
      
  
    <h1 class="title"><a href="/2015/10/31/how-to-maintain-iunknown-object-in-shared-ptr/">如何让std::shared_ptr持有IUnknown对象</a></h1>
  

    </header>
    <div class="entry">
      
        <p>C++11新增的智能指针std::shared_ptr使用引用计数来管理对象的生命周期，而COM提供的IUnknown接口也使用引用计数来管理自身的生命周期。理论上来说，在同一个环境中不应该同时使用两套引用计数方案，不然会造成混乱，带来很多麻烦。然而实际上，需要同时使用这两种方案的情况并不少见，有时的确需要用std::shared_ptr来持有COM对象。虽然这种做法看上去丑陋，并且是可以用别的方法来避免的，但本文不讨论这些方面，只聚焦于问题的本身。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/10/31/how-to-maintain-iunknown-object-in-shared-ptr/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-10-11T12:06:41.000Z"><a href="/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/">2015-10-11</a></time>
      
      
  
    <h1 class="title"><a href="/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/">如何调试在std::thread子线程中抛出的C++异常</a></h1>
  

    </header>
    <div class="entry">
      
        <p>C++11标准库新增的std::thread类可以方便地开启子线程。然而有个奇怪的现象是，如果在这些子线程中抛出了未处理的C++异常而导致程序崩溃，那么在生成的dump文件中将还原不出异常发生时的调用栈。可以通过下面的方法来展示这个现象。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/10/11/how-to-debug-cpp-exception-thrown-within-std-thread/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-09-28T04:00:51.000Z"><a href="/2015/09/28/use-precompiled-header-to-speed-up-compilation/">2015-09-28</a></time>
      
      
  
    <h1 class="title"><a href="/2015/09/28/use-precompiled-header-to-speed-up-compilation/">使用预编译头提高编译速度</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="什么是预编译头"><a href="#什么是预编译头" class="headerlink" title="什么是预编译头"></a>什么是预编译头</h2><p>在介绍预编译头之前，有必要了解一下C/C++的编译方式。C/C++的编译单元是源文件（带有.c、.cc、.cpp等扩展名的文件），在编译一个源文件之前，预处理器会把这个源文件中所有通过#include指令包含进来的头文件递归地展开，也就是把所有直接或间接包含的头文件原封不动地插入进来。当这个过程结束之后，才开始编译。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/09/28/use-precompiled-header-to-speed-up-compilation/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-08-29T12:50:54.000Z"><a href="/2015/08/29/write-debug-log-streamly/">2015-08-29</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/29/write-debug-log-streamly/">使用流式输出写调试日志</a></h1>
  

    </header>
    <div class="entry">
      
        <p>日志是一种有效的调试手段。但是日志写得太频繁会降低程序性能，所以一般采取的策略是，大部分日志只在调试版的程序中输出，少量重要的日志才在发行版的程序中输出。为了控制调试日志的输出，通常会使用下面的简便方法：</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/08/29/write-debug-log-streamly/#more" class="more-link">阅读全文</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/4/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/C/">C++</a><small>14</small></li>
  
    <li><a href="/tags/COM/">COM</a><small>3</small></li>
  
    <li><a href="/tags/ITextHost/">ITextHost</a><small>2</small></li>
  
    <li><a href="/tags/ITextService/">ITextService</a><small>2</small></li>
  
    <li><a href="/tags/IUnknown/">IUnknown</a><small>1</small></li>
  
    <li><a href="/tags/KeyWindow/">KeyWindow</a><small>1</small></li>
  
    <li><a href="/tags/OpenSSL/">OpenSSL</a><small>1</small></li>
  
    <li><a href="/tags/RAND-bytes/">RAND_bytes</a><small>1</small></li>
  
    <li><a href="/tags/RAND-poll/">RAND_poll</a><small>1</small></li>
  
    <li><a href="/tags/RichEdit/">RichEdit</a><small>2</small></li>
  
    <li><a href="/tags/SQL/">SQL</a><small>1</small></li>
  
    <li><a href="/tags/STL/">STL</a><small>5</small></li>
  
    <li><a href="/tags/Visual-Studio/">Visual Studio</a><small>1</small></li>
  
    <li><a href="/tags/WM-TIMER/">WM_TIMER</a><small>1</small></li>
  
    <li><a href="/tags/WinDbg/">WinDbg</a><small>1</small></li>
  
    <li><a href="/tags/Windowless-RichEdit/">Windowless RichEdit</a><small>2</small></li>
  
    <li><a href="/tags/Windows/">Windows</a><small>21</small></li>
  
    <li><a href="/tags/XCode/">XCode</a><small>1</small></li>
  
    <li><a href="/tags/boost/">boost</a><small>4</small></li>
  
    <li><a href="/tags/libcurl/">libcurl</a><small>2</small></li>
  
    <li><a href="/tags/macOS/">macOS</a><small>2</small></li>
  
    <li><a href="/tags/procdump/">procdump</a><small>1</small></li>
  
    <li><a href="/tags/内存泄露/">内存泄露</a><small>1</small></li>
  
    <li><a href="/tags/内核对象/">内核对象</a><small>1</small></li>
  
    <li><a href="/tags/单例/">单例</a><small>1</small></li>
  
    <li><a href="/tags/字符串/">字符串</a><small>4</small></li>
  
    <li><a href="/tags/字符编码/">字符编码</a><small>2</small></li>
  
    <li><a href="/tags/定时器/">定时器</a><small>2</small></li>
  
    <li><a href="/tags/异常/">异常</a><small>3</small></li>
  
    <li><a href="/tags/引用计数/">引用计数</a><small>1</small></li>
  
    <li><a href="/tags/性能/">性能</a><small>2</small></li>
  
    <li><a href="/tags/日志/">日志</a><small>1</small></li>
  
    <li><a href="/tags/智能指针/">智能指针</a><small>1</small></li>
  
    <li><a href="/tags/死锁/">死锁</a><small>1</small></li>
  
    <li><a href="/tags/流式输出/">流式输出</a><small>1</small></li>
  
    <li><a href="/tags/消息队列/">消息队列</a><small>1</small></li>
  
    <li><a href="/tags/线程/">线程</a><small>2</small></li>
  
    <li><a href="/tags/继承/">继承</a><small>1</small></li>
  
    <li><a href="/tags/编译/">编译</a><small>1</small></li>
  
    <li><a href="/tags/调试/">调试</a><small>5</small></li>
  
    <li><a href="/tags/超时/">超时</a><small>2</small></li>
  
    <li><a href="/tags/预编译头/">预编译头</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 Zplutor
  
</div>
<div class="clearfix"></div></footer>
  
</body>
</html>
